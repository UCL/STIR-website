<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STIR: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STIR
   &#160;<span id="projectnumber">4.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000097"></a>Module <a class="el" href="namespacestir.html#amgrp5712f4ee7ca82d662948449b6a193517">A collection of error functions.</a>  </dt>
<dd>replace with boost::erf  </dd>
<dt><a class="anchor" id="_todo000097"></a>Module <a class="el" href="namespacestir.html#amgrp5712f4ee7ca82d662948449b6a193517">A collection of error functions.</a>  </dt>
<dd>replace with boost::erf  </dd>
<dt><a class="anchor" id="_todo000097"></a>Module <a class="el" href="namespacestir.html#amgrp5712f4ee7ca82d662948449b6a193517">A collection of error functions.</a>  </dt>
<dd>replace with boost::erf  </dd>
<dt><a class="anchor" id="_todo000216"></a>File <a class="el" href="abs__image_8cxx.html">abs_image.cxx</a>  </dt>
<dd>Potentially, in the future it should be included in stir_math as an option. </dd>
<dt><a class="anchor" id="_todo000217"></a>File <a class="el" href="apply__normfactors_8cxx.html">apply_normfactors.cxx</a>  </dt>
<dd>should be replaced by using <a class="el" href="classstir_1_1BinNormalisationFromML2D.html" title="A BinNormalisation class that gets the normalisation factors from the files output by find_ML_normfac...">stir::BinNormalisationFromML2D</a> </dd>
<dt><a class="anchor" id="_todo000197"></a>File <a class="el" href="apply__patlak__to__images_8cxx.html">apply_patlak_to_images.cxx</a>  </dt>
<dd><p class="startdd">Reimplement the method for image-based input function.</p>
<p class="enddd">Add to the Doxygen documentation a reference to their paper and how exactly this utility works.  </p>
</dd>
<dt><a class="anchor" id="_todo000218"></a>File <a class="el" href="attenuation__coefficients__to__projections_8cxx.html">attenuation_coefficients_to_projections.cxx</a>  </dt>
<dd>get threshold from command line </dd>
<dt><a class="anchor" id="_todo000123"></a>File <a class="el" href="BackProjectorByBinNiftyPET_8h.html">BackProjectorByBinNiftyPET.h</a>  </dt>
<dd><p class="startdd">NiftyPET limitations - currently limited to the Siemens mMR scanner and requires to CUDA.</p>
<p class="enddd">STIR wrapper limitations - currently only projects all of the data (no subsets). NiftyPET currently supports spans 0, 1 and 11, but the STIR wrapper has only been tested for span-11. </p>
</dd>
<dt><a class="anchor" id="_todo000016"></a>File <a class="el" href="BasicCoordinate_8h.html">BasicCoordinate.h</a>  </dt>
<dd>The arithmetic operations might at some point be moved to a derived class stir::CartesianCoordinate.  </dd>
<dt><a class="anchor" id="_todo000202"></a>File <a class="el" href="BinNormalisationFromECAT8_8cxx.html">BinNormalisationFromECAT8.cxx</a>  </dt>
<dd>merge ECAT7 and 8 code </dd>
<dt><a class="anchor" id="_todo000203"></a>File <a class="el" href="BinNormalisationFromGEHDF5_8cxx.html">BinNormalisationFromGEHDF5.cxx</a>  </dt>
<dd>remove duplication </dd>
<dt><a class="anchor" id="_todo000005"></a>File <a class="el" href="Bland__Altman__plot_8cxx.html">Bland_Altman_plot.cxx</a>  </dt>
<dd>Add to the Doxygen documentation a reference to their paper and how exactly this utility works.  </dd>
<dt><a class="anchor" id="_todo000219"></a>File <a class="el" href="construct__randoms__from__GEsingles_8cxx.html">construct_randoms_from_GEsingles.cxx</a>  </dt>
<dd>We currently assume F-18 for decay. </dd>
<dt><a class="anchor" id="_todo000221"></a>File <a class="el" href="convecat6__if_8cxx.html">convecat6_if.cxx</a>  </dt>
<dd>This could easily be used to convert to other file formats. For images, this simply involves changing the <a class="el" href="classstir_1_1OutputFileFormat.html" title="Base class for classes that create output files. ">OutputFileFormat</a>. For projection data, we would have to extend <a class="el" href="classstir_1_1OutputFileFormat.html" title="Base class for classes that create output files. ">OutputFileFormat</a> to handle projection data.  </dd>
<dt><a class="anchor" id="_todo000031"></a>Module <a class="el" href="group__data__buildblock.html">data_buildblock</a>  </dt>
<dd>move projection data etc in here  </dd>
<dt><a class="anchor" id="_todo000204"></a>File <a class="el" href="distributableMPICacheEnabled_8cxx.html">distributableMPICacheEnabled.cxx</a>  </dt>
<dd>merge with <a class="el" href="distributable_8cxx.html" title="Implementation of stir::distributable_computation() and related functions. ">distributable.cxx</a> </dd>
<dt><a class="anchor" id="_todo000116"></a>File <a class="el" href="distributed__test__functions_8h.html">distributed_test_functions.h</a>  </dt>
<dd>Currently no independent test functions are implemented. The tests are used by embedding them into the reconstruction functions and calling them once.  </dd>
<dt><a class="anchor" id="_todo000125"></a>File <a class="el" href="ForwardProjectorByBinNiftyPET_8h.html">ForwardProjectorByBinNiftyPET.h</a>  </dt>
<dd><p class="startdd">NiftyPET limitations - currently limited to the Siemens mMR scanner and requires to CUDA.</p>
<p class="enddd">STIR wrapper limitations - currently only projects all of the data (no subsets). NiftyPET currently supports spans 0, 1 and 11, but the STIR wrapper has only been tested for span-11. </p>
</dd>
<dt><a class="anchor" id="_todo000222"></a>File <a class="el" href="generate__image_8cxx.html">generate_image.cxx</a>  </dt>
<dd>Code duplicates things from <a class="el" href="classstir_1_1InterfileHeader.html" title="a class for Interfile keywords (and parsing) common to all types of data ">stir::InterfileHeader</a>. This is bad as it might miss new features being added there.  </dd>
<dt><a class="anchor" id="_todo000199"></a>File <a class="el" href="get__dynamic__images__from__parametric__images_8cxx.html">get_dynamic_images_from_parametric_images.cxx</a>  </dt>
<dd>Add to the Doxygen documentation how exactly this utility works. </dd>
<dt><a class="anchor" id="_todo000041"></a>File <a class="el" href="index__at__maximum_8h.html">index_at_maximum.h</a>  </dt>
<dd>move implementations to .cxx  </dd>
<dt><a class="anchor" id="_todo000040"></a>File <a class="el" href="line__distances_8h.html">line_distances.h</a>  </dt>
<dd>move implementations to .cxx  </dd>
<dt><a class="anchor" id="_todo000006"></a>File <a class="el" href="line__profiles__through__projdata_8cxx.html">line_profiles_through_projdata.cxx</a>  </dt>
<dd>put the output profile name as a first argument after the command, to follow <em>STIR</em> conventions. </dd>
<dt><a class="anchor" id="_todo000007"></a>File <a class="el" href="list__TAC__ROI__values_8cxx.html">list_TAC_ROI_values.cxx</a>  </dt>
<dd><p class="startdd">Add the &ndash;V option to include the volume information for the sample region. </p>
<p class="enddd">Merge it with the <a class="el" href="list__ROI__values_8cxx.html" title="Utility program for getting ROI values. ">list_ROI_values.cxx</a> utility.  </p>
</dd>
<dt><a class="anchor" id="_todo000077"></a>File <a class="el" href="LmToProjDataNiftyPET_8h.html">LmToProjDataNiftyPET.h</a>  </dt>
<dd><p class="startdd">NiftyPET limitations - currently limited to the Siemens mMR scanner and requires to CUDA.</p>
<p class="enddd">STIR wrapper limitations - currently only projects all of the data (no subsets). NiftyPET currently supports spans 0, 1 and 11, but the STIR wrapper has only been tested for span-11. </p>
</dd>
<dt><a class="anchor" id="_todo000200"></a>File <a class="el" href="mult__image__parameters_8cxx.html">mult_image_parameters.cxx</a>  </dt>
<dd><p class="startdd">Make a generic utility which will multiply all the parameters together and store them in a multiple image file. </p>
<p class="enddd">It might be possible to integrate it into the <a class="el" href="stir__math_8cxx.html" title="add or multiply data, with some other basic math manipulations ">stir_math.cxx</a>, in the future. </p>
</dd>
<dt><a class="anchor" id="_todo000201"></a>File <a class="el" href="mult__model__with__dyn__images_8cxx.html">mult_model_with_dyn_images.cxx</a>  </dt>
<dd>Add to the Doxygen documentation how exactly this utility works. </dd>
<dt><a class="anchor" id="_todo000127"></a>File <a class="el" href="NiftyPETHelper_8h.html">NiftyPETHelper.h</a>  </dt>
<dd><p class="startdd">NiftyPET limitations - currently limited to the Siemens mMR scanner and requires to CUDA.</p>
<p class="enddd">STIR wrapper limitations - currently only projects all of the data (no subsets). NiftyPET currently supports spans 0, 1 and 11, but the STIR wrapper has only been tested for span-11. </p>
</dd>
<dt><a class="anchor" id="_todo000146"></a>Namespace <a class="el" href="namespaceSPECTUB.html">SPECTUB</a>  </dt>
<dd>Variables wm, wmh and Rrad are currently global variables. This means that this code would be very dangerous in a parallel setting.  </dd>
<dt><a class="anchor" id="_todo000108"></a>Class <a class="el" href="classstir_1_1AnalyticReconstruction.html">stir::AnalyticReconstruction</a>  </dt>
<dd>Currently the template argument uses <a class="el" href="classstir_1_1DiscretisedDensity.html" title="This abstract class is the basis for all image representations. ">DiscretisedDensity</a> because of conversion problems with stir::shared_ptr. Maybe it will be possible to correct this once we use boost:shared_ptr.  </dd>
<dt><a class="anchor" id="_todo000020"></a>Member <a class="el" href="group__Coordinate.html#ga534d8b44ffea46fe900b00257bc804dc">stir::angle</a>  (const BasicCoordinate&lt; num_dimensions, coordT &gt; &amp;p1, const BasicCoordinate&lt; num_dimensions, coordT &gt; &amp;p2)</dt>
<dd>move to a new CartesianCoordinate class  </dd>
<dt><a class="anchor" id="_todo000015"></a>Member <a class="el" href="group__Array.html#gaf86ba23c82d49d0fc41609a760dca0a3">stir::apply_array_functions_on_each_index</a>  (Array&lt; num_dim, elemT &gt; &amp;out_array, const Array&lt; num_dim, elemT &gt; &amp;in_array, ActualFunctionObjectPtrIter start, ActualFunctionObjectPtrIter stop)</dt>
<dd>Modify such that this function would handle function objects and (smart) pointers to <a class="el" href="classstir_1_1ArrayFunctionObject.html" title="A class for operations on n-dimensional Arrays. ">ArrayFunctionObject</a> objects. At the moment, it's only the latter.  </dd>
<dt><a class="anchor" id="_todo000014"></a>Member <a class="el" href="group__Array.html#gacc9c7a9df2f7a64dae97b59371d35668">stir::apply_array_functions_on_each_index</a>  (Array&lt; num_dim, elemT &gt; &amp;out_array, const Array&lt; num_dim, elemT &gt; &amp;in_array, FunctionObjectPtrIter start, FunctionObjectPtrIter stop)</dt>
<dd>Add a specialisation such that this function would handle iterators of function objects and (smart) pointers to function objects. At the moment, it's only the latter.  </dd>
<dt><a class="anchor" id="_todo000008"></a>Member <a class="el" href="classstir_1_1ArcCorrection.html#a17cb23483fe4c53cb9be836faa308f9f">stir::ArcCorrection::get_arc_corrected_proj_data_info_sptr</a>  () const</dt>
<dd>return a shared_ptr&lt;ProjDataInfoCylindricalArcCorr&gt; after switching to <a class="el" href="classboost_1_1shared__ptr.html" title="A smart pointer class: multiple shared_ptr&#39;s refer to one object. ">boost::shared_ptr</a>.  </dd>
<dt><a class="anchor" id="_todo000009"></a>Member <a class="el" href="classstir_1_1ArcCorrection.html#ae7e1b762bd50e07ca8279288604dfad4">stir::ArcCorrection::get_not_arc_corrected_proj_data_info_sptr</a>  () const</dt>
<dd>return a shared_ptr&lt;ProjDataInfoCylindricalNoArcCorr&gt; after switching to <a class="el" href="classboost_1_1shared__ptr.html" title="A smart pointer class: multiple shared_ptr&#39;s refer to one object. ">boost::shared_ptr</a>.  </dd>
<dt><a class="anchor" id="_todo000011"></a>Class <a class="el" href="classstir_1_1ArrayFilter1DUsingConvolution.html">stir::ArrayFilter1DUsingConvolution&lt; elemT &gt;</a>  </dt>
<dd>implement other boundary conditions  </dd>
<dt><a class="anchor" id="_todo000022"></a>Member <a class="el" href="classstir_1_1Bin.html#a6b10aa726aa5134c329daddd6fdf43a8">stir::Bin::operator/=</a>  (const float dx)</dt>
<dd>It is zero division proof in a similar way to <a class="el" href="group__numerics.html#ga2135eeda219aa6700b50580389a12771" title="division of two ranges, 0/0 = 0 ">divide&lt;,,&gt;()</a>, though I am not sure if it should be.  </dd>
<dt><a class="anchor" id="_todo000109"></a>Class <a class="el" href="classstir_1_1BinNormalisationFromAttenuationImage.html">stir::BinNormalisationFromAttenuationImage</a>  </dt>
<dd>Add mechanism for caching the attenuation correction factors, such that they will be calculated only once. However, caching should by default be disabled, as most applications need them only once anyway. </dd>
<dt><a class="anchor" id="_todo000092"></a>Class <a class="el" href="classstir_1_1BSpline_1_1BSplines1DRegularGrid.html">stir::BSpline::BSplines1DRegularGrid&lt; out_elemT, in_elemT, constantsT &gt;</a>  </dt>
<dd>remove overlap with the n-dimensional version <a class="el" href="classstir_1_1BSpline_1_1BSplinesRegularGrid.html" title="A class for n-dimensional BSpline interpolation when the input samples are on a regular grid...">BSplinesRegularGrid</a>  </dd>
<dt><a class="anchor" id="_todo000095"></a>Member <a class="el" href="classstir_1_1BSpline_1_1BSplinesRegularGrid.html#a6c92405a5f4291393e4f2f7c2eb5470f">stir::BSpline::BSplinesRegularGrid&lt; num_dimensions, out_elemT, in_elemT, constantsT &gt;::gradient</a>  (const BasicCoordinate&lt; num_dimensions, pos_type &gt; &amp;relative_positions) const</dt>
<dd>should probably be templated in pos_type.  </dd>
<dt><a class="anchor" id="_todo000094"></a>Member <a class="el" href="classstir_1_1BSpline_1_1BSplinesRegularGrid.html#a76124164c4e6d493d463fc13cbf8f17a">stir::BSpline::BSplinesRegularGrid&lt; num_dimensions, out_elemT, in_elemT, constantsT &gt;::operator()</a>  (const BasicCoordinate&lt; num_dimensions, pos_type &gt; &amp;relative_positions) const</dt>
<dd>should probably be templated in pos_type.  </dd>
<dt><a class="anchor" id="_todo000093"></a>Member <a class="el" href="classstir_1_1BSpline_1_1BSplinesRegularGrid.html#acd326394fa6d854d1f6be78d4db0f326">stir::BSpline::BSplinesRegularGrid&lt; num_dimensions, out_elemT, in_elemT, constantsT &gt;::set_coef</a>  (const Array&lt; num_dimensions, in_elemT &gt; &amp;input)</dt>
<dd>rename  </dd>
<dt><a class="anchor" id="_todo000067"></a>Class <a class="el" href="classstir_1_1CListEvent.html">stir::CListEvent</a>  </dt>
<dd>this is still under development. Things to add are for instance energy windows and time-of-flight info. Also, <a class="el" href="classstir_1_1ListEvent.html#a7a9623d9cfd546d8047c92c981199090" title="Finds the bin coordinates of this event for some characteristics of the projection data...">get_bin()</a> would need time info or so for rotating scanners. </dd>
<dt><a class="anchor" id="_todo000059"></a>Class <a class="el" href="classstir_1_1CListModeData.html">stir::CListModeData</a>  </dt>
<dd>Currently, this class (and CListRecord) is specific to PET, i.e. to coincidence detection (hence the 'C'). However, the only part that is not general are the functions related to prompts and delayeds. Potentially, we make classes <a class="el" href="classstir_1_1ListModeData.html" title="The base class for reading list mode data. ">ListModeData</a> etc which would work for SPECT (and other count-based modalities?). Alternatively, SPECT can be handled by calling all single photon events 'prompts'. </dd>
<dt><a class="anchor" id="_todo000066"></a>Member <a class="el" href="classstir_1_1CListModeDataSAFIR.html#a86edf8018e4e552f76e7f0ce6751be38">stir::CListModeDataSAFIR&lt; CListRecordT &gt;::has_delayeds</a>  () const</dt>
<dd>Implement this properly to check for delayed events in LM files.  </dd>
<dt><a class="anchor" id="_todo000065"></a>Member <a class="el" href="classstir_1_1CListModeDataSAFIR.html#a72ec088fe616361868293aa2b6afc338">stir::CListModeDataSAFIR&lt; CListRecordT &gt;::save_get_position</a>  ()</dt>
<dd>Maybe provide real implementation?  </dd>
<dt><a class="anchor" id="_todo000164"></a>Class <a class="el" href="classstir_1_1CombinedShape3D.html">stir::CombinedShape3D&lt; operation &gt;</a>  </dt>
<dd><p class="startdd">document more </p>
<p class="enddd">Parsing cannot work yet because of template (can be solved by explicit instantiation) </p>
</dd>
<dt><a class="anchor" id="_todo000220"></a>Class <a class="el" href="classstir_1_1CorrectProjDataApplication.html">stir::CorrectProjDataApplication</a>  </dt>
<dd>Preliminary class interface. At some point, this class should move to the library, instead of being in <a class="el" href="correct__projdata_8cxx.html" title="A utility applying/undoing some corrections on projection data. ">correct_projdata.cxx</a>.  </dd>
<dt><a class="anchor" id="_todo000021"></a>Member <a class="el" href="group__Coordinate.html#gadbdf0d99cabd5c3c7db9eb0fdb38bcfb">stir::cos_angle</a>  (const BasicCoordinate&lt; num_dimensions, coordT &gt; &amp;p1, const BasicCoordinate&lt; num_dimensions, coordT &gt; &amp;p2)</dt>
<dd>move to a new CartesianCoordinate class  </dd>
<dt><a class="anchor" id="_todo000112"></a>Class <a class="el" href="classstir_1_1DataSymmetriesForBins.html">stir::DataSymmetriesForBins</a>  </dt>
<dd>I have used <a class="el" href="classstir_1_1Bin.html" title="A class for storing coordinates and value of a single projection bin. ">Bin</a> here to have the 4 coordinates, but <a class="el" href="classstir_1_1Bin.html" title="A class for storing coordinates and value of a single projection bin. ">Bin</a> has data as well which is not really necessary here.  </dd>
<dt><a class="anchor" id="_todo000027"></a>Member <a class="el" href="group__densitydata.html#gaf67d385e5094a1990a9aa6ecdfece1f6">stir::Densel</a>  </dt>
<dd>This might at some point evolve into a class, similar to <a class="el" href="classstir_1_1Bin.html" title="A class for storing coordinates and value of a single projection bin. ">Bin</a>.  </dd>
<dt><a class="anchor" id="_todo000028"></a>Class <a class="el" href="classstir_1_1DetectionPosition.html">stir::DetectionPosition&lt; coordT &gt;</a>  </dt>
<dd>document directions </dd>
<dt><a class="anchor" id="_todo000096"></a>Member <a class="el" href="group__numerics.html#ga8de80007a01f8e495d0ee8d87280f1c4">stir::determinant</a>  (const <a class="el" href="classstir_1_1Array.html">Array&lt; 2, elemT &gt;</a> &amp;m)</dt>
<dd>Only works for low dimensions for now.  </dd>
<dt><a class="anchor" id="_todo000030"></a>Member <a class="el" href="classstir_1_1DiscretisedDensityOnCartesianGrid.html#ac102ff6d9ec4109dbedab5dd8eccbab9">stir::DiscretisedDensityOnCartesianGrid&lt; num_dimensions, elemT &gt;::actual_get_index_coordinates_for_relative_coordinates</a>  (const <a class="el" href="classstir_1_1CartesianCoordinate3D.html">CartesianCoordinate3D&lt; float &gt;</a> &amp;coords) const</dt>
<dd>cope with non-standard orientations  </dd>
<dt><a class="anchor" id="_todo000029"></a>Member <a class="el" href="classstir_1_1DiscretisedDensityOnCartesianGrid.html#a29118ba257099cd61b3ec7e0d1b83208">stir::DiscretisedDensityOnCartesianGrid&lt; num_dimensions, elemT &gt;::actual_get_relative_coordinates_for_indices</a>  (const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate&lt; num_dimensions, float &gt;</a> &amp;indices) const</dt>
<dd>cope with non-standard orientations  </dd>
<dt><a class="anchor" id="_todo000165"></a>Member <a class="el" href="classstir_1_1DiscretisedShape3D.html#a2869fbffe251e9dc3c258d994f3b3faa">stir::DiscretisedShape3D::operator==</a>  (const <a class="el" href="classstir_1_1Shape3D.html" title="The base class for all 3 dimensional shapes. ">Shape3D</a> &amp;) const</dt>
<dd>currently not implemented (will call <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f" title="Print error with format string a la printf and throw exception. ">error()</a>  </dd>
<dt><a class="anchor" id="_todo000166"></a>Member <a class="el" href="classstir_1_1DiscretisedShape3D.html#a0bcbf3af0505e15f7c4e68887ce5ae69">stir::DiscretisedShape3D::scale</a>  (const <a class="el" href="classstir_1_1CartesianCoordinate3D.html">CartesianCoordinate3D&lt; float &gt;</a> &amp;scale3D)</dt>
<dd>Not implemented (will call <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f" title="Print error with format string a la printf and throw exception. ">error()</a>)  </dd>
<dt><a class="anchor" id="_todo000114"></a>Member <a class="el" href="group__distributable.html#ga080ce96edb2b4b7b628a226bcd7d2b20">stir::distributable_computation</a>  (const shared_ptr&lt; ForwardProjectorByBin &gt; &amp;forward_projector_sptr, const shared_ptr&lt; BackProjectorByBin &gt; &amp;back_projector_sptr, const shared_ptr&lt; DataSymmetriesForViewSegmentNumbers &gt; &amp;symmetries_sptr, <a class="el" href="classstir_1_1DiscretisedDensity.html">DiscretisedDensity&lt; 3, float &gt;</a> *output_image_ptr, const <a class="el" href="classstir_1_1DiscretisedDensity.html">DiscretisedDensity&lt; 3, float &gt;</a> *input_image_ptr, const shared_ptr&lt; ProjData &gt; &amp;proj_data_ptr, const bool read_from_proj_data, int subset_num, int num_subsets, int min_segment_num, int max_segment_num, bool zero_seg0_end_planes, double *double_out_ptr, const shared_ptr&lt; ProjData &gt; &amp;additive_binwise_correction, const shared_ptr&lt; BinNormalisation &gt; normalise_sptr, const double start_time_of_frame, const double end_time_of_frame, RPC_process_related_viewgrams_type *RPC_process_related_viewgrams, <a class="el" href="classstir_1_1DistributedCachingInformation.html" title="This class implements the logic needed to support caching in a distributed manner. ">DistributedCachingInformation</a> *caching_info_ptr)</dt>
<dd>The subset-scheme should be moved somewhere else (a Subset class?). </dd>
<dt><a class="anchor" id="_todo000115"></a>Member <a class="el" href="group__distributable.html#gab7367d3ff2f137a0dba047f24be8b081">stir::distributable_computation_cache_enabled</a>  (const shared_ptr&lt; ForwardProjectorByBin &gt; &amp;forward_projector_ptr, const shared_ptr&lt; BackProjectorByBin &gt; &amp;back_projector_ptr, const shared_ptr&lt; DataSymmetriesForViewSegmentNumbers &gt; &amp;symmetries_ptr, <a class="el" href="classstir_1_1DiscretisedDensity.html">DiscretisedDensity&lt; 3, float &gt;</a> *output_image_ptr, const <a class="el" href="classstir_1_1DiscretisedDensity.html">DiscretisedDensity&lt; 3, float &gt;</a> *input_image_ptr, const shared_ptr&lt; ProjData &gt; &amp;proj_data_sptr, const bool read_from_proj_data, int subset_num, int num_subsets, int min_segment_num, int max_segment_num, bool zero_seg0_end_planes, double *double_out_ptr, const shared_ptr&lt; ProjData &gt; &amp;additive_binwise_correction, const shared_ptr&lt; BinNormalisation &gt; normalise_sptr, const double start_time_of_frame, const double end_time_of_frame, RPC_process_related_viewgrams_type *RPC_process_related_viewgrams, <a class="el" href="classstir_1_1DistributedCachingInformation.html" title="This class implements the logic needed to support caching in a distributed manner. ">DistributedCachingInformation</a> *caching_info_ptr)</dt>
<dd>Merge this functionality into <a class="el" href="group__distributable.html#ga080ce96edb2b4b7b628a226bcd7d2b20" title="This function essentially implements a loop over segments and all views in the current subset...">distributable_computation()</a> </dd>
<dt><a class="anchor" id="_todo000117"></a>Class <a class="el" href="classstir_1_1DistributedWorker.html">stir::DistributedWorker&lt; TargetT &gt;</a>  </dt>
<dd><p class="startdd">The log_likelihood_ptr argument to the RPC function is currently always NULL. </p>
<p class="enddd">Currently the only computation that is supported corresponds to the gradient computation. It would be trivial to add others.  </p>
</dd>
<dt><a class="anchor" id="_todo000032"></a>Class <a class="el" href="classstir_1_1DynamicDiscretisedDensity.html">stir::DynamicDiscretisedDensity</a>  </dt>
<dd>template in <code>elemT</code> and numDimensions?  </dd>
<dt><a class="anchor" id="_todo000033"></a>Class <a class="el" href="classstir_1_1DynamicProjData.html">stir::DynamicProjData</a>  </dt>
<dd><p class="startdd">Move read_from_file, write_to_ecat7 to usual registry methods </p>
<p class="enddd">Interfile support currently doesn't set start_time_in_secs_since_1970  </p>
</dd>
<dt><a class="anchor" id="_todo000110"></a>Class <a class="el" href="classstir_1_1ecat_1_1BinNormalisationFromECAT8.html">stir::ecat::BinNormalisationFromECAT8</a>  </dt>
<dd>dead-time is not yet implemented </dd>
<dt><a class="anchor" id="_todo000068"></a>Class <a class="el" href="classstir_1_1ecat_1_1CListEventECAT8__32bit.html">stir::ecat::CListEventECAT8_32bit</a>  </dt>
<dd><p class="startdd">This implementation only works if the list-mode data is stored without axial compression. </p>
<p class="enddd">If the target sinogram has the same characteristics as the sinogram encoding used in the list file (via the offset), the code could be sped-up dramatically by using the information. At present, we go a huge round-about (offset-&gt;sinogram-&gt;detectors-&gt;sinogram-&gt;offset)  </p>
</dd>
<dt><a class="anchor" id="_todo000063"></a>Member <a class="el" href="classstir_1_1ecat_1_1CListModeDataECAT8__32bit.html#a9a8cf56d6202eaf7f6cc0d0a798a14bf">stir::ecat::CListModeDataECAT8_32bit::has_delayeds</a>  () const</dt>
<dd>this might depend on the acquisition parameters  </dd>
<dt><a class="anchor" id="_todo000069"></a>Class <a class="el" href="classstir_1_1ecat_1_1ecat7_1_1CListEventDataECAT962.html">stir::ecat::ecat7::CListEventDataECAT962</a>  </dt>
<dd>use <a class="el" href="classstir_1_1DetectionPosition.html" title="A class for storing coordinates of a detection. ">DetectionPosition</a> etc.  </dd>
<dt><a class="anchor" id="_todo000060"></a>Class <a class="el" href="classstir_1_1ecat_1_1ecat7_1_1CListModeDataECAT.html">stir::ecat::ecat7::CListModeDataECAT&lt; CListRecordT &gt;</a>  </dt>
<dd>This class currently relies in the fact that vector&lt;&gt;::size_type == SavedPosition  </dd>
<dt><a class="anchor" id="_todo000061"></a>Member <a class="el" href="classstir_1_1ecat_1_1ecat7_1_1CListModeDataECAT.html#a3739933432d421275648db144ee12343">stir::ecat::ecat7::CListModeDataECAT&lt; CListRecordT &gt;::CListModeDataECAT</a>  (const std::string &amp;listmode_filename_prefix)</dt>
<dd>Maybe allow for passing e.g. something_2.lm in case the first lm file is missing.  </dd>
<dt><a class="anchor" id="_todo000193"></a>Member <a class="el" href="classstir_1_1ecat_1_1ecat7_1_1CListModeDataECAT.html#a3563227cfd7f39c4e4adaac571063391">stir::ecat::ecat7::CListModeDataECAT&lt; CListRecordT &gt;::get_next_record</a>  (CListRecord &amp;record) const</dt>
<dd>Currently switches over to the next .lm file whenever <a class="el" href="classstir_1_1ecat_1_1ecat7_1_1CListModeDataECAT.html#a3563227cfd7f39c4e4adaac571063391">get_next_record()</a> on the current file fails. This even happens when it failed not because of EOF, or if the listmode file is shorter than 2 GB.  </dd>
<dt><a class="anchor" id="_todo000062"></a>Member <a class="el" href="classstir_1_1ecat_1_1ecat7_1_1CListModeDataECAT.html#adb98afafc5b15e58f0afa40ea3cee3f0">stir::ecat::ecat7::CListModeDataECAT&lt; CListRecordT &gt;::has_delayeds</a>  () const</dt>
<dd>this might depend on the acquisition parameters  </dd>
<dt><a class="anchor" id="_todo000034"></a>Member <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f">stir::error</a>  (const char *const s,...)</dt>
<dd>As opposed to using printf-style calling sequence, use a syntax like <a class="el" href="group__buildblock.html#ga58339978ae5e7a02db3ba4d82bff5ab6" title="Use this function for writing informational messages. ">stir::info</a> </dd>
<dt><a class="anchor" id="_todo000035"></a>Member <a class="el" href="group__buildblock.html#ga4c7446f82a82a3d8ecd2cc9c6a5a8984">stir::error</a>  (const STRING &amp;string)</dt>
<dd>At a later stage, it will also write to a log-file. </dd>
<dt><a class="anchor" id="_todo000036"></a>Class <a class="el" href="classstir_1_1ExamInfo.html">stir::ExamInfo</a>  </dt>
<dd><p class="startdd">this is very incomplete at the moment. Things like bed positions, gating, isotopes etc etc are all missing</p>
<p class="enddd">This should be an abtract registered object, in order to serve as a complete base function for every input data type.  </p>
</dd>
<dt><a class="anchor" id="_todo000038"></a>Member <a class="el" href="group__buildblock.html#gab0e1214b5c53b71c58b89687abb3f5e1">stir::extract_line</a>  (const <a class="el" href="classstir_1_1Array.html">Array&lt; 3, elemT &gt;</a> &amp;, const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate&lt; 3, int &gt;</a> &amp;index, const int dimension)</dt>
<dd>make n-dimensional version  </dd>
<dt><a class="anchor" id="_todo000039"></a>Class <a class="el" href="classstir_1_1FactoryRegistry.html">stir::FactoryRegistry&lt; Key, Factory, Compare &gt;</a>  </dt>
<dd>Probably it would be better to store pointers to factories. However, in that case, the destructor of <a class="el" href="classstir_1_1FactoryRegistry.html" title="This class can be used to store &#39;factories&#39; and their corresponding keys. It is essentially a map...">FactoryRegistry</a> would have to deallocate these factory objects. This would mean that factories have to be allocated with new, and hence would prevent using simple function pointers.  </dd>
<dt><a class="anchor" id="_todo000178"></a>Class <a class="el" href="classstir_1_1Filter1D.html">stir::Filter1D&lt; T &gt;</a>  </dt>
<dd><a class="el" href="classstir_1_1Filter1D.html#a15d0960c13a353a5074c2a18b833b559" title="Filters data (which has to be in the &#39;spatial&#39; domain. ">apply()</a> members can't be const as they call <a class="el" href="classstir_1_1TimedObject.html#ad03301ca66aa639b11129f4081c4cca8" title="start all timers kept by this object ">TimedObject::start_timers()</a>  </dd>
<dt><a class="anchor" id="_todo000023"></a>Member <a class="el" href="group__Array.html#ga2e0944415644cae8cbbd0b9f299f25d2">stir::find_centre_of_gravity</a>  (const Array&lt; num_dimensions, T &gt; &amp;)</dt>
<dd>better error handling  </dd>
<dt><a class="anchor" id="_todo000025"></a>Class <a class="el" href="classstir_1_1FrameSinglesRates.html">stir::FrameSinglesRates</a>  </dt>
<dd>This class does not store rates, but totals! Naming is all wrong.  </dd>
<dt><a class="anchor" id="_todo000111"></a>Class <a class="el" href="classstir_1_1GE_1_1RDF__HDF5_1_1BinNormalisationFromGEHDF5.html">stir::GE::RDF_HDF5::BinNormalisationFromGEHDF5</a>  </dt>
<dd>dead-time is not yet implemented </dd>
<dt><a class="anchor" id="_todo000064"></a>Member <a class="el" href="classstir_1_1GE_1_1RDF__HDF5_1_1CListModeDataGEHDF5.html#a47db237de45e417a42a629ffe25a003f">stir::GE::RDF_HDF5::CListModeDataGEHDF5::has_delayeds</a>  () const</dt>
<dd>this depends on the acquisition parameters  </dd>
<dt><a class="anchor" id="_todo000048"></a>Class <a class="el" href="classstir_1_1GE_1_1RDF__HDF5_1_1InputStreamWithRecordsFromHDF5.html">stir::GE::RDF_HDF5::InputStreamWithRecordsFromHDF5&lt; RecordT &gt;</a>  </dt>
<dd>Allow choosing between allocation with <code>new</code> or on the stack.  </dd>
<dt><a class="anchor" id="_todo000026"></a>Class <a class="el" href="classstir_1_1GE_1_1RDF__HDF5_1_1SinglesRatesFromGEHDF5.html">stir::GE::RDF_HDF5::SinglesRatesFromGEHDF5</a>  </dt>
<dd>expose <a class="el" href="classstir_1_1GE_1_1RDF__HDF5_1_1GEHDF5Wrapper.html#a715b676b34af373a84343544251ed34b" title="Get shared pointer to exam info. ">GE::RDF_HDF5::GEHDF5Wrapper.get_exam_info_sptr()</a> </dd>
<dt><a class="anchor" id="_todo000118"></a>Class <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction&lt; TargetT &gt;</a>  </dt>
<dd>Currently, there is subset code in both <a class="el" href="classstir_1_1IterativeReconstruction.html" title="base class for iterative reconstruction objectsThis is the base class for all iterative reconstructio...">IterativeReconstruction</a> and here. This is confusing and leads to repetition. It probably should all be moved here. </dd>
<dt><a class="anchor" id="_todo000119"></a>Member <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#abe5bfcded32b6d3339b5bb1be1995c75">stir::GeneralisedObjectiveFunction&lt; TargetT &gt;::fill_nonidentifiable_target_parameters</a>  (TargetT &amp;target, const float value) const</dt>
<dd>The type of the value should really be derived from e.g. TargetT::full_iterator.  </dd>
<dt><a class="anchor" id="_todo000120"></a>Member <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a9c99dc70801b4cc6e909794f3889bb5f">stir::GeneralisedObjectiveFunction&lt; TargetT &gt;::get_prior_ptr</a>  () const</dt>
<dd>It would be nicer to not return a pointer.  </dd>
<dt><a class="anchor" id="_todo000010"></a>Member <a class="el" href="namespacestir.html#a16a96932257b3bfee40ea54c605fbf8b">stir::get_min_indices</a>  (const Array&lt; num_dimensions, T &gt; &amp;a)</dt>
<dd>If the array </dd>
<dt><a class="anchor" id="_todo000012"></a>Member <a class="el" href="group__Array.html#ga252955f8443f3f8c60326c17af5e5ad6">stir::in_place_apply_array_function_on_1st_index</a>  (Array&lt; num_dim, elemT &gt; &amp;array, FunctionObjectPtr f)</dt>
<dd><p class="startdd">Add a 1D specialisation as the current implementation would be really inefficient in this case. </p>
<p class="enddd">Add a specialisation such that this function would handle function objects and (smart) pointers to function objects. At the moment, it's only the latter.  </p>
</dd>
<dt><a class="anchor" id="_todo000013"></a>Member <a class="el" href="group__Array.html#ga95e3e07cb7fddb64dd189f1ea1bca40f">stir::in_place_apply_array_functions_on_each_index</a>  (Array&lt; num_dim, elemT &gt; &amp;array, FunctionObjectPtrIter start, FunctionObjectPtrIter stop)</dt>
<dd>Add a specialisation such that this function would handle function objects and (smart) pointers to function objects. At the moment, it's only the latter.  </dd>
<dt><a class="anchor" id="_todo000042"></a>Member <a class="el" href="namespacestir.html#ae1ebc92c91187cf5b389badf5641e2c6">stir::index_at_maximum</a>  (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset&lt; elemT &gt;</a> &amp;v)</dt>
<dd>make iterator version, or something that works on std::vector </dd>
<dt><a class="anchor" id="_todo000043"></a>Member <a class="el" href="namespacestir.html#adb5d5586ec57da1b5ecabbebb1a697a4">stir::indices_at_maximum</a>  (const <a class="el" href="classstir_1_1Array.html">Array&lt; 3, elemT &gt;</a> &amp;input_array)</dt>
<dd><p class="startdd">generalise to arbitrary dimensions </p>
<p class="enddd">implementation currently cycles through the data twice  </p>
</dd>
<dt><a class="anchor" id="_todo000044"></a>Member <a class="el" href="group__buildblock.html#ga58339978ae5e7a02db3ba4d82bff5ab6">stir::info</a>  (const STRING &amp;string, const int verbosity_level=1)</dt>
<dd>At a later stage, it will also write to a log-file. </dd>
<dt><a class="anchor" id="_todo000017"></a>Member <a class="el" href="group__Coordinate.html#ga2f556ccc1c78f5ee93aac477d852701a">stir::inner_product</a>  (const BasicCoordinate&lt; num_dimensions, coordT &gt; &amp;p1, const BasicCoordinate&lt; num_dimensions, coordT &gt; &amp;p2)</dt>
<dd>move to a new CartesianCoordinate class  </dd>
<dt><a class="anchor" id="_todo000046"></a>Class <a class="el" href="classstir_1_1InputFileFormat.html">stir::InputFileFormat&lt; DataT &gt;</a>  </dt>
<dd><p class="startdd">should be able to open for input-output maybe </p>
<p class="enddd">there is overlap between function having filenames or istreams. This is a bit of a mess. Also, some file formats we might only have an API for using C-style FILE.  </p>
</dd>
<dt><a class="anchor" id="_todo000047"></a>Class <a class="el" href="classstir_1_1InputStreamWithRecords.html">stir::InputStreamWithRecords&lt; RecordT, OptionsT &gt;</a>  </dt>
<dd>Allow choosing between allocation with <code>new</code> or on the stack.  </dd>
<dt><a class="anchor" id="_todo000045"></a>Member <a class="el" href="group__projdata.html#ga0cb657b2de00a68eb0b235a89861f477">stir::interpolate_projdata</a>  (<a class="el" href="classstir_1_1ProjData.html" title="The (abstract) base class for the projection data. ">ProjData</a> &amp;proj_data_out, const <a class="el" href="classstir_1_1ProjData.html" title="The (abstract) base class for the projection data. ">ProjData</a> &amp;proj_data_in, const <a class="el" href="group__BSpline.html#gaa4a83dae28c1550670e3fc9482fb2fe1" title="enum providing constants to define the type of B-Spline used for interpolation ">BSpline::BSplineType</a> spline_type, const bool remove_interleaving=false, const bool use_view_offset=false)</dt>
<dd>This currently only works for direct sinograms (i.e. segment 0).  </dd>
<dt><a class="anchor" id="_todo000051"></a>Class <a class="el" href="classstir_1_1IOTests.html">stir::IOTests&lt; A &gt;</a>  </dt>
<dd>Delete STIRtmp.* files, but that's a bit difficult as we don't know which ones are written.  </dd>
<dt><a class="anchor" id="_todo000207"></a>Class <a class="el" href="classstir_1_1IOTests__DiscretisedDensity.html">stir::IOTests_DiscretisedDensity</a>  </dt>
<dd>Delete STIRtmp.* files, but that's a bit difficult as we don't know which ones are written.  </dd>
<dt><a class="anchor" id="_todo000209"></a>Class <a class="el" href="classstir_1_1IOTests__DynamicDiscretisedDensity.html">stir::IOTests_DynamicDiscretisedDensity</a>  </dt>
<dd>Delete STIRtmp.* files, but that's a bit difficult as we don't know which ones are written.  </dd>
<dt><a class="anchor" id="_todo000211"></a>Class <a class="el" href="classstir_1_1IOTests__ParametricDiscretisedDensity.html">stir::IOTests_ParametricDiscretisedDensity</a>  </dt>
<dd>Delete STIRtmp.* files, but that's a bit difficult as we don't know which ones are written.  </dd>
<dt><a class="anchor" id="_todo000121"></a>Class <a class="el" href="classstir_1_1IterativeReconstruction.html">stir::IterativeReconstruction&lt; TargetT &gt;</a>  </dt>
<dd><p class="startdd">move subset things somewhere else </p>
<p class="enddd">all the <code>compute</code> functions should be <code>const</code>.  </p>
</dd>
<dt><a class="anchor" id="_todo000122"></a>Member <a class="el" href="classstir_1_1IterativeReconstruction.html#a9a9168f766c27f34c4c51ed28adf64eb">stir::IterativeReconstruction&lt; TargetT &gt;::get_initial_data_ptr</a>  () const</dt>
<dd><p class="startdd">Dependency on explicit strings "1" or "0" in <a class="el" href="classstir_1_1IterativeReconstruction.html#adb451d24d9eccdd5b62f553f583edd4e" title="name of the file containing the data for intializing the reconstruction ">IterativeReconstruction::initial_data_filename</a> is not nice. </p>
<p class="enddd">should not return a 'bare' pointer.  </p>
</dd>
<dt><a class="anchor" id="_todo000052"></a>Class <a class="el" href="classstir_1_1KeyArgument.html">stir::KeyArgument</a>  </dt>
<dd>Should be made a protected enum of <a class="el" href="classstir_1_1KeyParser.html" title="A class to parse Interfile headers. ">KeyParser</a>  </dd>
<dt><a class="anchor" id="_todo000054"></a>Class <a class="el" href="classstir_1_1KeyParser.html">stir::KeyParser</a>  </dt>
<dd><p class="startdd">add checking functions in the map, as in </p>
<p class="enddd">add facilities for checking (while parsing) if a keyword was present before the current one  </p>
</dd>
<dt><a class="anchor" id="_todo000056"></a>Member <a class="el" href="classstir_1_1KeyParser.html#acee4511c9040f002985af97336d84ffd">stir::KeyParser::ask_parameters</a>  ()</dt>
<dd>any consistency checks are currently done by <a class="el" href="classstir_1_1KeyParser.html#a1a9a476639a8bc800bee613f5178f722" title="This will be called at the end of the parsing. ">post_processing()</a> at the end of the parsing. It should be possible to have checks after every question such that it can be repeated. </dd>
<dt><a class="anchor" id="_todo000057"></a>Member <a class="el" href="classstir_1_1KeyParser.html#a1a9a476639a8bc800bee613f5178f722">stir::KeyParser::post_processing</a>  ()</dt>
<dd><p class="startdd">return <a class="el" href="classstir_1_1Succeeded.html" title="a class containing an enumeration type that can be used by functions to signal successful operation o...">Succeeded</a> instead. </p>
<p class="enddd">rename to <code>post_parsing()</code>  </p>
</dd>
<dt><a class="anchor" id="_todo000058"></a>Member <a class="el" href="classstir_1_1KeyParser.html#ae88a689951a4b3179493c3aae392520b">stir::KeyParser::standardise_keyword</a>  (const std::string &amp;keyword) const</dt>
<dd>Implementation note: this function is non-static such that it can be overloaded. Probably a template with a function object would be better.  </dd>
<dt><a class="anchor" id="_todo000070"></a>Class <a class="el" href="classstir_1_1ListEvent.html">stir::ListEvent</a>  </dt>
<dd>this is still under development. Things to add are for instance energy windows and time-of-flight info. Also, <a class="el" href="classstir_1_1ListEvent.html#a7a9623d9cfd546d8047c92c981199090" title="Finds the bin coordinates of this event for some characteristics of the projection data...">get_bin()</a> would need time info or so for rotating scanners. </dd>
<dt><a class="anchor" id="_todo000072"></a>Member <a class="el" href="classstir_1_1ListEvent.html#a7a9623d9cfd546d8047c92c981199090">stir::ListEvent::get_bin</a>  (<a class="el" href="classstir_1_1Bin.html" title="A class for storing coordinates and value of a single projection bin. ">Bin</a> &amp;bin, const <a class="el" href="classstir_1_1ProjDataInfo.html" title="An (abstract base) class that contains information on the projection data. ">ProjDataInfo</a> &amp;) const</dt>
<dd><a class="el" href="classstir_1_1ListEvent.html#a7a9623d9cfd546d8047c92c981199090" title="Finds the bin coordinates of this event for some characteristics of the projection data...">get_bin()</a> might need time info or so for rotating scanners.  </dd>
<dt><a class="anchor" id="_todo000071"></a>Member <a class="el" href="classstir_1_1ListEvent.html#aa3ff35d983c9c3856cfa7fc17d0d7d4c">stir::ListEvent::get_LOR</a>  () const =0</dt>
<dd>This function might need time info or so for rotating scanners.  </dd>
<dt><a class="anchor" id="_todo000073"></a>Class <a class="el" href="classstir_1_1ListTime.html">stir::ListTime</a>  </dt>
<dd>this is still under development. Things to add are angles or so for rotating scanners. Also, some info on the maximum (and actual?) number of gates would be useful.  </dd>
<dt><a class="anchor" id="_todo000074"></a>Class <a class="el" href="classstir_1_1LmToProjData.html">stir::LmToProjData</a>  </dt>
<dd><p class="startdd">Currently, there is no support for gating or energy windows. This could in principle be added by a derived class, but it would be better to do it here. </p>
<p>Timing info or so for <a class="el" href="classstir_1_1LmToProjData.html#a4b260985d647a3809f0e8648f2ab6652" title="will be called to get the bin for a coincidence event ">get_bin_from_event()</a> for rotating scanners etc. </p>
<p class="enddd">There is overlap between the normalisation and the current treatment of bin.get_bin_value(). This is really because we should be using something like a EventNormalisation class for pre-normalisation. </p>
</dd>
<dt><a class="anchor" id="_todo000075"></a>Member <a class="el" href="classstir_1_1LmToProjData.html#a4b260985d647a3809f0e8648f2ab6652">stir::LmToProjData::get_bin_from_event</a>  (<a class="el" href="classstir_1_1Bin.html" title="A class for storing coordinates and value of a single projection bin. ">Bin</a> &amp;bin, const <a class="el" href="classstir_1_1ListEvent.html" title="Class for storing and using gamma events from a list mode file. ">ListEvent</a> &amp;) const</dt>
<dd>Would need timing info or so for e.g. time dependent normalisation or angle info for a rotating scanner.  </dd>
<dt><a class="anchor" id="_todo000076"></a>Member <a class="el" href="classstir_1_1LmToProjData.html#a0ff58620224faa4d1017bb2b6115bcd5">stir::LmToProjData::get_compression_count</a>  (const <a class="el" href="classstir_1_1Bin.html" title="A class for storing coordinates and value of a single projection bin. ">Bin</a> &amp;bin) const</dt>
<dd>it is not compatiable with e.g. HiDAC doesn't belong here anyway (more <a class="el" href="classstir_1_1ProjDataInfo.html" title="An (abstract base) class that contains information on the projection data. ">ProjDataInfo</a>?)  </dd>
<dt><a class="anchor" id="_todo000053"></a>Class <a class="el" href="classstir_1_1map__element.html">stir::map_element</a>  </dt>
<dd>make private class in <a class="el" href="classstir_1_1KeyParser.html" title="A class to parse Interfile headers. ">KeyParser</a>  </dd>
<dt><a class="anchor" id="_todo000098"></a>Member <a class="el" href="group__numerics.html#ga37432709a9e70ddd8b94d65f0e82e4f7">stir::max_eigenvector_using_power_method</a>  (elemT &amp;max_eigenvalue, <a class="el" href="classstir_1_1Array_3_011_00_01elemT_01_4.html" title="The 1-dimensional (partial) specialisation of Array. ">Array&lt; 1, elemT &gt;</a> &amp;max_eigenvector, const <a class="el" href="classstir_1_1Array.html">Array&lt; 2, elemT &gt;</a> &amp;m, const <a class="el" href="classstir_1_1Array_3_011_00_01elemT_01_4.html" title="The 1-dimensional (partial) specialisation of Array. ">Array&lt; 1, elemT &gt;</a> &amp;start, const double tolerance=.03, const unsigned long max_num_iterations=10000UL)</dt>
<dd>the algorithm would work with hermitian matrices, but the code needs one small adjustment.  </dd>
<dt><a class="anchor" id="_todo000080"></a>Class <a class="el" href="classstir_1_1MaximalArrayFilter3D.html">stir::MaximalArrayFilter3D&lt; elemT &gt;</a>  </dt>
<dd><p class="startdd">Currently, the mask is determined in terms of the mask radius (in pixels), where size = 2*radius+1. This could easily be relaxed. </p>
<p class="enddd">generalise to n-dimensions  </p>
</dd>
<dt><a class="anchor" id="_todo000081"></a>Class <a class="el" href="classstir_1_1MedianArrayFilter3D.html">stir::MedianArrayFilter3D&lt; elemT &gt;</a>  </dt>
<dd><p class="startdd">Currently, the mask is determined in terms of the mask radius (in pixels), where size = 2*radius+1. This could easily be relaxed. </p>
<p class="enddd">generalise to n-dimensions  </p>
</dd>
<dt><a class="anchor" id="_todo000082"></a>Class <a class="el" href="classstir_1_1MinimalArrayFilter3D.html">stir::MinimalArrayFilter3D&lt; elemT &gt;</a>  </dt>
<dd><p class="startdd">Currently, the mask is determined in terms of the mask radius (in pixels), where size = 2*radius+1. This could easily be relaxed. </p>
<p class="enddd">generalise to n-dimensions  </p>
</dd>
<dt><a class="anchor" id="_todo000083"></a>Member <a class="el" href="classstir_1_1ModelMatrix.html#a009848e4220b8d8e2f7d8815b6ee3d53">stir::ModelMatrix&lt; num_param &gt;::multiply_dynamic_image_with_model</a>  (ParametricVoxelsOnCartesianGrid &amp;parametric_image, const <a class="el" href="classstir_1_1DynamicDiscretisedDensity.html" title="Class of multiple image frames, one for each time frame Each time frame is a DiscretisedDensity&lt;3,float&gt; ">DynamicDiscretisedDensity</a> &amp;dynamic_image) const</dt>
<dd>current implementation first fills first argument with 0 and then calls <a class="el" href="classstir_1_1ModelMatrix.html#afb2489065f94678405831e54762925f4" title="multiply (transpose) model-matrix with dynamic image and add result to original parametric_image ...">multiply_dynamic_image_with_model_and_add_to_input()</a>. This is somewhat inefficient.  </dd>
<dt><a class="anchor" id="_todo000084"></a>Member <a class="el" href="classstir_1_1ModelMatrix.html#a4b77b48f105b57abc29e641171d290d0">stir::ModelMatrix&lt; num_param &gt;::multiply_parametric_image_with_model</a>  (<a class="el" href="classstir_1_1DynamicDiscretisedDensity.html" title="Class of multiple image frames, one for each time frame Each time frame is a DiscretisedDensity&lt;3,float&gt; ">DynamicDiscretisedDensity</a> &amp;dynamic_image, const ParametricVoxelsOnCartesianGrid &amp;parametric_image) const</dt>
<dd>current implementation first fills first argument with 0 and then calls <a class="el" href="classstir_1_1ModelMatrix.html#afb2489065f94678405831e54762925f4" title="multiply (transpose) model-matrix with dynamic image and add result to original parametric_image ...">multiply_dynamic_image_with_model_and_add_to_input()</a>. This is somewhat inefficient.  </dd>
<dt><a class="anchor" id="_todo000212"></a>Class <a class="el" href="classstir_1_1NestedIteratorTests.html">stir::NestedIteratorTests</a>  </dt>
<dd>Code is ugly. Copy-paste with tiny modifications.  </dd>
<dt><a class="anchor" id="_todo000019"></a>Member <a class="el" href="group__Coordinate.html#ga4770b3db3002116b144d80af7afdef39">stir::norm</a>  (const BasicCoordinate&lt; num_dimensions, coordT &gt; &amp;p1)</dt>
<dd>move to a new CartesianCoordinate class  </dd>
<dt><a class="anchor" id="_todo000018"></a>Member <a class="el" href="group__Coordinate.html#ga5d087edb9c8d2db898c61f64cbdcc846">stir::norm_squared</a>  (const BasicCoordinate&lt; num_dimensions, coordT &gt; &amp;p1)</dt>
<dd>move to a new CartesianCoordinate class  </dd>
<dt><a class="anchor" id="_todo000100"></a>Class <a class="el" href="classstir_1_1OSSPSReconstruction.html">stir::OSSPSReconstruction&lt; TargetT &gt;</a>  </dt>
<dd>split into a preconditioned subgradient descent class and something that computes the preconditioner.  </dd>
<dt><a class="anchor" id="_todo000049"></a>Class <a class="el" href="classstir_1_1OutputFileFormat.html">stir::OutputFileFormat&lt; DataT &gt;</a>  </dt>
<dd><p class="startdd">Support projection data </p>
<p class="enddd">Provide functions that enable the user to inquire about capabilities. For instance, supports_multi_time_frames(), supports_different_xy_pixel_size() etc.  </p>
</dd>
<dt><a class="anchor" id="_todo000214"></a>Class <a class="el" href="classstir_1_1OutputFileFormatTests.html">stir::OutputFileFormatTests</a>  </dt>
<dd>Delete STIRtmp.* files, but that's a bit difficult as we don't know which ones are written.  </dd>
<dt><a class="anchor" id="_todo000190"></a>Member <a class="el" href="classstir_1_1ParametricQuadraticPrior.html#a47ef9218f761a1391a98e347dab19024">stir::ParametricQuadraticPrior&lt; TargetT &gt;::weights</a>  </dt>
<dd>This member is mutable at present because some const functions initialise it. That initialisation should be moved to a new <a class="el" href="classstir_1_1ParametricQuadraticPrior.html#a2a3766b1a4b816554383d619835a5438" title="Has to be called before using this object. ">set_up()</a> function.  </dd>
<dt><a class="anchor" id="_todo000101"></a> Class <a class="el" href="classstir_1_1ParseAndCreateFrom_3_01DiscretisedDensity_3_013_00_01elemT_01_4_00_01ExamDataT_01_4.html">stir::ParseAndCreateFrom&lt; DiscretisedDensity&lt; 3, elemT &gt;, ExamDataT &gt;</a>  </dt>
<dd>Currently only supports <a class="el" href="classstir_1_1VoxelsOnCartesianGrid.html" title="This class is used to represent voxelised densities on a cuboid grid (3D). ">VoxelsOnCartesianGrid</a> parameters (we could introduce another keyword to differentiate between types).  </dd>
<dt><a class="anchor" id="_todo000102"></a>Member <a class="el" href="classstir_1_1ParseAndCreateFrom.html#ae335e7747328c2ee570610212e93c6f5">stir::ParseAndCreateFrom&lt; OutputT, InputT, ParserT &gt;::create</a>  (const InputT &amp;) const</dt>
<dd>Currently we're assuming this returns a bare pointer (to a new object). This is due to limitations in the reconstruction classes. It will need to change to a <code>std::unique</code> pointer.  </dd>
<dt><a class="anchor" id="_todo000085"></a>Class <a class="el" href="classstir_1_1PatlakPlot.html">stir::PatlakPlot</a>  </dt>
<dd>Should be derived from LinearModels, but when non-linear models will be introduced, as well.  </dd>
<dt><a class="anchor" id="_todo000088"></a>Member <a class="el" href="classstir_1_1PatlakPlot.html#afec9c3bfba5007820a0ab7fb3c3c6033">stir::PatlakPlot::get_dynamic_image_from_parametric_image</a>  (<a class="el" href="classstir_1_1DynamicDiscretisedDensity.html" title="Class of multiple image frames, one for each time frame Each time frame is a DiscretisedDensity&lt;3,float&gt; ">DynamicDiscretisedDensity</a> &amp;dyn_image, const ParametricVoxelsOnCartesianGrid &amp;par_image) const</dt>
<dd>Should be a virtual function declared in the <a class="el" href="classstir_1_1KineticModel.html" title="base class for all kinetic modelsAt present very basic. It just provides the parsing mechanism...">KineticModel</a> class.  </dd>
<dt><a class="anchor" id="_todo000086"></a>Member <a class="el" href="classstir_1_1PatlakPlot.html#a40c1da6e658762c9113e6a853a26c89f">stir::PatlakPlot::multiply_dynamic_image_with_model_gradient</a>  (ParametricVoxelsOnCartesianGrid &amp;parametric_image, const <a class="el" href="classstir_1_1DynamicDiscretisedDensity.html" title="Class of multiple image frames, one for each time frame Each time frame is a DiscretisedDensity&lt;3,float&gt; ">DynamicDiscretisedDensity</a> &amp;dyn_image) const</dt>
<dd>Should be a virtual function declared in the <a class="el" href="classstir_1_1KineticModel.html" title="base class for all kinetic modelsAt present very basic. It just provides the parsing mechanism...">KineticModel</a> class.  </dd>
<dt><a class="anchor" id="_todo000087"></a>Member <a class="el" href="classstir_1_1PatlakPlot.html#ae48528f812ab58a1ba9075984d8c80eb">stir::PatlakPlot::multiply_dynamic_image_with_model_gradient_and_add_to_input</a>  (ParametricVoxelsOnCartesianGrid &amp;parametric_image, const <a class="el" href="classstir_1_1DynamicDiscretisedDensity.html" title="Class of multiple image frames, one for each time frame Each time frame is a DiscretisedDensity&lt;3,float&gt; ">DynamicDiscretisedDensity</a> &amp;dyn_image) const</dt>
<dd>Should be a virtual function declared in the <a class="el" href="classstir_1_1KineticModel.html" title="base class for all kinetic modelsAt present very basic. It just provides the parsing mechanism...">KineticModel</a> class.  </dd>
<dt><a class="anchor" id="_todo000089"></a>Member <a class="el" href="classstir_1_1PlasmaData.html#adb6c0e8a2d4515dbca7c07f363c28d52">stir::PlasmaData::PlasmaData</a>  (const std::vector&lt; PlasmaSample &gt; &amp;plasma_blood_plot)</dt>
<dd>Better to use iterators  </dd>
<dt><a class="anchor" id="_todo000090"></a>Member <a class="el" href="classstir_1_1PlasmaData.html#ab59b0c0e5b479da933e9d734b44877d1">stir::PlasmaData::read_plasma_data</a>  (const std::string input_string)</dt>
<dd>Implementation to set the input units.  </dd>
<dt><a class="anchor" id="_todo000129"></a>Member <a class="el" href="classstir_1_1PLSPrior.html#a0a4ba86f8b0bbdfa74ccf1b7e50a6205">stir::PLSPrior&lt; elemT &gt;::set_up</a>  (shared_ptr&lt; DiscretisedDensity&lt; 3, elemT &gt; &gt; const &amp;target_sptr)</dt>
<dd>set the anatomical image to zero if not defined  </dd>
<dt><a class="anchor" id="_todo000130"></a>Member <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html#aba81530af2ac6653b07e9d086dd69bfc">stir::PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData&lt; TargetT &gt;::add_subset_sensitivity</a>  (TargetT &amp;sensitivity, const int subset_num) const</dt>
<dd>Current implementation does NOT add to the subset sensitivity, but overwrites  </dd>
<dt><a class="anchor" id="_todo000131"></a>Member <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeData.html#abfa7cfcf324ceec07baa4a99cb83e93d">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeData&lt; TargetT &gt;::frame_defs</a>  </dt>
<dd>This is currently used to be able to compute the gradient for one time frame. However, it probably does not belong here. For instance when fitting kinetic model parameters from list mode data, time frames are in principle irrelevant. So, we will probably shift this to the derived class.  </dd>
<dt><a class="anchor" id="_todo000132"></a>Member <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin.html#a6a5ba0ca97156380f9e40479a51e2dcf">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin&lt; TargetT &gt;::max_ring_difference_num_to_process</a>  </dt>
<dd>Might be removed  </dd>
<dt><a class="anchor" id="_todo000134"></a>Member <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#af1fa559b025845e21972856be9d9b653">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;::actual_add_multiplication_with_approximate_sub_Hessian_without_penalty</a>  (TargetT &amp;output, const TargetT &amp;input, const int subset_num) const</dt>
<dd>Two work-arounds for the noisy estimate of the Hessian are listed below, but they are currently not implemented. </dd>
<dt><a class="anchor" id="_todo000205"></a>Member <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjDataTests.html#a7adc1ba208cd86ec7bbebac4f9a89491">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjDataTests::PoissonLogLikelihoodWithLinearModelForMeanAndProjDataTests</a>  (char const *const proj_data_filename=0, char const *const density_filename=0)</dt>
<dd>it would be better to parse an objective function. That would allow us to set all parameters from the command line.  </dd>
<dt><a class="anchor" id="_todo000103"></a>Class <a class="el" href="classstir_1_1ProjDataInfoCylindricalNoArcCorr.html">stir::ProjDataInfoCylindricalNoArcCorr</a>  </dt>
<dd>The detector specific functions possibly do not belong in this class. One can easily imagine a case where the theta,phi,s,t coordinates are as described, but there is no real correspondence with detectors (for instance, a rotating system). Maybe they should be moved somewhere else?  </dd>
<dt><a class="anchor" id="_todo000107"></a>Member <a class="el" href="classstir_1_1ProjDataInfoCylindricalNoArcCorr.html#afd1cccfbb544e40fd6040c2b0e45ceaf">stir::ProjDataInfoCylindricalNoArcCorr::get_all_det_pos_pairs_for_bin</a>  (std::vector&lt; DetectionPositionPair&lt;&gt; &gt; &amp;, const <a class="el" href="classstir_1_1Bin.html" title="A class for storing coordinates and value of a single projection bin. ">Bin</a> &amp;) const</dt>
<dd>It might be possible to return some weight factors in case there is no many-to-one correspondence between detection positions and bins (for instance for continuous detectors, or rotating scanners, or arc-corrected data).  </dd>
<dt><a class="anchor" id="_todo000105"></a>Member <a class="el" href="classstir_1_1ProjDataInfoCylindricalNoArcCorr.html#a97966e71446d6996f03dc9b93f36b378">stir::ProjDataInfoCylindricalNoArcCorr::get_bin_for_det_pos_pair</a>  (<a class="el" href="classstir_1_1Bin.html" title="A class for storing coordinates and value of a single projection bin. ">Bin</a> &amp;, const DetectionPositionPair&lt;&gt; &amp;) const</dt>
<dd>use member template for the coordT type to support continuous detectors.  </dd>
<dt><a class="anchor" id="_todo000106"></a>Member <a class="el" href="classstir_1_1ProjDataInfoCylindricalNoArcCorr.html#a91d17e431dad398a978a408126a5ff8c">stir::ProjDataInfoCylindricalNoArcCorr::get_det_pos_pair_for_bin</a>  (DetectionPositionPair&lt;&gt; &amp;, const <a class="el" href="classstir_1_1Bin.html" title="A class for storing coordinates and value of a single projection bin. ">Bin</a> &amp;) const</dt>
<dd>use member template for the coordT type to support continuous detectors.  </dd>
<dt><a class="anchor" id="_todo000104"></a>Member <a class="el" href="classstir_1_1ProjDataInfoCylindricalNoArcCorr.html#a3392fd5a875c88b7d2ebfdfb14065840">stir::ProjDataInfoCylindricalNoArcCorr::ProjDataInfoCylindricalNoArcCorr</a>  (const shared_ptr&lt; Scanner &gt; scanner_ptr, const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset&lt; int &gt;</a> &amp;num_axial_pos_per_segment, const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset&lt; int &gt;</a> &amp;min_ring_diff_v, const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset&lt; int &gt;</a> &amp;max_ring_diff_v, const int num_views, const int num_tangential_poss)</dt>
<dd>only suitable for full-ring PET scanners  </dd>
<dt><a class="anchor" id="_todo000135"></a>Class <a class="el" href="classstir_1_1ProjDataRebinning.html">stir::ProjDataRebinning</a>  </dt>
<dd>there should be a method to rebin the data without writing the result to disk  </dd>
<dt><a class="anchor" id="_todo000136"></a>Member <a class="el" href="classstir_1_1ProjectorByBinPair.html#aac4db3998150cda080c3e3582e1a0572">stir::ProjectorByBinPair::get_symmetries_used</a>  () const</dt>
<dd>determine set of minimal symmetries  </dd>
<dt><a class="anchor" id="_todo000138"></a>Class <a class="el" href="classstir_1_1ProjMatrixByBinFromFile.html">stir::ProjMatrixByBinFromFile</a>  </dt>
<dd>this class currently only works with <a class="el" href="classstir_1_1VoxelsOnCartesianGrid.html" title="This class is used to represent voxelised densities on a cuboid grid (3D). ">VoxelsOnCartesianGrid</a>. To fix this, we would need a DiscretisedDensityInfo class, and be able to have constructed the appropriate symmetries object by parsing the .par file </dd>
<dt><a class="anchor" id="_todo000191"></a>Class <a class="el" href="classstir_1_1ProjMatrixByBinSinglePhoton.html">stir::ProjMatrixByBinSinglePhoton</a>  </dt>
<dd>This is a horrible work-around for the fact that STIR currently insists on working on a density. </dd>
<dt><a class="anchor" id="_todo000139"></a>Class <a class="el" href="classstir_1_1ProjMatrixElemsForOneBin.html">stir::ProjMatrixElemsForOneBin</a>  </dt>
<dd><p class="startdd">Most of the members of this class would work just as well for a (not yet existing) class <a class="el" href="classstir_1_1ProjMatrixElemsForOneDensel.html" title="This stores the non-zero projection matrix elements for every &#39;voxel&#39;. ">ProjMatrixElemsForOneDensel</a>. This means that we should derived both from a common base class, templated in the type of element.</p>
<p class="enddd">It might be useful to template this class in terms of the element-type as well. That way, we could have 'compact' elements, efficient elements, etc. However, doing this will probably only be useful if all <a class="el" href="classstir_1_1ProjMatrixByBin.html" title="This is the (abstract) base class for all projection matrices which are organised by &#39;bin&#39;...">ProjMatrixByBin</a> classes are then templated as well, which would be a pain.  </p>
</dd>
<dt><a class="anchor" id="_todo000141"></a>Class <a class="el" href="classstir_1_1ProjMatrixElemsForOneDenselValue.html">stir::ProjMatrixElemsForOneDenselValue</a>  </dt>
<dd>Simply derived from <a class="el" href="classstir_1_1Bin.html" title="A class for storing coordinates and value of a single projection bin. ">Bin</a> for now. </dd>
<dt><a class="anchor" id="_todo000185"></a>Class <a class="el" href="classstir_1_1PullLinearInterpolator.html">stir::PullLinearInterpolator&lt; elemT &gt;</a>  </dt>
<dd>preliminary. We might want to derive this from a class or so.  </dd>
<dt><a class="anchor" id="_todo000187"></a>Class <a class="el" href="classstir_1_1PullNearestNeighbourInterpolator.html">stir::PullNearestNeighbourInterpolator&lt; elemT &gt;</a>  </dt>
<dd>preliminary. We might want to derive this from a class or so.  </dd>
<dt><a class="anchor" id="_todo000188"></a>Class <a class="el" href="classstir_1_1PushNearestNeighbourInterpolator.html">stir::PushNearestNeighbourInterpolator&lt; elemT &gt;</a>  </dt>
<dd>preliminary. We might want to derive this from a class or so.  </dd>
<dt><a class="anchor" id="_todo000186"></a>Class <a class="el" href="classstir_1_1PushTransposeLinearInterpolator.html">stir::PushTransposeLinearInterpolator&lt; elemT &gt;</a>  </dt>
<dd>preliminary. We might want to derive this from a class or so.  </dd>
<dt><a class="anchor" id="_todo000142"></a>Member <a class="el" href="classstir_1_1QuadraticPrior.html#a1646ee82569e71a4453c4531a8cb6e66">stir::QuadraticPrior&lt; elemT &gt;::weights</a>  </dt>
<dd>This member is mutable at present because some const functions initialise it. That initialisation should be moved to a new <a class="el" href="classstir_1_1QuadraticPrior.html#a24129b4ba940326c15dee22385c4c4d6" title="Has to be called before using this object. ">set_up()</a> function.  </dd>
<dt><a class="anchor" id="_todo000024"></a>Member <a class="el" href="group__singles__buildblock.html#ga6a0a3de9251746563ba30d4c3aeb3e88">stir::randoms_from_singles</a>  (<a class="el" href="classstir_1_1ProjData.html" title="The (abstract) base class for the projection data. ">ProjData</a> &amp;proj_data, const <a class="el" href="classstir_1_1SinglesRates.html" title="The base-class for using singles info. ">SinglesRates</a> &amp;singles, const float coincidence_time_window)</dt>
<dd><p class="startdd">Dead-time is currently completely ignored. </p>
<p class="enddd">The function currently assumes F-18 half-life.  </p>
</dd>
<dt><a class="anchor" id="_todo000144"></a>Member <a class="el" href="classstir_1_1Reconstruction.html#ad8e95fdce438b611703cc9fd4b9f5a94">stir::Reconstruction&lt; TargetT &gt;::initialise</a>  (const std::string &amp;parameter_filename)</dt>
<dd>It currently calls <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f" title="Print error with format string a la printf and throw exception. ">error()</a> when something goes wrong. It should return <a class="el" href="classstir_1_1Succeeded.html" title="a class containing an enumeration type that can be used by functions to signal successful operation o...">Succeeded</a> (or throw an exception).  </dd>
<dt><a class="anchor" id="_todo000143"></a>Member <a class="el" href="classstir_1_1Reconstruction.html#a595decb0763564b00a9f4b91ac4ac000">stir::Reconstruction&lt; TargetT &gt;::set_up</a>  (shared_ptr&lt; TargetT &gt; const &amp;target_data_sptr)</dt>
<dd>Currently, <a class="el" href="classstir_1_1Reconstruction.html#a595decb0763564b00a9f4b91ac4ac000" title="operations prior to the reconstruction ">set_up()</a> is called by <a class="el" href="classstir_1_1Reconstruction.html#a3a21f515d15e20c4281e3643aa170472" title="executes the reconstruction ">reconstruct()</a>. This is in contrast with some other class hierarchies in STIR where <a class="el" href="classstir_1_1Reconstruction.html#a595decb0763564b00a9f4b91ac4ac000" title="operations prior to the reconstruction ">set_up()</a> has to be called before any actual processing. Maybe this should be made consistent.  </dd>
<dt><a class="anchor" id="_todo000150"></a>Class <a class="el" href="classstir_1_1RegisteredObject.html">stir::RegisteredObject&lt; Root &gt;</a>  </dt>
<dd>Currently there is a hard-wired value of &quot;None&quot; for the default key (with a 0 factory). This is inappropriate in some cases. </dd>
<dt><a class="anchor" id="_todo000151"></a>Member <a class="el" href="classstir_1_1RegisteredParsingObject.html#a4efc30dcaf35a1029c6bd099acb3f6a4">stir::RegisteredParsingObject&lt; Derived, Base, Parent &gt;::read_from_stream</a>  (std::istream *)</dt>
<dd>Currently, the return value is a <em>Base*</em>. Preferably, it should be a <em>Derived*</em>, but it seems the registration machinery would need extra (unsafe) reinterpret_casts to get that to work. (TODO find a remedy).  </dd>
<dt><a class="anchor" id="_todo000152"></a>Member <a class="el" href="structstir_1_1RegisteredParsingObject_1_1RegisterIt.html#a8bc144856329ceedc24ee01acf8d3045">stir::RegisteredParsingObject&lt; Derived, Base, Parent &gt;::RegisterIt::~RegisterIt</a>  ()</dt>
<dd>At present, the object remain in the registry, as there is a potential conflict in the order of destruction of the registry and the <a class="el" href="structstir_1_1RegisteredParsingObject_1_1RegisterIt.html" title="A helper class to allow automatic registration. ">RegisterIt</a> objects. This can be solved with shared_ptr s.  </dd>
<dt><a class="anchor" id="_todo000153"></a>Member <a class="el" href="classstir_1_1RelatedViewgrams.html#aa8fae579683f0f510fb71c553b21fb1c">stir::RelatedViewgrams&lt; elemT &gt;::RelatedViewgrams</a>  (const std::vector&lt; Viewgram&lt; elemT &gt; &gt; &amp;viewgrams, const shared_ptr&lt; DataSymmetriesForViewSegmentNumbers &gt; &amp;symmetries_used)</dt>
<dd>Currently public for the STIR_MPI version  </dd>
<dt><a class="anchor" id="_todo000145"></a>Member <a class="el" href="classstir_1_1RelativeDifferencePrior.html#ae3fde6f3b09c80e3c2d237148bcfff5a">stir::RelativeDifferencePrior&lt; elemT &gt;::weights</a>  </dt>
<dd>This member is mutable at present because some const functions initialise it. That initialisation should be moved to a new <a class="el" href="classstir_1_1RelativeDifferencePrior.html#a3d7cefa1e0da8158f6dee15936369563" title="Has to be called before using this object. ">set_up()</a> function.  </dd>
<dt><a class="anchor" id="_todo000179"></a>Member <a class="el" href="classstir_1_1RigidObject3DMotion.html#a0bbdb02de63fd0bf550c4434ab31c075">stir::RigidObject3DMotion::get_rel_time_of_samples</a>  (const double start_time, const double end_time) const =0</dt>
<dd>Really only makes sense for motion tracking that happens via sampling. One could imagine having simulated motion, and then this function wouldn't make a lot of sense. So, it probably should be moved to a derived class <code>SampledRigidObject3DMotion</code> or so.  </dd>
<dt><a class="anchor" id="_todo000180"></a>Class <a class="el" href="classstir_1_1RigidObject3DMotionFromPolaris.html">stir::RigidObject3DMotionFromPolaris</a>  </dt>
<dd>move synchronisation out of this class  </dd>
<dt><a class="anchor" id="_todo000181"></a>Class <a class="el" href="classstir_1_1RigidObject3DTransformation.html">stir::RigidObject3DTransformation</a>  </dt>
<dd><p class="startdd">Document sign choice for rotation.</p>
<p class="enddd">define Euler angles (the code is derived from the Polaris manual)  </p>
</dd>
<dt><a class="anchor" id="_todo000004"></a>Class <a class="el" href="classstir_1_1RigidObject3DTransformationTests.html">stir::RigidObject3DTransformationTests</a>  </dt>
<dd>tests on inverse of transform_bin fail with some rotations (too large difference in round-trip).  </dd>
<dt><a class="anchor" id="_todo000215"></a>Class <a class="el" href="classstir_1_1ROITests.html">stir::ROITests</a>  </dt>
<dd>Tests are currently somewhat simplistic </dd>
<dt><a class="anchor" id="_todo000154"></a>Member <a class="el" href="namespacestir.html#a704df98be13e78a12dd340500a9e26f3">stir::round_to</a>  (integerT &amp;result, const float x)</dt>
<dd>add code to check that <code>integerT</code> is really an integer type at compilation time  </dd>
<dt><a class="anchor" id="_todo000099"></a>Member <a class="el" href="group__numerics.html#ga3d41e73fca815d036389b83d7eda9584">stir::sample_function_on_regular_grid</a>  (<a class="el" href="classstir_1_1Array.html">Array&lt; 3, elemT &gt;</a> &amp;out, FunctionType func, const BasicCoordinate&lt; 3, positionT &gt; &amp;offset, const BasicCoordinate&lt; 3, positionT &gt; &amp;step)</dt>
<dd>At the moment, only the 3D version is implemented, but this could be templated.  </dd>
<dt><a class="anchor" id="_todo000155"></a>Class <a class="el" href="classstir_1_1Scanner.html">stir::Scanner</a>  </dt>
<dd><p class="startdd">Some scanners do not have all info filled in at present. Values are then set to 0. </p>
<p>derive from <a class="el" href="classstir_1_1ParsingObject.html" title="A base class for objects that want to be able to parse parameter files. ">ParsingObject</a> </p>
<p class="enddd">a hierarchy distinguishing between different types of scanners  </p>
</dd>
<dt><a class="anchor" id="_todo000159"></a>Member <a class="el" href="classstir_1_1Scanner.html#a6aa371b02399f36703d56e0f18e7e7b3">stir::Scanner::get_default_intrinsic_tilt</a>  () const</dt>
<dd>we still have to decide if <a class="el" href="classstir_1_1ProjDataInfo.html#af184359e9af5f284cc3628e607824d07" title="Get azimuthal angle phi of the normal to the projection plane. ">ProjDataInfo::get_phi()</a> will take this tilt into account or not. At present, STIR ignores the intrinsic tilt.  </dd>
<dt><a class="anchor" id="_todo000158"></a>Member <a class="el" href="classstir_1_1Scanner.html#a996ac6569d3a0b5a3a132e45e9a6e08f">stir::Scanner::get_default_num_arccorrected_bins</a>  () const</dt>
<dd>change name, mabe refering to the fan of detectors in coincidence or so  </dd>
<dt><a class="anchor" id="_todo000157"></a>Member <a class="el" href="classstir_1_1Scanner.html#aeba39b832436927867bee200f63569a5">stir::Scanner::get_max_num_non_arccorrected_bins</a>  () const</dt>
<dd>change name  </dd>
<dt><a class="anchor" id="_todo000001"></a>Member <a class="el" href="classstir_1_1Scanner.html#aa52bf602bb4303feeaead04910ba2550">stir::Scanner::get_num_virtual_axial_crystals_per_block</a>  () const</dt>
<dd>The current list is bound to be incomplete. would be better to stick it in set_params().  </dd>
<dt><a class="anchor" id="_todo000002"></a>Member <a class="el" href="classstir_1_1Scanner.html#adcb91c82d2eab159c9f3688bb468b847">stir::Scanner::get_num_virtual_transaxial_crystals_per_block</a>  () const</dt>
<dd>The current list is bound to be incomplete. would be better to stick it in set_params().  </dd>
<dt><a class="anchor" id="_todo000160"></a>Class <a class="el" href="classstir_1_1ScatterEstimation.html">stir::ScatterEstimation</a>  </dt>
<dd><p class="startdd">The code should throw an error if 2D input data are loaded. It should just deactivate the final upsampling. </p>
<p>Currently FBP reconstruction is not working and just throws an error. </p>
<p class="enddd">This code needs far more documentation. </p>
</dd>
<dt><a class="anchor" id="_todo000161"></a>Class <a class="el" href="classstir_1_1ScatterSimulation.html">stir::ScatterSimulation</a>  </dt>
<dd><p class="startdd">detector coordinates are derived from <a class="el" href="classstir_1_1ProjDataInfo.html" title="An (abstract base) class that contains information on the projection data. ">ProjDataInfo</a>, but areas and orientations are determined by using a cylindrical scanner.</p>
<p class="enddd">variables/function named <code>density</code> really should use <code>attenuation</code>. This is currently only done for a few variables, but parsing keywords are correct. </p>
</dd>
<dt><a class="anchor" id="_todo000113"></a>Member <a class="el" href="group__distributable.html#gaada573d812a582abc182c8f77ac19e96">stir::setup_distributable_computation</a>  (const shared_ptr&lt; ProjectorByBinPair &gt; &amp;proj_pair_sptr, const shared_ptr&lt; ExamInfo &gt; &amp;exam_info_sptr, const <a class="el" href="classstir_1_1ProjDataInfo.html" title="An (abstract base) class that contains information on the projection data. ">ProjDataInfo</a> *const proj_data_info_ptr, const shared_ptr&lt; <a class="el" href="classstir_1_1DiscretisedDensity.html">DiscretisedDensity&lt; 3, float &gt;</a> &gt; &amp;target_sptr, const bool zero_seg0_end_planes, const bool distributed_cache_enabled)</dt>
<dd>currently uses some global variables for configuration in the distributed namespace. This needs to be converted to a class, e.g. <code>DistributedMaster</code>  </dd>
<dt><a class="anchor" id="_todo000167"></a>Class <a class="el" href="classstir_1_1Shape3D.html">stir::Shape3D</a>  </dt>
<dd><p class="startdd">This could/should be generalised to allow general fuzzy shapes. Probably the only thing to change is to let <a class="el" href="classstir_1_1Shape3D.html#aa7327f75ae28f41ed8b7305bc2ea65d6" title="determine if a point is inside the shape or not (up to floating point errors) ">is_inside_shape()</a> return a float (between 0 and 1). This would solve some issues with DiscretisedDhape3D.</p>
<p>The restriction to the 3D case for this base class largely comes from the <a class="el" href="classstir_1_1Shape3D.html#ac1853acdcef8475e61fb3a93e35765b3" title="construct an image representation the shape in a discretised manner ">construct_volume()</a> member (and the origin parsing members)</p>
<p class="enddd">This base class really should have no origin member. For example, <a class="el" href="classstir_1_1DiscretisedShape3D.html" title="A class for shapes that have been discretised. ">DiscretisedShape3D</a> now has effectively two. Instead, we should have an additional class Shape3DWithOrigin. Easy to do. </p>
</dd>
<dt><a class="anchor" id="_todo000171"></a>Member <a class="el" href="classstir_1_1Shape3D.html#ac1853acdcef8475e61fb3a93e35765b3">stir::Shape3D::construct_volume</a>  (VoxelsOnCartesianGrid&lt; float &gt; &amp;image, const <a class="el" href="classstir_1_1CartesianCoordinate3D.html">CartesianCoordinate3D&lt; int &gt;</a> &amp;num_samples) const</dt>
<dd><p class="startdd">Get rid of restriction to allow only VoxelsOnCartesianGrid&lt;float&gt; (but that's rather hard) </p>
<p class="enddd">Potentially this should fill a <a class="el" href="classstir_1_1DiscretisedShape3D.html" title="A class for shapes that have been discretised. ">DiscretisedShape3D</a>.  </p>
</dd>
<dt><a class="anchor" id="_todo000170"></a>Member <a class="el" href="classstir_1_1Shape3D.html#aa7327f75ae28f41ed8b7305bc2ea65d6">stir::Shape3D::is_inside_shape</a>  (const <a class="el" href="classstir_1_1CartesianCoordinate3D.html">CartesianCoordinate3D&lt; float &gt;</a> &amp;coord) const =0</dt>
<dd>replace by floating point return value?  </dd>
<dt><a class="anchor" id="_todo000172"></a>Class <a class="el" href="classstir_1_1Shape3DWithOrientation.html">stir::Shape3DWithOrientation</a>  </dt>
<dd>A previous release had Euler angle code. However, it is currently disabled as there were bugs in it. </dd>
<dt><a class="anchor" id="_todo000163"></a>Class <a class="el" href="classstir_1_1SingleScatterSimulation.html">stir::SingleScatterSimulation</a>  </dt>
<dd>The class is specific to PET so should be renamed accordingly.  </dd>
<dt><a class="anchor" id="_todo000079"></a>Class <a class="el" href="classstir_1_1SPECTListEvent.html">stir::SPECTListEvent</a>  </dt>
<dd>this is still under development. Things to add are for instance energy windows and time-of-flight info. Also, <a class="el" href="classstir_1_1ListEvent.html#a7a9623d9cfd546d8047c92c981199090" title="Finds the bin coordinates of this event for some characteristics of the projection data...">get_bin()</a> would need time info or so for rotating scanners. </dd>
<dt><a class="anchor" id="_todo000173"></a>Member <a class="el" href="group__projdata.html#gac58540d3d092496da3c2c10836a6a77f">stir::SSRB</a>  (const <a class="el" href="classstir_1_1ProjDataInfo.html" title="An (abstract base) class that contains information on the projection data. ">ProjDataInfo</a> &amp;in_proj_data_info, const int num_segments_to_combine, const int num_views_to_combine=1, const int num_tangential_poss_to_trim=0, const int max_in_segment_num_to_process=-1, const int num_tof_bins_to_combine=1)</dt>
<dd><p class="startdd">get rid of both restrictions flagged as warnings in the documentation for this function. </p>
<p class="enddd">rename to something much more general than <code>SSRB</code>  </p>
</dd>
<dt><a class="anchor" id="_todo000147"></a>Class <a class="el" href="classstir_1_1SumOfGeneralisedObjectiveFunctions.html">stir::SumOfGeneralisedObjectiveFunctions&lt; ObjFuncT, TargetT, ParentT &gt;</a>  </dt>
<dd><p class="startdd">document why use of ParentT template </p>
<p class="enddd">doc subsets  </p>
</dd>
<dt><a class="anchor" id="_todo000148"></a>Member <a class="el" href="classstir_1_1SumOfGeneralisedObjectiveFunctions.html#ad133b896ff6307ce2cb5a70388c95f43">stir::SumOfGeneralisedObjectiveFunctions&lt; ObjFuncT, TargetT, ParentT &gt;::actual_subsets_are_approximately_balanced</a>  (std::string &amp;warning_message) const</dt>
<dd>doc subset  </dd>
<dt><a class="anchor" id="_todo000183"></a>Member <a class="el" href="group__motion.html#ga0adbd95408531c79d46fd53888d95db3">stir::transform_3d_object</a>  (<a class="el" href="classstir_1_1DiscretisedDensity.html">DiscretisedDensity&lt; 3, float &gt;</a> &amp;out_density, const <a class="el" href="classstir_1_1DiscretisedDensity.html">DiscretisedDensity&lt; 3, float &gt;</a> &amp;in_density, const <a class="el" href="classstir_1_1RigidObject3DTransformation.html" title="Class to perform rigid object transformations in 3 dimensions. ">RigidObject3DTransformation</a> &amp;transformation_in_to_out)</dt>
<dd>cannot use <a class="el" href="classstir_1_1ObjectTransformation.html" title="Base-class for performing (potentially non-rigid) object transformations. ">ObjectTransformation</a> yet as it needs the inverse transformation  </dd>
<dt><a class="anchor" id="_todo000184"></a>Member <a class="el" href="group__motion.html#gad79cf166422ffc3b7f701fd1e7a897fe">stir::transpose_of_transform_3d_object</a>  (<a class="el" href="classstir_1_1DiscretisedDensity.html">DiscretisedDensity&lt; 3, float &gt;</a> &amp;out_density, const <a class="el" href="classstir_1_1DiscretisedDensity.html">DiscretisedDensity&lt; 3, float &gt;</a> &amp;in_density, const <a class="el" href="classstir_1_1RigidObject3DTransformation.html" title="Class to perform rigid object transformations in 3 dimensions. ">RigidObject3DTransformation</a> &amp;transformation_in_to_out)</dt>
<dd>cannot use <a class="el" href="classstir_1_1ObjectTransformation.html" title="Base-class for performing (potentially non-rigid) object transformations. ">ObjectTransformation</a> yet as it needs the inverse transformation  </dd>
<dt><a class="anchor" id="_todo000149"></a>Class <a class="el" href="classstir_1_1TrivialBinNormalisation.html">stir::TrivialBinNormalisation</a>  </dt>
<dd>Make sure that the keyword value <code>None</code> corresponds to this class. </dd>
<dt><a class="anchor" id="_todo000189"></a>Class <a class="el" href="classstir_1_1Utah__phantom.html">stir::Utah_phantom</a>  </dt>
<dd>dims here are wrong A: cylinder, 20cm diam, 10cm height B: cylinder, 18cm diam, 15cm height C: outer annulus, 20cm extern.diam, 2cm thick, 15cm height D: cylinder in B, 4.5cm diam, 18cm??? height E: shorter cylinder in B, 4.5cm diam, 5.5cm height  </dd>
<dt><a class="anchor" id="_todo000175"></a>Class <a class="el" href="classstir_1_1VectorWithOffset.html">stir::VectorWithOffset&lt; T &gt;</a>  </dt>
<dd>add allocator template as in std::vector. This is non-trivial as we would have to use uninitialized_copy etc. in some places.  </dd>
<dt><a class="anchor" id="_todo000176"></a>Member <a class="el" href="classstir_1_1VectorWithOffset.html#aa0d7c80102ef873b5d60c52f3db4348d">stir::VectorWithOffset&lt; T &gt;::resize</a>  (const int min_index, const int max_index)</dt>
<dd>in principle reallocation could be avoided when the new range would fit in the old one by shifting.  </dd>
<dt><a class="anchor" id="_todo000177"></a>Member <a class="el" href="group__buildblock.html#ga86c10e7ec133abbe6202467168faa93c">stir::warning</a>  (const STRING &amp;string)</dt>
<dd>At a later stage, it will also write to a log-file. </dd>
<dt><a class="anchor" id="_todo000050"></a>File <a class="el" href="test__IO_8h.html">test_IO.h</a>  </dt>
<dd>The current implementation requires that the output file format as also readable by <a class="el" href="group__IO.html#ga023d6e4a62c18b9df73dd31527f7c648" title="Function that reads data from file using the default InputFileFormatRegistry, using the provided File...">stir::read_from_file</a>. At least we should provide a run-time switch to not run that part of the tests.  </dd>
<dt><a class="anchor" id="_todo000206"></a>File <a class="el" href="test__IO__DiscretisedDensity_8cxx.html">test_IO_DiscretisedDensity.cxx</a>  </dt>
<dd>The current implementation requires that the output file format as also readable by <a class="el" href="group__IO.html#ga023d6e4a62c18b9df73dd31527f7c648" title="Function that reads data from file using the default InputFileFormatRegistry, using the provided File...">stir::read_from_file</a>. At least we should provide a run-time switch to not run that part of the tests.  </dd>
<dt><a class="anchor" id="_todo000208"></a>File <a class="el" href="test__IO__DynamicDiscretisedDensity_8cxx.html">test_IO_DynamicDiscretisedDensity.cxx</a>  </dt>
<dd>The current implementation requires that the output file format as also readable by <a class="el" href="group__IO.html#ga023d6e4a62c18b9df73dd31527f7c648" title="Function that reads data from file using the default InputFileFormatRegistry, using the provided File...">stir::read_from_file</a>. At least we should provide a run-time switch to not run that part of the tests.  </dd>
<dt><a class="anchor" id="_todo000210"></a>File <a class="el" href="test_2IO_2test__IO__ParametricDiscretisedDensity_8cxx.html">test_IO_ParametricDiscretisedDensity.cxx</a>  </dt>
<dd>The current implementation requires that the output file format as also readable by <a class="el" href="group__IO.html#ga023d6e4a62c18b9df73dd31527f7c648" title="Function that reads data from file using the default InputFileFormatRegistry, using the provided File...">stir::read_from_file</a>. At least we should provide a run-time switch to not run that part of the tests.  </dd>
<dt><a class="anchor" id="_todo000213"></a>File <a class="el" href="test__OutputFileFormat_8cxx.html">test_OutputFileFormat.cxx</a>  </dt>
<dd>The current implementation requires that the output file format as also readable by <a class="el" href="group__IO.html#ga023d6e4a62c18b9df73dd31527f7c648" title="Function that reads data from file using the default InputFileFormatRegistry, using the provided File...">stir::read_from_file</a>. At least we should provide a run-time switch to not run that part of the tests.  </dd>
<dt><a class="anchor" id="_todo000003"></a>File <a class="el" href="test__proj__data__info__LOR_8cxx.html">test_proj_data_info_LOR.cxx</a>  </dt>
<dd><p class="startdd">test <a class="el" href="classstir_1_1ProjDataInfo.html#a4f1cb72c33d4f53e9ee95ca046c70e19" title="Get LOR corresponding to a given bin. ">stir::ProjDataInfo::get_LOR</a> and <a class="el" href="classstir_1_1ProjDataInfo.html#a5b4e785f8388daa878c91e22ce126e49" title="Find the bin in the projection data that &#39;contains&#39; an LOR. ">stir::ProjDataInfo::get_bin</a> </p>
<p class="enddd">use <a class="el" href="classstir_1_1RunTests.html" title="A base class for making test classesWith a derived class, an application could look like...">stir::RunTests</a>  </p>
</dd>
<dt><a class="anchor" id="_todo000174"></a>File <a class="el" href="TimeGateDefinitions_8h.html">TimeGateDefinitions.h</a>  </dt>
<dd>This files needs proper test </dd>
<dt><a class="anchor" id="_todo000133"></a>Module <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#amgrpae48fe072a5fddedaa876112772bbf79">Variables for STIR_MPI</a>  </dt>
<dd>move to protected area </dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 2 2021 10:00:36 for STIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
