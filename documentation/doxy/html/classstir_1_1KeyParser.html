<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STIR: stir::KeyParser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STIR
   &#160;<span id="projectnumber">4.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestir.html">stir</a></li><li class="navelem"><a class="el" href="classstir_1_1KeyParser.html">KeyParser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classstir_1_1KeyParser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">stir::KeyParser Class Reference<div class="ingroups"><a class="el" href="group__STIR.html">STIR</a> &raquo; <a class="el" href="group__STIR__library.html">STIR library</a> &raquo; <a class="el" href="group__buildblock.html">Basic building blocks</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A class to parse Interfile headers.  
 <a href="classstir_1_1KeyParser.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="KeyParser_8h_source.html">stir/KeyParser.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for stir::KeyParser:</div>
<div class="dyncontent">
<div class="center"><img src="classstir_1_1KeyParser__inherit__graph.png" border="0" usemap="#stir_1_1KeyParser_inherit__map" alt="Inheritance graph"/></div>
<map name="stir_1_1KeyParser_inherit__map" id="stir_1_1KeyParser_inherit__map">
<area shape="rect" id="node2" href="classstir_1_1MinimalInterfileHeader.html" title="a minimal class for Interfile keywords (and parsing) common to all types of data " alt="" coords="168,81,368,108"/>
<area shape="rect" id="node3" href="classstir_1_1InterfileHeader.html" title="a class for Interfile keywords (and parsing) common to all types of data " alt="" coords="416,81,564,108"/>
<area shape="rect" id="node4" href="classstir_1_1InterfileHeaderSiemens.html" title="a class for Interfile keywords (and parsing) common to all types of data " alt="" coords="612,5,816,32"/>
<area shape="rect" id="node5" href="classstir_1_1InterfileImageHeader.html" title="a class for Interfile keywords (and parsing) specific to images " alt="" coords="619,56,809,83"/>
<area shape="rect" id="node6" href="classstir_1_1InterfilePDFSHeader.html" title="a class for Interfile keywords (and parsing) specific to projection data (i.e. ProjDataFromStream) ..." alt="" coords="623,107,805,133"/>
<area shape="rect" id="node7" href="classstir_1_1InterfilePDFSHeaderSPECT.html" title="a class for Interfile keywords (and parsing) specific to SPECT projection data " alt="" coords="623,158,805,199"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a08ca6f6fc94772b3f2832b438a0a6b43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a08ca6f6fc94772b3f2832b438a0a6b43">parse</a> (std::istream &amp;f, const bool write_warnings=true)</td></tr>
<tr class="memdesc:a08ca6f6fc94772b3f2832b438a0a6b43"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstir_1_1KeyParser.html#a08ca6f6fc94772b3f2832b438a0a6b43" title="parse() returns false if there is some error, true otherwise ">parse()</a> returns false if there is some error, true otherwise  <a href="#a08ca6f6fc94772b3f2832b438a0a6b43">More...</a><br /></td></tr>
<tr class="separator:a08ca6f6fc94772b3f2832b438a0a6b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae835c59ce855b24eef4220656c9df2fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#ae835c59ce855b24eef4220656c9df2fc">parse</a> (const char *const filename, const bool write_warnings=true)</td></tr>
<tr class="memdesc:ae835c59ce855b24eef4220656c9df2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstir_1_1KeyParser.html#a08ca6f6fc94772b3f2832b438a0a6b43" title="parse() returns false if there is some error, true otherwise ">parse()</a> returns false if there is some error, true otherwise  <a href="#ae835c59ce855b24eef4220656c9df2fc">More...</a><br /></td></tr>
<tr class="separator:ae835c59ce855b24eef4220656c9df2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0df590f8e6b676f5d5410da654021a"><td class="memItemLeft" align="right" valign="top"><a id="ace0df590f8e6b676f5d5410da654021a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#ace0df590f8e6b676f5d5410da654021a">add_key</a> (const std::string &amp;keyword, float *variable_ptr)</td></tr>
<tr class="memdesc:ace0df590f8e6b676f5d5410da654021a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as a float and put it in *variable_ptr <br /></td></tr>
<tr class="separator:ace0df590f8e6b676f5d5410da654021a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402cb40676f6927f4bbf1903ab5f7e43"><td class="memItemLeft" align="right" valign="top"><a id="a402cb40676f6927f4bbf1903ab5f7e43"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a402cb40676f6927f4bbf1903ab5f7e43">add_vectorised_key</a> (const std::string &amp;keyword, std::vector&lt; float &gt; *variable_ptr)</td></tr>
<tr class="memdesc:a402cb40676f6927f4bbf1903ab5f7e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a vectorised keyword. When parsing, parse its value as a float and put it in <code></code>(*variable_ptr)[current_index] <br /></td></tr>
<tr class="separator:a402cb40676f6927f4bbf1903ab5f7e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1273fca9ae54b80ac1abfead043421bd"><td class="memItemLeft" align="right" valign="top"><a id="a1273fca9ae54b80ac1abfead043421bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a1273fca9ae54b80ac1abfead043421bd">add_key</a> (const std::string &amp;keyword, double *variable_ptr)</td></tr>
<tr class="memdesc:a1273fca9ae54b80ac1abfead043421bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as a double and put it in *variable_ptr <br /></td></tr>
<tr class="separator:a1273fca9ae54b80ac1abfead043421bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe39db966516191684e8a21b8194465"><td class="memItemLeft" align="right" valign="top"><a id="a5fe39db966516191684e8a21b8194465"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a5fe39db966516191684e8a21b8194465">add_vectorised_key</a> (const std::string &amp;keyword, std::vector&lt; double &gt; *variable_ptr)</td></tr>
<tr class="memdesc:a5fe39db966516191684e8a21b8194465"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a vectorised keyword. When parsing, parse its value as a double and put it in <code></code>(*variable_ptr)[current_index] <br /></td></tr>
<tr class="separator:a5fe39db966516191684e8a21b8194465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc419bdab24cbb90848e4c33bd634e58"><td class="memItemLeft" align="right" valign="top"><a id="adc419bdab24cbb90848e4c33bd634e58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#adc419bdab24cbb90848e4c33bd634e58">add_vectorised_key</a> (const std::string &amp;keyword, std::vector&lt; std::vector&lt; double &gt; &gt; *variable_ptr)</td></tr>
<tr class="memdesc:adc419bdab24cbb90848e4c33bd634e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a vectorised keyword. When parsing, parse its value as a list of doubles and put it in <code></code>(*variable_ptr)[current_index] <br /></td></tr>
<tr class="separator:adc419bdab24cbb90848e4c33bd634e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503b8d99edc00f245e3b8c505d940c9a"><td class="memItemLeft" align="right" valign="top"><a id="a503b8d99edc00f245e3b8c505d940c9a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a503b8d99edc00f245e3b8c505d940c9a">add_key</a> (const std::string &amp;keyword, int *variable_ptr)</td></tr>
<tr class="memdesc:a503b8d99edc00f245e3b8c505d940c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as a int and put it in *variable_ptr <br /></td></tr>
<tr class="separator:a503b8d99edc00f245e3b8c505d940c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d29594b310d5e2a74b3f0a2dc0f736"><td class="memItemLeft" align="right" valign="top"><a id="a02d29594b310d5e2a74b3f0a2dc0f736"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a02d29594b310d5e2a74b3f0a2dc0f736">add_key</a> (const std::string &amp;keyword, std::vector&lt; int &gt; *variable_ptr)</td></tr>
<tr class="memdesc:a02d29594b310d5e2a74b3f0a2dc0f736"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as a int and put it in *variable_ptr <br /></td></tr>
<tr class="separator:a02d29594b310d5e2a74b3f0a2dc0f736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24b5427ebf63dfc5261bec995d26590"><td class="memItemLeft" align="right" valign="top"><a id="ad24b5427ebf63dfc5261bec995d26590"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#ad24b5427ebf63dfc5261bec995d26590">add_vectorised_key</a> (const std::string &amp;keyword, std::vector&lt; int &gt; *variable_ptr)</td></tr>
<tr class="memdesc:ad24b5427ebf63dfc5261bec995d26590"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a vectorised keyword. When parsing, parse its value as a int and put it in <code></code>(*variable_ptr)[current_index] <br /></td></tr>
<tr class="separator:ad24b5427ebf63dfc5261bec995d26590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020cb14be59d52cac7dc9301c2054ef6"><td class="memItemLeft" align="right" valign="top"><a id="a020cb14be59d52cac7dc9301c2054ef6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a020cb14be59d52cac7dc9301c2054ef6">add_vectorised_key</a> (const std::string &amp;keyword, std::vector&lt; std::vector&lt; int &gt; &gt; *variable_ptr)</td></tr>
<tr class="memdesc:a020cb14be59d52cac7dc9301c2054ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a vectorised keyword. When parsing, parse its value as a list of ints and put it in <code></code>(*variable_ptr)[current_index] <br /></td></tr>
<tr class="separator:a020cb14be59d52cac7dc9301c2054ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa105e778bdb0f79a2414c62b67fe81e3"><td class="memItemLeft" align="right" valign="top"><a id="aa105e778bdb0f79a2414c62b67fe81e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#aa105e778bdb0f79a2414c62b67fe81e3">add_key</a> (const std::string &amp;keyword, long int *variable_ptr)</td></tr>
<tr class="memdesc:aa105e778bdb0f79a2414c62b67fe81e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as a int and put it in *variable_ptr <br /></td></tr>
<tr class="separator:aa105e778bdb0f79a2414c62b67fe81e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea574aa744922f155c708644c7aaf957"><td class="memItemLeft" align="right" valign="top"><a id="aea574aa744922f155c708644c7aaf957"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#aea574aa744922f155c708644c7aaf957">add_key</a> (const std::string &amp;keyword, unsigned int *variable_ptr)</td></tr>
<tr class="memdesc:aea574aa744922f155c708644c7aaf957"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as a int and put it in *variable_ptr <br /></td></tr>
<tr class="separator:aea574aa744922f155c708644c7aaf957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7205090cdac13123e158722ecf5784c9"><td class="memItemLeft" align="right" valign="top"><a id="a7205090cdac13123e158722ecf5784c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a7205090cdac13123e158722ecf5784c9">add_vectorised_key</a> (const std::string &amp;keyword, std::vector&lt; unsigned int &gt; *variable)</td></tr>
<tr class="memdesc:a7205090cdac13123e158722ecf5784c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a vectorised keyword. When parsing, parse its value as an unsigned int and put it in <code></code>(*variable_ptr)[current_index] <br /></td></tr>
<tr class="separator:a7205090cdac13123e158722ecf5784c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4fe2a38e222b438e13c159bcfc3a94"><td class="memItemLeft" align="right" valign="top"><a id="a7f4fe2a38e222b438e13c159bcfc3a94"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a7f4fe2a38e222b438e13c159bcfc3a94">add_key</a> (const std::string &amp;keyword, unsigned long *variable_ptr)</td></tr>
<tr class="memdesc:a7f4fe2a38e222b438e13c159bcfc3a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as an unsigned long and put it in *variable_ptr <br /></td></tr>
<tr class="separator:a7f4fe2a38e222b438e13c159bcfc3a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a45f50717b66d7032e87965772b4c0"><td class="memItemLeft" align="right" valign="top"><a id="a50a45f50717b66d7032e87965772b4c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a50a45f50717b66d7032e87965772b4c0">add_vectorised_key</a> (const std::string &amp;keyword, std::vector&lt; unsigned long &gt; *variable_ptr)</td></tr>
<tr class="memdesc:a50a45f50717b66d7032e87965772b4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a vectorised keyword. When parsing, parse its value as an unsigned long and put it in <code></code>(*variable_ptr)[current_index] <br /></td></tr>
<tr class="separator:a50a45f50717b66d7032e87965772b4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36283cf64a02e99b9810be31a9e967a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a36283cf64a02e99b9810be31a9e967a4">add_key</a> (const std::string &amp;keyword, bool *variable_ptr)</td></tr>
<tr class="memdesc:a36283cf64a02e99b9810be31a9e967a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as a int and put the bool value in *variable_ptr  <a href="#a36283cf64a02e99b9810be31a9e967a4">More...</a><br /></td></tr>
<tr class="separator:a36283cf64a02e99b9810be31a9e967a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8015b917ca80074d6bd1d5a84b8a8b08"><td class="memItemLeft" align="right" valign="top"><a id="a8015b917ca80074d6bd1d5a84b8a8b08"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a8015b917ca80074d6bd1d5a84b8a8b08">add_key</a> (const std::string &amp;keyword, std::vector&lt; double &gt; *variable_ptr)</td></tr>
<tr class="memdesc:a8015b917ca80074d6bd1d5a84b8a8b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as a list of doubles and put its value in *variable_ptr <br /></td></tr>
<tr class="separator:a8015b917ca80074d6bd1d5a84b8a8b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9595ae460776e3d34f1759842bbb4473"><td class="memItemLeft" align="right" valign="top"><a id="a9595ae460776e3d34f1759842bbb4473"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a9595ae460776e3d34f1759842bbb4473">add_key</a> (const std::string &amp;keyword, std::vector&lt; std::string &gt; *variable_ptr)</td></tr>
<tr class="memdesc:a9595ae460776e3d34f1759842bbb4473"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as a list of comma-separated strings and put its value in *variable_ptr <br /></td></tr>
<tr class="separator:a9595ae460776e3d34f1759842bbb4473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ad654cf7e9869a61ea6705d996e0b3"><td class="memItemLeft" align="right" valign="top"><a id="aa0ad654cf7e9869a61ea6705d996e0b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#aa0ad654cf7e9869a61ea6705d996e0b3">add_key</a> (const std::string &amp;keyword, <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 2, float &gt; *variable_ptr)</td></tr>
<tr class="memdesc:aa0ad654cf7e9869a61ea6705d996e0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as a 2d array of floats and put its value in *variable_ptr <br /></td></tr>
<tr class="separator:aa0ad654cf7e9869a61ea6705d996e0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddd9aac9bb83e590c314f96d238da3a"><td class="memItemLeft" align="right" valign="top"><a id="a2ddd9aac9bb83e590c314f96d238da3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a2ddd9aac9bb83e590c314f96d238da3a">add_key</a> (const std::string &amp;keyword, <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, float &gt; *variable_ptr)</td></tr>
<tr class="memdesc:a2ddd9aac9bb83e590c314f96d238da3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as a 3d array of floats and put its value in *variable_ptr <br /></td></tr>
<tr class="separator:a2ddd9aac9bb83e590c314f96d238da3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c57cacf9f0a3449d9f605e496fabd16"><td class="memItemLeft" align="right" valign="top"><a id="a4c57cacf9f0a3449d9f605e496fabd16"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a4c57cacf9f0a3449d9f605e496fabd16">add_key</a> (const std::string &amp;keyword, <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, float &gt; *variable_ptr)</td></tr>
<tr class="memdesc:a4c57cacf9f0a3449d9f605e496fabd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as a 3d <a class="el" href="classstir_1_1BasicCoordinate.html" title="class BasicCoordinate&lt;int num_dimensions, typename coordT&gt; defines num_dimensions -dimensional coordi...">BasicCoordinate</a> of floats and put its value in *variable_ptr <br /></td></tr>
<tr class="separator:a4c57cacf9f0a3449d9f605e496fabd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0656bd690ab288672772fc5bbc0b911"><td class="memItemLeft" align="right" valign="top"><a id="ae0656bd690ab288672772fc5bbc0b911"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#ae0656bd690ab288672772fc5bbc0b911">add_key</a> (const std::string &amp;keyword, <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, float &gt; &gt; *variable_ptr)</td></tr>
<tr class="memdesc:ae0656bd690ab288672772fc5bbc0b911"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, parse its value as a 3d <a class="el" href="classstir_1_1BasicCoordinate.html" title="class BasicCoordinate&lt;int num_dimensions, typename coordT&gt; defines num_dimensions -dimensional coordi...">BasicCoordinate</a> of a 3d array of floats and put its value in *variable_ptr <br /></td></tr>
<tr class="separator:ae0656bd690ab288672772fc5bbc0b911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b547427bbe54d728a5a71fc1e205f15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a3b547427bbe54d728a5a71fc1e205f15">add_key</a> (const std::string &amp;keyword, std::string *variable_ptr)</td></tr>
<tr class="separator:a3b547427bbe54d728a5a71fc1e205f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf7e5099fed5d1e68c923cfdbda8342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#abcf7e5099fed5d1e68c923cfdbda8342">add_vectorised_key</a> (const std::string &amp;keyword, std::vector&lt; std::string &gt; *variable_ptr)</td></tr>
<tr class="memdesc:abcf7e5099fed5d1e68c923cfdbda8342"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a vectorised keyword. When parsing, parse its value as a string and put it in <code></code>(*variable_ptr)[current_index]  <a href="#abcf7e5099fed5d1e68c923cfdbda8342">More...</a><br /></td></tr>
<tr class="separator:abcf7e5099fed5d1e68c923cfdbda8342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e1ba9954bbbd3bd5b7a958a636b67f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a69e1ba9954bbbd3bd5b7a958a636b67f">add_key</a> (const std::string &amp;keyword, int *variable_ptr, const ASCIIlist_type *const list_of_values)</td></tr>
<tr class="memdesc:a69e1ba9954bbbd3bd5b7a958a636b67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword. When parsing, its string value is checked against a list of strings. The corresponding index is stored in variable_ptr.  <a href="#a69e1ba9954bbbd3bd5b7a958a636b67f">More...</a><br /></td></tr>
<tr class="separator:a69e1ba9954bbbd3bd5b7a958a636b67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715e180ed62dd9b63abcdf9b813f3d42"><td class="memItemLeft" align="right" valign="top"><a id="a715e180ed62dd9b63abcdf9b813f3d42"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a715e180ed62dd9b63abcdf9b813f3d42">ignore_key</a> (const std::string &amp;keyword)</td></tr>
<tr class="memdesc:a715e180ed62dd9b63abcdf9b813f3d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add keyword this is just ignored by the parser. <br /></td></tr>
<tr class="separator:a715e180ed62dd9b63abcdf9b813f3d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9888661e50ab3a45504abd91e57d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a2f9888661e50ab3a45504abd91e57d72">add_start_key</a> (const std::string &amp;keyword)</td></tr>
<tr class="memdesc:a2f9888661e50ab3a45504abd91e57d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">add keyword that has to occur before all others  <a href="#a2f9888661e50ab3a45504abd91e57d72">More...</a><br /></td></tr>
<tr class="separator:a2f9888661e50ab3a45504abd91e57d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92a7db6e8ab333adf8741acfcd95cb9"><td class="memItemLeft" align="right" valign="top"><a id="aa92a7db6e8ab333adf8741acfcd95cb9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#aa92a7db6e8ab333adf8741acfcd95cb9">add_stop_key</a> (const std::string &amp;keyword)</td></tr>
<tr class="memdesc:aa92a7db6e8ab333adf8741acfcd95cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword that when encountered, will stop the parsing <br /></td></tr>
<tr class="separator:aa92a7db6e8ab333adf8741acfcd95cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ac36b0d6259233724f5f1b89ab20fb"><td class="memTemplParams" colspan="2">template&lt;typename ParsingClass &gt; </td></tr>
<tr class="memitem:a31ac36b0d6259233724f5f1b89ab20fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a31ac36b0d6259233724f5f1b89ab20fb">add_parsing_key</a> (const std::string &amp;keyword, ParsingClass **parsed_object_ptr_ptr)</td></tr>
<tr class="memdesc:a31ac36b0d6259233724f5f1b89ab20fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">add keyword corresponding to an object that will parse the next keys itself  <a href="#a31ac36b0d6259233724f5f1b89ab20fb">More...</a><br /></td></tr>
<tr class="separator:a31ac36b0d6259233724f5f1b89ab20fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43471a913ec1d55d23b690df8880247f"><td class="memTemplParams" colspan="2">template&lt;typename ParsingClass &gt; </td></tr>
<tr class="memitem:a43471a913ec1d55d23b690df8880247f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a43471a913ec1d55d23b690df8880247f">add_parsing_key</a> (const std::string &amp;keyword, shared_ptr&lt; ParsingClass &gt; *parsed_object_ptr_ptr)</td></tr>
<tr class="memdesc:a43471a913ec1d55d23b690df8880247f"><td class="mdescLeft">&#160;</td><td class="mdescRight">add keyword corresponding to an object that will parse the next keys itself  <a href="#a43471a913ec1d55d23b690df8880247f">More...</a><br /></td></tr>
<tr class="separator:a43471a913ec1d55d23b690df8880247f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b28df9f1085e73e037fa829d99dbd3a"><td class="memItemLeft" align="right" valign="top"><a id="a5b28df9f1085e73e037fa829d99dbd3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a5b28df9f1085e73e037fa829d99dbd3a">print_keywords_to_stream</a> (std::ostream &amp;) const</td></tr>
<tr class="memdesc:a5b28df9f1085e73e037fa829d99dbd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints all keywords (in random order) to the stream. <br /></td></tr>
<tr class="separator:a5b28df9f1085e73e037fa829d99dbd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5b0bca8a73d015c9fef5dbe6aebb71"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a4e5b0bca8a73d015c9fef5dbe6aebb71">parameter_info</a> () const</td></tr>
<tr class="memdesc:a4e5b0bca8a73d015c9fef5dbe6aebb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string with keywords and their values.  <a href="#a4e5b0bca8a73d015c9fef5dbe6aebb71">More...</a><br /></td></tr>
<tr class="separator:a4e5b0bca8a73d015c9fef5dbe6aebb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee4511c9040f002985af97336d84ffd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#acee4511c9040f002985af97336d84ffd">ask_parameters</a> ()</td></tr>
<tr class="memdesc:acee4511c9040f002985af97336d84ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask interactively for values for all keywords.  <a href="#acee4511c9040f002985af97336d84ffd">More...</a><br /></td></tr>
<tr class="separator:acee4511c9040f002985af97336d84ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18afa74f9bad622968472b1b918ee699"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a18afa74f9bad622968472b1b918ee699">find_in_ASCIIlist</a> (const std::string &amp;, const ASCIIlist_type &amp;list_of_values)</td></tr>
<tr class="memdesc:a18afa74f9bad622968472b1b918ee699"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index of a string in 'list_of_values', -1 if not found  <a href="#a18afa74f9bad622968472b1b918ee699">More...</a><br /></td></tr>
<tr class="separator:a18afa74f9bad622968472b1b918ee699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46de0f60836c7e79938fdda780641381"><td class="memItemLeft" align="right" valign="top"><a id="a46de0f60836c7e79938fdda780641381"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a46de0f60836c7e79938fdda780641381">start_parsing</a> ()</td></tr>
<tr class="memdesc:a46de0f60836c7e79938fdda780641381"><td class="mdescLeft">&#160;</td><td class="mdescRight">callback function to start parsing, has to be set by first keyword <br /></td></tr>
<tr class="separator:a46de0f60836c7e79938fdda780641381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b886da1a41689c63624a41913b8ea4"><td class="memItemLeft" align="right" valign="top"><a id="a58b886da1a41689c63624a41913b8ea4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a58b886da1a41689c63624a41913b8ea4">stop_parsing</a> ()</td></tr>
<tr class="memdesc:a58b886da1a41689c63624a41913b8ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">to stop parsing <br /></td></tr>
<tr class="separator:a58b886da1a41689c63624a41913b8ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85972eee166cdc25ce3e901a89f40b5"><td class="memItemLeft" align="right" valign="top"><a id="ab85972eee166cdc25ce3e901a89f40b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#ab85972eee166cdc25ce3e901a89f40b5">do_nothing</a> ()</td></tr>
<tr class="memdesc:ab85972eee166cdc25ce3e901a89f40b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">callback function for keys which do not do anything <br /></td></tr>
<tr class="separator:ab85972eee166cdc25ce3e901a89f40b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b0dc0a34dc427ffda4de8154ae31e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a05b0dc0a34dc427ffda4de8154ae31e6">set_variable</a> ()</td></tr>
<tr class="memdesc:a05b0dc0a34dc427ffda4de8154ae31e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">callback function that sets the variable to the value given as the value of the keyword  <a href="#a05b0dc0a34dc427ffda4de8154ae31e6">More...</a><br /></td></tr>
<tr class="separator:a05b0dc0a34dc427ffda4de8154ae31e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639eee3531f5cb1c95274f34b9312b01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a639eee3531f5cb1c95274f34b9312b01">set_parsing_object</a> ()</td></tr>
<tr class="memdesc:a639eee3531f5cb1c95274f34b9312b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">callback function that sets the variable by calling the parser (as stored by <a class="el" href="classstir_1_1KeyParser.html#a31ac36b0d6259233724f5f1b89ab20fb" title="add keyword corresponding to an object that will parse the next keys itself ">add_parsing_key()</a>), with argument the value of the keyword  <a href="#a639eee3531f5cb1c95274f34b9312b01">More...</a><br /></td></tr>
<tr class="separator:a639eee3531f5cb1c95274f34b9312b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c488f57e21f7bf61fcc30287b9111b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a04c488f57e21f7bf61fcc30287b9111b">set_shared_parsing_object</a> ()</td></tr>
<tr class="memdesc:a04c488f57e21f7bf61fcc30287b9111b"><td class="mdescLeft">&#160;</td><td class="mdescRight">callback function that sets the shared_ptr variable by calling the parser (as stored by <a class="el" href="classstir_1_1KeyParser.html#a31ac36b0d6259233724f5f1b89ab20fb" title="add keyword corresponding to an object that will parse the next keys itself ">add_parsing_key()</a>), with argument the value of the keyword  <a href="#a04c488f57e21f7bf61fcc30287b9111b">More...</a><br /></td></tr>
<tr class="separator:a04c488f57e21f7bf61fcc30287b9111b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a6186152f315ff27bc0a293308bf64f05"><td class="memItemLeft" align="right" valign="top"><a id="a6186152f315ff27bc0a293308bf64f05"></a>
typedef void(KeyParser::*&#160;</td><td class="memItemRight" valign="bottom"><b>KeywordProcessor</b>) ()</td></tr>
<tr class="separator:a6186152f315ff27bc0a293308bf64f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1a9a476639a8bc800bee613f5178f722"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a1a9a476639a8bc800bee613f5178f722">post_processing</a> ()</td></tr>
<tr class="memdesc:a1a9a476639a8bc800bee613f5178f722"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will be called at the end of the parsing.  <a href="#a1a9a476639a8bc800bee613f5178f722">More...</a><br /></td></tr>
<tr class="separator:a1a9a476639a8bc800bee613f5178f722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88a689951a4b3179493c3aae392520b"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#ae88a689951a4b3179493c3aae392520b">standardise_keyword</a> (const std::string &amp;keyword) const</td></tr>
<tr class="memdesc:ae88a689951a4b3179493c3aae392520b"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert 'rough' keyword into a standardised form  <a href="#ae88a689951a4b3179493c3aae392520b">More...</a><br /></td></tr>
<tr class="separator:ae88a689951a4b3179493c3aae392520b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4c2ecb4ba6a7896cc3e4303523a64f"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#abf4c2ecb4ba6a7896cc3e4303523a64f">get_keyword</a> (const std::string &amp;) const</td></tr>
<tr class="memdesc:abf4c2ecb4ba6a7896cc3e4303523a64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets a keyword from a string  <a href="#abf4c2ecb4ba6a7896cc3e4303523a64f">More...</a><br /></td></tr>
<tr class="separator:abf4c2ecb4ba6a7896cc3e4303523a64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f4f7bbbc4eacdde5aa160481150fcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a77f4f7bbbc4eacdde5aa160481150fcb">add_key</a> (const std::string &amp;keyword, KeyArgument::type t, KeywordProcessor function, void *variable=0, const ASCIIlist_type *const list=0)</td></tr>
<tr class="memdesc:a77f4f7bbbc4eacdde5aa160481150fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword to the list, together with its call_back function  <a href="#a77f4f7bbbc4eacdde5aa160481150fcb">More...</a><br /></td></tr>
<tr class="separator:a77f4f7bbbc4eacdde5aa160481150fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d8a334e666bf06c933fb6a24b4fe1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#af7d8a334e666bf06c933fb6a24b4fe1a">add_key</a> (const std::string &amp;keyword, KeyArgument::type t, KeywordProcessor function, void *variable, const int vectorised_key_level, const ASCIIlist_type *const list=0)</td></tr>
<tr class="memdesc:af7d8a334e666bf06c933fb6a24b4fe1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a keyword to the list, together with its call_back function  <a href="#af7d8a334e666bf06c933fb6a24b4fe1a">More...</a><br /></td></tr>
<tr class="separator:af7d8a334e666bf06c933fb6a24b4fe1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa047edb9faf9f29bdf5f67cdb7355628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#aa047edb9faf9f29bdf5f67cdb7355628">add_key</a> (const std::string &amp;keyword, KeyArgument::type t, void *variable, const ASCIIlist_type *const list=0)</td></tr>
<tr class="memdesc:aa047edb9faf9f29bdf5f67cdb7355628"><td class="mdescLeft">&#160;</td><td class="mdescRight">version that defaults 'function' to set_variable  <a href="#aa047edb9faf9f29bdf5f67cdb7355628">More...</a><br /></td></tr>
<tr class="separator:aa047edb9faf9f29bdf5f67cdb7355628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a0e8aacf9736fa6c3d31e4425ea655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a71a0e8aacf9736fa6c3d31e4425ea655">add_key</a> (const std::string &amp;keyword, KeyArgument::type t, void *variable, const int vectorised_key_level, const ASCIIlist_type *const list=0)</td></tr>
<tr class="memdesc:a71a0e8aacf9736fa6c3d31e4425ea655"><td class="mdescLeft">&#160;</td><td class="mdescRight">version that defaults 'function' to set_variable  <a href="#a71a0e8aacf9736fa6c3d31e4425ea655">More...</a><br /></td></tr>
<tr class="separator:a71a0e8aacf9736fa6c3d31e4425ea655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9174427fa54ff09cba8765295ebb5bb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1KeyParser.html#a9174427fa54ff09cba8765295ebb5bb2">remove_key</a> (const std::string &amp;keyword)</td></tr>
<tr class="memdesc:a9174427fa54ff09cba8765295ebb5bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a key from the kep map.  <a href="#a9174427fa54ff09cba8765295ebb5bb2">More...</a><br /></td></tr>
<tr class="separator:a9174427fa54ff09cba8765295ebb5bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3ad52c24bdfe4cf012e253786a91858d"><td class="memItemLeft" align="right" valign="top"><a id="a3ad52c24bdfe4cf012e253786a91858d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>map_element</b></td></tr>
<tr class="separator:a3ad52c24bdfe4cf012e253786a91858d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class to parse Interfile headers. </p>
<p>Currently, Interfile 3.3 parsing rules are hard-coded, with some extensions.</p>
<p><a class="el" href="classstir_1_1KeyParser.html" title="A class to parse Interfile headers. ">KeyParser</a> reads input line by line and parses each line separately. It allows for '\r' at the end of the line (as in files originating in DOS/Windows). When the line ends with a backslash '\', the next line will just be appended to the current one. That is, '\' acts as continuation marker.</p>
<p>Lines can have arbitrary length.</p>
<p>A special facility is provided for using the value of environment variables: after reading the whole line, the text is checked for occurences of the form <code>${some_text}$</code>. These text strings are then replaced by the value of the corresponding environment variables (using the std::getenv function).</p>
<dl class="section warning"><dt>Warning</dt><dd>For end-of-line continuation, the backslash HAS to be the last character. Even spaces after it will stop the 'continuation'.</dd>
<dd>
The use of the [*] index for vectorised keys is NOT supported.</dd></dl>
<p>Main problem: when non-trivial callback functions have to be used, you need to do it via a derived class (as <a class="el" href="classstir_1_1KeyParser.html" title="A class to parse Interfile headers. ">KeyParser</a> requires pointers to member functions.)</p>
<dl class="section warning"><dt>Warning</dt><dd>As <a class="el" href="classstir_1_1KeyParser.html#ace0df590f8e6b676f5d5410da654021a" title="add a keyword. When parsing, parse its value as a float and put it in *variable_ptr ...">KeyParser::add_key</a> stores pointers to the variables where you want your results, it is somewhat dangerous to copy a <a class="el" href="classstir_1_1KeyParser.html" title="A class to parse Interfile headers. ">KeyParser</a> object. That is, its keymap will still point to the same variables.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000054">Todo:</a></b></dt><dd>add checking functions in the map, as in </dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classstir_1_1KeyParser.html#ace0df590f8e6b676f5d5410da654021a">add_key</a>(<span class="stringliteral">&quot;my key&quot;</span>,&amp;my_value, check_positive); </div></div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000055">Todo:</a></b></dt><dd>add facilities for checking (while parsing) if a keyword was present before the current one </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a08ca6f6fc94772b3f2832b438a0a6b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ca6f6fc94772b3f2832b438a0a6b43">&#9670;&nbsp;</a></span>parse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stir::KeyParser::parse </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>write_warnings</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classstir_1_1KeyParser.html#a08ca6f6fc94772b3f2832b438a0a6b43" title="parse() returns false if there is some error, true otherwise ">parse()</a> returns false if there is some error, true otherwise </p>
<p>if <em>write_warnings</em> is <code>false</code>, warnigns about undefined keywords will be supressed. </p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1ecat_1_1CListModeDataECAT8__32bit.html#aa3973ddeb0a4a852d9e7a9a45cbc7fb1">stir::ecat::CListModeDataECAT8_32bit::CListModeDataECAT8_32bit()</a>, <a class="el" href="classstir_1_1CListModeDataROOT.html#a8baf41a636d8db8d42a028d41cbde356">stir::CListModeDataROOT::CListModeDataROOT()</a>, <a class="el" href="classstir_1_1RigidObject3DMotionFromPolaris.html#a73ace820fd73adbfd78d5fa44eac4bdf">stir::RigidObject3DMotionFromPolaris::post_processing()</a>, <a class="el" href="classstir_1_1ScatterEstimation.html#aceaf7c9893842d246996d16c0b03f8a0">stir::ScatterEstimation::post_processing()</a>, <a class="el" href="namespacedistributed.html#a59355c8b36a8904c9f869ed1a8ca6023">distributed::receive_and_construct_exam_and_proj_data_info_ptr()</a>, <a class="el" href="classstir_1_1ecat_1_1BinNormalisationFromECAT8.html#a0e97ca9b7f59ea248a43278b710e9d59">stir::ecat::BinNormalisationFromECAT8::set_up()</a>, and <a class="el" href="classstir_1_1TimeFrameDefinitions.html#af863595d5f7123c15bca6704515056e7">stir::TimeFrameDefinitions::TimeFrameDefinitions()</a>.</p>

</div>
</div>
<a id="ae835c59ce855b24eef4220656c9df2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae835c59ce855b24eef4220656c9df2fc">&#9670;&nbsp;</a></span>parse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stir::KeyParser::parse </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>write_warnings</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classstir_1_1KeyParser.html#a08ca6f6fc94772b3f2832b438a0a6b43" title="parse() returns false if there is some error, true otherwise ">parse()</a> returns false if there is some error, true otherwise </p>
<p>if <em>write_warnings</em> is <code>false</code>, warnigns about undefined keywords will be supressed. </p>

<p class="reference">References <a class="el" href="group__buildblock.html#ga45e27d9de6cdc69c146e791a825a20da">stir::warning()</a>.</p>

</div>
</div>
<a id="a36283cf64a02e99b9810be31a9e967a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36283cf64a02e99b9810be31a9e967a4">&#9670;&nbsp;</a></span>add_key() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::add_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>variable_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a keyword. When parsing, parse its value as a int and put the bool value in *variable_ptr </p>
<p>The integer should be 0 or 1, corresponding to false and true resp. </p>

</div>
</div>
<a id="a3b547427bbe54d728a5a71fc1e205f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b547427bbe54d728a5a71fc1e205f15">&#9670;&nbsp;</a></span>add_key() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::add_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>variable_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The 'value' can contain spaces. </p>

</div>
</div>
<a id="abcf7e5099fed5d1e68c923cfdbda8342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf7e5099fed5d1e68c923cfdbda8342">&#9670;&nbsp;</a></span>add_vectorised_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::add_vectorised_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>variable_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a vectorised keyword. When parsing, parse its value as a string and put it in <code></code>(*variable_ptr)[current_index] </p>
<p>The 'value' can contain spaces. </p>

</div>
</div>
<a id="a69e1ba9954bbbd3bd5b7a958a636b67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e1ba9954bbbd3bd5b7a958a636b67f">&#9670;&nbsp;</a></span>add_key() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::add_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>variable_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ASCIIlist_type *const&#160;</td>
          <td class="paramname"><em>list_of_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a keyword. When parsing, its string value is checked against a list of strings. The corresponding index is stored in variable_ptr. </p>
<p>If no match is found, a warning message is issued and *variable_ptr is set to -1. </p>

</div>
</div>
<a id="a2f9888661e50ab3a45504abd91e57d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9888661e50ab3a45504abd91e57d72">&#9670;&nbsp;</a></span>add_start_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::add_start_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyword</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add keyword that has to occur before all others </p>
<p>Example of such a key: INTERFILE </p>

<p class="reference">References <a class="el" href="classstir_1_1KeyParser.html#a46de0f60836c7e79938fdda780641381">start_parsing()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1AbsTimeIntervalFromDynamicData.html#a2e8f912d3fcfeae3ed864421bab32e15">stir::AbsTimeIntervalFromDynamicData::AbsTimeIntervalFromDynamicData()</a>, <a class="el" href="classstir_1_1AbsTimeIntervalFromECAT7ACF.html#abcdf6a876759e327cf373a3f871a1691">stir::AbsTimeIntervalFromECAT7ACF::AbsTimeIntervalFromECAT7ACF()</a>, <a class="el" href="classstir_1_1BackProjectorByBinUsingSquareProjMatrixByBin.html#a3a83373665a23153de5ad1e771eb6c19">stir::BackProjectorByBinUsingSquareProjMatrixByBin::actual_back_project()</a>, <a class="el" href="classstir_1_1ChainedDataProcessor.html#a07bbecb3da123f2d9ba85198aba5e87e">stir::ChainedDataProcessor&lt; DataT &gt;::ChainedDataProcessor()</a>, <a class="el" href="classstir_1_1CListModeDataROOT.html#a8baf41a636d8db8d42a028d41cbde356">stir::CListModeDataROOT::CListModeDataROOT()</a>, <a class="el" href="classstir_1_1DiscretisedShape3D.html#ac6c1214080116aaade987256b1eb84ce">stir::DiscretisedShape3D::DiscretisedShape3D()</a>, <a class="el" href="classstir_1_1SeparableCartesianMetzImageFilter.html#a51fce83a63606e9062998c9b18a58949">stir::SeparableCartesianMetzImageFilter&lt; elemT &gt;::get_max_kernel_sizes()</a>, <a class="el" href="classstir_1_1BackProjectorByBinNiftyPET.html#aedb64c5fb954e5c09985b56d5f251e83">stir::BackProjectorByBinNiftyPET::initialise_keymap()</a>, <a class="el" href="classstir_1_1ForwardProjectorByBinNiftyPET.html#a992445a0da1d3ab7c9e254bce355af71">stir::ForwardProjectorByBinNiftyPET::initialise_keymap()</a>, <a class="el" href="classstir_1_1SingleScatterSimulation.html#a458b8c10b5842d8334175f06cb9832e5">stir::SingleScatterSimulation::initialise_keymap()</a>, <a class="el" href="classstir_1_1SeparableGaussianImageFilter.html#a08ffab306b8127f4f8057c63fd8ff0d5">stir::SeparableGaussianImageFilter&lt; elemT &gt;::initialise_keymap()</a>, <a class="el" href="classstir_1_1InputStreamFromROOTFileForECATPET.html#a53019277d10511dbc5d2b065aa519948">stir::InputStreamFromROOTFileForECATPET::initialise_keymap()</a>, <a class="el" href="classstir_1_1InputStreamFromROOTFileForCylindricalPET.html#abc14bcad3b88e037248fc209e8b065b8">stir::InputStreamFromROOTFileForCylindricalPET::initialise_keymap()</a>, <a class="el" href="classstir_1_1ForwardProjectorByBin.html#a661783a56af61eb4b62e45fde03f8ff4">stir::ForwardProjectorByBin::initialise_keymap()</a>, <a class="el" href="classstir_1_1BackProjectorByBin.html#a1213ce53e95f5bb22dbe05face140d0e">stir::BackProjectorByBin::initialise_keymap()</a>, <a class="el" href="classstir_1_1ScatterEstimation.html#af4a883113f5f2ee32f74cbb9a5067d88">stir::ScatterEstimation::initialise_keymap()</a>, <a class="el" href="classstir_1_1RigidObject3DMotionFromPolaris.html#a73ace820fd73adbfd78d5fa44eac4bdf">stir::RigidObject3DMotionFromPolaris::post_processing()</a>, <a class="el" href="classstir_1_1ScatterEstimation.html#aceaf7c9893842d246996d16c0b03f8a0">stir::ScatterEstimation::post_processing()</a>, <a class="el" href="classstir_1_1ProjMatrixByBinUsingInterpolation.html#af38923176710a95e928624c99d19381b">stir::ProjMatrixByBinUsingInterpolation::ProjMatrixByBinUsingInterpolation()</a>, <a class="el" href="classstir_1_1ecat_1_1BinNormalisationFromECAT8.html#a0e97ca9b7f59ea248a43278b710e9d59">stir::ecat::BinNormalisationFromECAT8::set_up()</a>, and <a class="el" href="classstir_1_1RigidObject3DMotionFromPolaris.html#a49f0b2bae4660791e9efb62e4ddadc89">stir::RigidObject3DMotionFromPolaris::synchronise()</a>.</p>

</div>
</div>
<a id="a31ac36b0d6259233724f5f1b89ab20fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ac36b0d6259233724f5f1b89ab20fb">&#9670;&nbsp;</a></span>add_parsing_key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParsingClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::add_parsing_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParsingClass **&#160;</td>
          <td class="paramname"><em>parsed_object_ptr_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add keyword corresponding to an object that will parse the next keys itself </p>
<p>When this keyword is encountered during parsing, the parser ParsingClass::read_registered_object(name) is called, with 'name' set to to the value of the keyword.</p>
<p>ParsingClass has to be derived from <a class="el" href="classstir_1_1RegisteredObject.html" title="Helper class to provide registry mechanisms to a Base classSuppose you have a hierarchy of classes wi...">RegisteredObject</a> (strictly speaking it only has to be derived from Object, and provide a static function void read_registered_object(string&amp;)).</p>
<p>Example of usage: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>SomeReconstruction </div><div class="line">{</div><div class="line">  SomeReconstruction();</div><div class="line">  ImageProcessor&lt;3,float&gt;* filter_ptr;</div><div class="line">  <span class="keywordtype">double</span> beta;     </div><div class="line">  KeyParser parser;</div><div class="line">};      </div><div class="line"></div><div class="line">SomeReconstruction::SomeReconstruction()</div><div class="line">{</div><div class="line">      beta = 1;</div><div class="line">      filter_ptr = 0;</div><div class="line">      parser.add_start_key(<span class="stringliteral">&quot;SomeReconstructionParameters&quot;</span>);</div><div class="line">      parser.add_key(<span class="stringliteral">&quot;beta &quot;</span>, &amp;beta);</div><div class="line">      parser.add_parsing_key(<span class="stringliteral">&quot;MAP a la MRP filter type&quot;</span>, &amp;filter_ptr);</div><div class="line">      parser.add_stop_key(<span class="stringliteral">&quot;END SomeReconstruction Parameters&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>The .par file then would look as follows </p><pre class="fragment">  SomeReconstructionParameters :=
    beta := 0.001
    MAP a la MRP filter type := Median
    ; keywords here appropriate to a Median ImageFilter
  End SomeReconstruction Parameters:= ;
</pre> 
<p class="reference">Referenced by <a class="el" href="classstir_1_1BackProjectorByBinUsingSquareProjMatrixByBin.html#a3a83373665a23153de5ad1e771eb6c19">stir::BackProjectorByBinUsingSquareProjMatrixByBin::actual_back_project()</a>, <a class="el" href="classstir_1_1ChainedDataProcessor.html#a07bbecb3da123f2d9ba85198aba5e87e">stir::ChainedDataProcessor&lt; DataT &gt;::ChainedDataProcessor()</a>, <a class="el" href="classstir_1_1CListModeDataROOT.html#a8baf41a636d8db8d42a028d41cbde356">stir::CListModeDataROOT::CListModeDataROOT()</a>, <a class="el" href="classstir_1_1ForwardProjectorByBin.html#a661783a56af61eb4b62e45fde03f8ff4">stir::ForwardProjectorByBin::initialise_keymap()</a>, <a class="el" href="classstir_1_1BackProjectorByBin.html#a1213ce53e95f5bb22dbe05face140d0e">stir::BackProjectorByBin::initialise_keymap()</a>, <a class="el" href="classstir_1_1ScatterEstimation.html#af4a883113f5f2ee32f74cbb9a5067d88">stir::ScatterEstimation::initialise_keymap()</a>, and <a class="el" href="classstir_1_1ScatterEstimation.html#aceaf7c9893842d246996d16c0b03f8a0">stir::ScatterEstimation::post_processing()</a>.</p>

</div>
</div>
<a id="a43471a913ec1d55d23b690df8880247f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43471a913ec1d55d23b690df8880247f">&#9670;&nbsp;</a></span>add_parsing_key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParsingClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::add_parsing_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; ParsingClass &gt; *&#160;</td>
          <td class="paramname"><em>parsed_object_ptr_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add keyword corresponding to an object that will parse the next keys itself </p>
<p>As above, but with a shared_ptr </p>

</div>
</div>
<a id="a4e5b0bca8a73d015c9fef5dbe6aebb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5b0bca8a73d015c9fef5dbe6aebb71">&#9670;&nbsp;</a></span>parameter_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string stir::KeyParser::parameter_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string with keywords and their values. </p>
<p>Keywords are listed in the order they are inserted in the keymap (except for start and stop keys which are listed first and last).</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>breaks with 'vectorised' keys. </dd></dl>

<p class="reference">References <a class="el" href="classstir_1_1RegisteredObjectBase.html#a9eb7d6e93407316c0780e2121e522ae4">stir::RegisteredObjectBase::get_registered_name()</a>, <a class="el" href="classstir_1_1KeyParser.html#a46de0f60836c7e79938fdda780641381">start_parsing()</a>, <a class="el" href="classstir_1_1KeyParser.html#a58b886da1a41689c63624a41913b8ea4">stop_parsing()</a>, and <a class="el" href="group__buildblock.html#ga45e27d9de6cdc69c146e791a825a20da">stir::warning()</a>.</p>

</div>
</div>
<a id="acee4511c9040f002985af97336d84ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee4511c9040f002985af97336d84ffd">&#9670;&nbsp;</a></span>ask_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::ask_parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ask interactively for values for all keywords. </p>
<p>Keywords are asked in the order they are inserted in the keymap.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000056">Todo:</a></b></dt><dd>any consistency checks are currently done by <a class="el" href="classstir_1_1KeyParser.html#a1a9a476639a8bc800bee613f5178f722" title="This will be called at the end of the parsing. ">post_processing()</a> at the end of the parsing. It should be possible to have checks after every question such that it can be repeated.</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>breaks with for 'vectorised' keys. </dd></dl>

<p class="reference">References <a class="el" href="classstir_1_1KeyParser.html#ab85972eee166cdc25ce3e901a89f40b5">do_nothing()</a>, <a class="el" href="classstir_1_1KeyParser.html#a46de0f60836c7e79938fdda780641381">start_parsing()</a>, <a class="el" href="classstir_1_1KeyParser.html#a58b886da1a41689c63624a41913b8ea4">stop_parsing()</a>, and <a class="el" href="group__buildblock.html#ga45e27d9de6cdc69c146e791a825a20da">stir::warning()</a>.</p>

</div>
</div>
<a id="a18afa74f9bad622968472b1b918ee699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18afa74f9bad622968472b1b918ee699">&#9670;&nbsp;</a></span>find_in_ASCIIlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stir::KeyParser::find_in_ASCIIlist </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>par_ascii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ASCIIlist_type &amp;&#160;</td>
          <td class="paramname"><em>list_of_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the index of a string in 'list_of_values', -1 if not found </p>
<p>Implementation note: this function is non-static because it uses standardise_keyword </p>

</div>
</div>
<a id="a1a9a476639a8bc800bee613f5178f722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9a476639a8bc800bee613f5178f722">&#9670;&nbsp;</a></span>post_processing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool stir::KeyParser::post_processing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This will be called at the end of the parsing. </p>
<dl class="section return"><dt>Returns</dt><dd>false if everything OK, true if not </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000057">Todo:</a></b></dt><dd><p class="startdd">return <a class="el" href="classstir_1_1Succeeded.html" title="a class containing an enumeration type that can be used by functions to signal successful operation o...">Succeeded</a> instead. </p>
<p class="enddd">rename to <code>post_parsing()</code> </p>
</dd></dl>

<p>Reimplemented in <a class="el" href="classstir_1_1InterfilePDFSHeader.html#a2a713f500cba47b52a366969e066e90a">stir::InterfilePDFSHeader</a>, <a class="el" href="classstir_1_1InterfileImageHeader.html#adb4d156da50dc1c8a2e26c01ac802c39">stir::InterfileImageHeader</a>, <a class="el" href="classstir_1_1InterfileListmodeHeaderSiemens.html#aea36cf6b58b0f3e7e14b4d093ae4338e">stir::InterfileListmodeHeaderSiemens</a>, <a class="el" href="classstir_1_1InterfilePDFSHeaderSiemens.html#ae7d24990011aa8c35e5aeeb46a998b7a">stir::InterfilePDFSHeaderSiemens</a>, <a class="el" href="classstir_1_1InterfileRawDataHeaderSiemens.html#ad9e29007720a4c8d04e3d6307a8da1d8">stir::InterfileRawDataHeaderSiemens</a>, <a class="el" href="classstir_1_1InterfileHeader.html#af9cee00c096a2c401260f29139128094">stir::InterfileHeader</a>, <a class="el" href="classstir_1_1InterfileHeaderSiemens.html#a3754b86f34a8ada9deeae2340e95db86">stir::InterfileHeaderSiemens</a>, and <a class="el" href="classstir_1_1InterfilePDFSHeaderSPECT.html#a9c9a50577c1186bc990504c62966194a">stir::InterfilePDFSHeaderSPECT</a>.</p>

</div>
</div>
<a id="ae88a689951a4b3179493c3aae392520b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88a689951a4b3179493c3aae392520b">&#9670;&nbsp;</a></span>standardise_keyword()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string stir::KeyParser::standardise_keyword </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyword</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert 'rough' keyword into a standardised form </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000058">Todo:</a></b></dt><dd>Implementation note: this function is non-static such that it can be overloaded. Probably a template with a function object would be better. </dd></dl>
<p>This follows Interfile 3.3 conventions: </p><ul>
<li>
The characters <code>space</code>, <code>tab</code>, <code>underscore</code>, <code>!</code> are all treated as white space and ignored. </li>
<li>
Case is ignored. </li>
</ul>
<p>Note: in this implementation 'ignoring' white space means 'trimming' at the start and end of the keyword, and replacing repeated white space with a single space. </p>

<p class="reference">References <a class="el" href="namespacestir.html#a674b256e49c1eadcd4f614dded8acc3e">stir::standardise_interfile_keyword()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1InterfilePDFSHeaderSiemens.html#ae7d24990011aa8c35e5aeeb46a998b7a">stir::InterfilePDFSHeaderSiemens::post_processing()</a>.</p>

</div>
</div>
<a id="abf4c2ecb4ba6a7896cc3e4303523a64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4c2ecb4ba6a7896cc3e4303523a64f">&#9670;&nbsp;</a></span>get_keyword()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string stir::KeyParser::get_keyword </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gets a keyword from a string </p>
<p>Implementation note: this function is non-static as it uses <a class="el" href="classstir_1_1KeyParser.html#ae88a689951a4b3179493c3aae392520b" title="convert &#39;rough&#39; keyword into a standardised form ">standardise_keyword()</a>. </p>

</div>
</div>
<a id="a77f4f7bbbc4eacdde5aa160481150fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f4f7bbbc4eacdde5aa160481150fcb">&#9670;&nbsp;</a></span>add_key() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::add_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyArgument::type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeywordProcessor&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>variable</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ASCIIlist_type *const&#160;</td>
          <td class="paramname"><em>list</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a keyword to the list, together with its call_back function </p>
<p>This provides a more flexible way to add keys with specific call_backs. Can currently only be used by derived classes, as KeywordProcessor has to be a pointer to member function. </p><dl class="section warning"><dt>Warning</dt><dd>this interface to <a class="el" href="classstir_1_1KeyParser.html" title="A class to parse Interfile headers. ">KeyParser</a> will change in a future release </dd></dl>

</div>
</div>
<a id="af7d8a334e666bf06c933fb6a24b4fe1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d8a334e666bf06c933fb6a24b4fe1a">&#9670;&nbsp;</a></span>add_key() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::add_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyArgument::type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeywordProcessor&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>vectorised_key_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ASCIIlist_type *const&#160;</td>
          <td class="paramname"><em>list</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a keyword to the list, together with its call_back function </p>
<p>This provides a more flexible way to add keys with specific call_backs. Can currently only be used by derived classes, as KeywordProcessor has to be a pointer to member function. </p><dl class="section warning"><dt>Warning</dt><dd>this interface to <a class="el" href="classstir_1_1KeyParser.html" title="A class to parse Interfile headers. ">KeyParser</a> will change in a future release </dd></dl>

</div>
</div>
<a id="aa047edb9faf9f29bdf5f67cdb7355628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa047edb9faf9f29bdf5f67cdb7355628">&#9670;&nbsp;</a></span>add_key() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::add_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyArgument::type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ASCIIlist_type *const&#160;</td>
          <td class="paramname"><em>list</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>version that defaults 'function' to set_variable </p>
<dl class="section warning"><dt>Warning</dt><dd>this interface to <a class="el" href="classstir_1_1KeyParser.html" title="A class to parse Interfile headers. ">KeyParser</a> will change in a future release </dd></dl>

</div>
</div>
<a id="a71a0e8aacf9736fa6c3d31e4425ea655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a0e8aacf9736fa6c3d31e4425ea655">&#9670;&nbsp;</a></span>add_key() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::add_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyArgument::type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>vectorised_key_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ASCIIlist_type *const&#160;</td>
          <td class="paramname"><em>list</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>version that defaults 'function' to set_variable </p>
<dl class="section warning"><dt>Warning</dt><dd>this interface to <a class="el" href="classstir_1_1KeyParser.html" title="A class to parse Interfile headers. ">KeyParser</a> will change in a future release </dd></dl>

</div>
</div>
<a id="a9174427fa54ff09cba8765295ebb5bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9174427fa54ff09cba8765295ebb5bb2">&#9670;&nbsp;</a></span>remove_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stir::KeyParser::remove_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keyword</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a key from the kep map. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if it was found, <code>false</code> otherwise </dd></dl>

<p class="reference">References <a class="el" href="group__buildblock.html#ga45e27d9de6cdc69c146e791a825a20da">stir::warning()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1InterfileHeaderSiemens.html#a3754b86f34a8ada9deeae2340e95db86">stir::InterfileHeaderSiemens::post_processing()</a>, and <a class="el" href="classstir_1_1InterfileRawDataHeaderSiemens.html#ad9e29007720a4c8d04e3d6307a8da1d8">stir::InterfileRawDataHeaderSiemens::post_processing()</a>.</p>

</div>
</div>
<a id="a05b0dc0a34dc427ffda4de8154ae31e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b0dc0a34dc427ffda4de8154ae31e6">&#9670;&nbsp;</a></span>set_variable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::set_variable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>callback function that sets the variable to the value given as the value of the keyword </p>
<p>if the keyword had no value, set_variable will do nothing </p>

<p class="reference">References <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f">stir::error()</a>, and <a class="el" href="group__buildblock.html#ga45e27d9de6cdc69c146e791a825a20da">stir::warning()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1InterfileHeaderSiemens.html#a3754b86f34a8ada9deeae2340e95db86">stir::InterfileHeaderSiemens::post_processing()</a>, and <a class="el" href="classstir_1_1InterfileRawDataHeaderSiemens.html#ad9e29007720a4c8d04e3d6307a8da1d8">stir::InterfileRawDataHeaderSiemens::post_processing()</a>.</p>

</div>
</div>
<a id="a639eee3531f5cb1c95274f34b9312b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639eee3531f5cb1c95274f34b9312b01">&#9670;&nbsp;</a></span>set_parsing_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::set_parsing_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>callback function that sets the variable by calling the parser (as stored by <a class="el" href="classstir_1_1KeyParser.html#a31ac36b0d6259233724f5f1b89ab20fb" title="add keyword corresponding to an object that will parse the next keys itself ">add_parsing_key()</a>), with argument the value of the keyword </p>
<p>if the keyword had no value, set_variable will do nothing </p>

<p class="reference">References <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f">stir::error()</a>.</p>

</div>
</div>
<a id="a04c488f57e21f7bf61fcc30287b9111b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c488f57e21f7bf61fcc30287b9111b">&#9670;&nbsp;</a></span>set_shared_parsing_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stir::KeyParser::set_shared_parsing_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>callback function that sets the shared_ptr variable by calling the parser (as stored by <a class="el" href="classstir_1_1KeyParser.html#a31ac36b0d6259233724f5f1b89ab20fb" title="add keyword corresponding to an object that will parse the next keys itself ">add_parsing_key()</a>), with argument the value of the keyword </p>
<p>if the keyword had no value, set_variable will do nothing </p>

<p class="reference">References <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f">stir::error()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/sirfuser/devel/STIRdistrib/STIR/src/include/stir/<a class="el" href="KeyParser_8h_source.html">KeyParser.h</a></li>
<li>/home/sirfuser/devel/STIRdistrib/STIR/src/buildblock/<a class="el" href="KeyParser_8cxx.html">KeyParser.cxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 7 2021 07:21:20 for STIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
