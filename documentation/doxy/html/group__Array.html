<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STIR: Items relating to vectors and (multi-dimensional) arrays</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STIR
   &#160;<span id="projectnumber">4.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Items relating to vectors and (multi-dimensional) arrays<div class="ingroups"><a class="el" href="group__STIR.html">STIR</a> &raquo; <a class="el" href="group__STIR__library.html">STIR library</a> &raquo; <a class="el" href="group__buildblock.html">Basic building blocks</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Items relating to vectors and (multi-dimensional) arrays:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__Array.png" border="0" alt="" usemap="#group____Array"/>
<map name="group____Array" id="group____Array">
<area shape="rect" id="node2" href="group__Array__IO.html" title="Functions that implement\l IO for Array objects" alt="" coords="633,5,821,47"/>
<area shape="rect" id="node3" href="group__test.html" title="Tests of the basic\l building blocks" alt="" coords="660,96,795,137"/>
<area shape="rect" id="node4" href="group__Array__detail.html" title="Implementation details\l used by Array classes" alt="" coords="640,173,815,215"/>
<area shape="rect" id="node5" href="group__buildblock.html" title="Basic building blocks" alt="" coords="5,114,164,141"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__Array__detail"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Array__detail.html">Implementation details used by Array classes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__Array__IO"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Array__IO.html">Functions that implement IO for Array objects</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:Array_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array_8cxx.html">Array.cxx</a></td></tr>
<tr class="memdesc:Array_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">non-inline implementations for the Array class <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ArrayFilter1DUsingConvolution_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ArrayFilter1DUsingConvolution_8cxx.html">ArrayFilter1DUsingConvolution.cxx</a></td></tr>
<tr class="memdesc:ArrayFilter1DUsingConvolution_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations for class <a class="el" href="classstir_1_1ArrayFilter1DUsingConvolution.html" title="This class implements convolution of a 1D array with an arbitrary (i.e. potentially non-symmetric) ke...">stir::ArrayFilter1DUsingConvolution</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ArrayFilter1DUsingConvolutionSymmetricKernel_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ArrayFilter1DUsingConvolutionSymmetricKernel_8cxx.html">ArrayFilter1DUsingConvolutionSymmetricKernel.cxx</a></td></tr>
<tr class="memdesc:ArrayFilter1DUsingConvolutionSymmetricKernel_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations for class <a class="el" href="classstir_1_1ArrayFilter1DUsingConvolutionSymmetricKernel.html" title="This class implements convolution of a 1D array with a symmetric kernel. ">stir::ArrayFilter1DUsingConvolutionSymmetricKernel</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ArrayFilterUsingRealDFTWithPadding_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ArrayFilterUsingRealDFTWithPadding_8cxx.html">ArrayFilterUsingRealDFTWithPadding.cxx</a></td></tr>
<tr class="memdesc:ArrayFilterUsingRealDFTWithPadding_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of class <a class="el" href="classstir_1_1ArrayFilterUsingRealDFTWithPadding.html" title="This class implements convolution of an array of real numbers with an arbitrary (i.e. potentially non-symmetric) kernel using DFTs. ">stir::ArrayFilterUsingRealDFTWithPadding</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:centre__of__gravity_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="centre__of__gravity_8cxx.html">centre_of_gravity.cxx</a></td></tr>
<tr class="memdesc:centre__of__gravity_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of <a class="el" href="centre__of__gravity_8h.html" title="This file contains functions to compute the centre of gravity of arrays and images. ">centre_of_gravity.h</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:IndexRange_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IndexRange_8cxx.html">IndexRange.cxx</a></td></tr>
<tr class="memdesc:IndexRange_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementations for the <a class="el" href="classstir_1_1IndexRange.html" title="This class defines ranges which can be &#39;irregular&#39;. ">stir::IndexRange</a> class <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:MaximalArrayFilter3D_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MaximalArrayFilter3D_8cxx.html">MaximalArrayFilter3D.cxx</a></td></tr>
<tr class="memdesc:MaximalArrayFilter3D_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the dilation filter (i.e. voxel=max(neighbours)) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:MedianArrayFilter3D_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MedianArrayFilter3D_8cxx.html">MedianArrayFilter3D.cxx</a></td></tr>
<tr class="memdesc:MedianArrayFilter3D_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations for class <a class="el" href="classstir_1_1MedianArrayFilter3D.html" title="Implements median filtering on 3D arrays. ">stir::MedianArrayFilter3D</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:MinimalArrayFilter3D_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MinimalArrayFilter3D_8cxx.html">MinimalArrayFilter3D.cxx</a></td></tr>
<tr class="memdesc:MinimalArrayFilter3D_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the erosion filter (i.e. voxel=min(neighbours)) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SeparableArrayFunctionObject_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SeparableArrayFunctionObject_8cxx.html">SeparableArrayFunctionObject.cxx</a></td></tr>
<tr class="memdesc:SeparableArrayFunctionObject_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations for <a class="el" href="classstir_1_1SeparableArrayFunctionObject.html" title="This class implements an n -dimensional ArrayFunctionObject whose operation is separable. ">stir::SeparableArrayFunctionObject</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SeparableGaussianArrayFilter_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SeparableGaussianArrayFilter_8cxx.html">SeparableGaussianArrayFilter.cxx</a></td></tr>
<tr class="memdesc:SeparableGaussianArrayFilter_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations for class <a class="el" href="classstir_1_1SeparableGaussianArrayFilter.html" title="Separable Gaussian filtering in n - dimensions. ">stir::SeparableGaussianArrayFilter</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SeparableMetzArrayFilter_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SeparableMetzArrayFilter_8cxx.html">SeparableMetzArrayFilter.cxx</a></td></tr>
<tr class="memdesc:SeparableMetzArrayFilter_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations for class <a class="el" href="classstir_1_1SeparableMetzArrayFilter.html" title="Separable Metz filtering in n - dimensions. ">stir::SeparableMetzArrayFilter</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:Array_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array_8h.html">Array.h</a></td></tr>
<tr class="memdesc:Array_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the Array class for multi-dimensional (numeric) arrays <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:Array_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array_8inl.html">Array.inl</a></td></tr>
<tr class="memdesc:Array_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline implementations for the <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">stir::Array</a> class <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:Array1d_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array1d_8h.html">Array1d.h</a></td></tr>
<tr class="memdesc:Array1d_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the 1D specialisation of the Array class for broken compilers <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:Array__complex__numbers_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Array__complex__numbers_8h.html">Array_complex_numbers.h</a></td></tr>
<tr class="memdesc:Array__complex__numbers_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines additional numerical operations for arrays of complex numbers <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:array__index__functions_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__index__functions_8h.html">array_index_functions.h</a></td></tr>
<tr class="memdesc:array__index__functions_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">a variety of useful functions for indexing <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">stir::Array</a> objects <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:array__index__functions_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="array__index__functions_8inl.html">array_index_functions.inl</a></td></tr>
<tr class="memdesc:array__index__functions_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of functions in <a class="el" href="array__index__functions_8h.html" title="a variety of useful functions for indexing stir::Array objects ">stir/array_index_functions.h</a> <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ArrayFilter1DUsingConvolution_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ArrayFilter1DUsingConvolution_8h.html">ArrayFilter1DUsingConvolution.h</a></td></tr>
<tr class="memdesc:ArrayFilter1DUsingConvolution_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of class <a class="el" href="classstir_1_1ArrayFilter1DUsingConvolution.html" title="This class implements convolution of a 1D array with an arbitrary (i.e. potentially non-symmetric) ke...">stir::ArrayFilter1DUsingConvolution</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ArrayFilter1DUsingConvolutionSymmetricKernel_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ArrayFilter1DUsingConvolutionSymmetricKernel_8h.html">ArrayFilter1DUsingConvolutionSymmetricKernel.h</a></td></tr>
<tr class="memdesc:ArrayFilter1DUsingConvolutionSymmetricKernel_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of class <a class="el" href="classstir_1_1ArrayFilter1DUsingConvolutionSymmetricKernel.html" title="This class implements convolution of a 1D array with a symmetric kernel. ">stir::ArrayFilter1DUsingConvolutionSymmetricKernel</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ArrayFilterUsingRealDFTWithPadding_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ArrayFilterUsingRealDFTWithPadding_8h.html">ArrayFilterUsingRealDFTWithPadding.h</a></td></tr>
<tr class="memdesc:ArrayFilterUsingRealDFTWithPadding_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of class <a class="el" href="classstir_1_1ArrayFilterUsingRealDFTWithPadding.html" title="This class implements convolution of an array of real numbers with an arbitrary (i.e. potentially non-symmetric) kernel using DFTs. ">stir::ArrayFilterUsingRealDFTWithPadding</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ArrayFunction_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ArrayFunction_8h.html">ArrayFunction.h</a></td></tr>
<tr class="memdesc:ArrayFunction_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This include file provides some additional functionality for <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">stir::Array</a> objects. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ArrayFunction_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ArrayFunction_8inl.html">ArrayFunction.inl</a></td></tr>
<tr class="memdesc:ArrayFunction_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations for <a class="el" href="ArrayFunction_8h.html" title="This include file provides some additional functionality for stir::Array objects. ...">ArrayFunction.h</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ArrayFunctionObject_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ArrayFunctionObject_8h.html">ArrayFunctionObject.h</a></td></tr>
<tr class="memdesc:ArrayFunctionObject_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of class <a class="el" href="classstir_1_1ArrayFunctionObject.html" title="A class for operations on n-dimensional Arrays. ">stir::ArrayFunctionObject</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ArrayFunctionObject__1ArgumentImplementation_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ArrayFunctionObject__1ArgumentImplementation_8h.html">ArrayFunctionObject_1ArgumentImplementation.h</a></td></tr>
<tr class="memdesc:ArrayFunctionObject__1ArgumentImplementation_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of class <a class="el" href="classstir_1_1ArrayFunctionObject__1ArgumentImplementation.html" title="A convenience class for children of ArrayFunctionObject. It implements the 2 argument operator() in t...">stir::ArrayFunctionObject_1ArgumentImplementation</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ArrayFunctionObject__2ArgumentImplementation_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ArrayFunctionObject__2ArgumentImplementation_8h.html">ArrayFunctionObject_2ArgumentImplementation.h</a></td></tr>
<tr class="memdesc:ArrayFunctionObject__2ArgumentImplementation_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of class <a class="el" href="classstir_1_1ArrayFunctionObject__2ArgumentImplementation.html" title="A convenience class for children of ArrayFunctionObject. It implements the in-place operator() in ter...">stir::ArrayFunctionObject_2ArgumentImplementation</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:assign__to__subregion_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assign__to__subregion_8h.html">assign_to_subregion.h</a></td></tr>
<tr class="memdesc:assign__to__subregion_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">declares the <a class="el" href="group__Array.html#ga585c22e0a650f60c6263a1f9041629e7" title="assign a value to a sub-region of an array ">stir::assign_to_subregion</a> function <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:assign__to__subregion_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assign__to__subregion_8inl.html">assign_to_subregion.inl</a></td></tr>
<tr class="memdesc:assign__to__subregion_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of the <a class="el" href="group__Array.html#ga585c22e0a650f60c6263a1f9041629e7" title="assign a value to a sub-region of an array ">stir::assign_to_subregion</a> function <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:BoundaryConditions_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BoundaryConditions_8h.html">BoundaryConditions.h</a></td></tr>
<tr class="memdesc:BoundaryConditions_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of class <a class="el" href="classstir_1_1BoundaryConditions.html" title="Preliminary class to specify boundary conditions for filters. ">stir::BoundaryConditions</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:centre__of__gravity_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="centre__of__gravity_8h.html">centre_of_gravity.h</a></td></tr>
<tr class="memdesc:centre__of__gravity_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file contains functions to compute the centre of gravity of arrays and images. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:convert__array_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="convert__array_8h.html">convert_array.h</a></td></tr>
<tr class="memdesc:convert__array_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file declares the <a class="el" href="group__Array.html#gaa732f225afedbdd7e23c51ac7a879769" title="A function that returns a new Array (of the same dimension) with elements of type T2...">stir::convert_array</a> functions. This is a function to convert <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">stir::Array</a> objects to a different numeric type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:convert__array_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="convert__array_8inl.html">convert_array.inl</a></td></tr>
<tr class="memdesc:convert__array_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of <a class="el" href="group__Array.html#gaa732f225afedbdd7e23c51ac7a879769" title="A function that returns a new Array (of the same dimension) with elements of type T2...">stir::convert_array</a> <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:convert__range_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="convert__range_8h.html">convert_range.h</a></td></tr>
<tr class="memdesc:convert__range_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file declares the <a class="el" href="group__Array.html#ga56484b2412114338773aa3eab2fb1f6b" title="Converts the data in the input range to the output range (with elements of different types) such that...">stir::convert_range</a> and <a class="el" href="group__Array.html#gaa5bb010e50caacfa64f8568fbef591cd" title="A function that finds a scale factor to use when converting data to a new type. ">stir::find_scale_factor</a> functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:convert__range_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="convert__range_8inl.html">convert_range.inl</a></td></tr>
<tr class="memdesc:convert__range_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of <a class="el" href="group__Array.html#ga56484b2412114338773aa3eab2fb1f6b" title="Converts the data in the input range to the output range (with elements of different types) such that...">stir::convert_range</a> <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:FullArrayIterator_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FullArrayIterator_8h.html">FullArrayIterator.h</a></td></tr>
<tr class="memdesc:FullArrayIterator_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file declares the <a class="el" href="classstir_1_1FullArrayIterator.html" title="Class FullArrayIterator implements (forward) iterators that go through all elements of an Array...">stir::FullArrayIterator</a> class. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:FullArrayIterator_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FullArrayIterator_8inl.html">FullArrayIterator.inl</a></td></tr>
<tr class="memdesc:FullArrayIterator_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline implementations for <a class="el" href="classstir_1_1FullArrayIterator.html" title="Class FullArrayIterator implements (forward) iterators that go through all elements of an Array...">stir::FullArrayIterator</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:IndexRange_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IndexRange_8inl.html">IndexRange.inl</a></td></tr>
<tr class="memdesc:IndexRange_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline definitions for the IndexRange class <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:IndexRange2D_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IndexRange2D_8h.html">IndexRange2D.h</a></td></tr>
<tr class="memdesc:IndexRange2D_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file declares the class <a class="el" href="classstir_1_1IndexRange2D.html" title="a &#39;convenience&#39; class for 2D index ranges. ">stir::IndexRange2D</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:IndexRange2D_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IndexRange2D_8inl.html">IndexRange2D.inl</a></td></tr>
<tr class="memdesc:IndexRange2D_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline implementations for <a class="el" href="classstir_1_1IndexRange2D.html" title="a &#39;convenience&#39; class for 2D index ranges. ">stir::IndexRange2D</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:IndexRange3D_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IndexRange3D_8h.html">IndexRange3D.h</a></td></tr>
<tr class="memdesc:IndexRange3D_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file declares the class <a class="el" href="classstir_1_1IndexRange3D.html" title="a &#39;convenience&#39; class for 3D index ranges. Provides an easier constructor for regular ranges...">stir::IndexRange3D</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:IndexRange3D_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IndexRange3D_8inl.html">IndexRange3D.inl</a></td></tr>
<tr class="memdesc:IndexRange3D_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline implementations for <a class="el" href="classstir_1_1IndexRange3D.html" title="a &#39;convenience&#39; class for 3D index ranges. Provides an easier constructor for regular ranges...">stir::IndexRange3D</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:IndexRange4D_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IndexRange4D_8h.html">IndexRange4D.h</a></td></tr>
<tr class="memdesc:IndexRange4D_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file declares the class <a class="el" href="classstir_1_1IndexRange4D.html" title="A convenience class for 4D index ranges. ">stir::IndexRange4D</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:IndexRange4D_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IndexRange4D_8inl.html">IndexRange4D.inl</a></td></tr>
<tr class="memdesc:IndexRange4D_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline implementations for <a class="el" href="classstir_1_1IndexRange4D.html" title="A convenience class for 4D index ranges. ">stir::IndexRange4D</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:make__array_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="make__array_8h.html">make_array.h</a></td></tr>
<tr class="memdesc:make__array_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of functions for constructing arrays stir::make_1d_array etc. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:make__array_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="make__array_8inl.html">make_array.inl</a></td></tr>
<tr class="memdesc:make__array_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of functions for constructing arrays stir::make_1d_array etc. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:MaximalArrayFilter3D_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MaximalArrayFilter3D_8h.html">MaximalArrayFilter3D.h</a></td></tr>
<tr class="memdesc:MaximalArrayFilter3D_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the dilation filter (i.e. voxel=max(neighbours)) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:MedianArrayFilter3D_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MedianArrayFilter3D_8h.html">MedianArrayFilter3D.h</a></td></tr>
<tr class="memdesc:MedianArrayFilter3D_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of class <a class="el" href="classstir_1_1MedianArrayFilter3D.html" title="Implements median filtering on 3D arrays. ">stir::MedianArrayFilter3D</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:MinimalArrayFilter3D_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MinimalArrayFilter3D_8h.html">MinimalArrayFilter3D.h</a></td></tr>
<tr class="memdesc:MinimalArrayFilter3D_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the erosion filter (i.e. voxel=min(neighbours)) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:NumericVectorWithOffset_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="NumericVectorWithOffset_8inl.html">NumericVectorWithOffset.inl</a></td></tr>
<tr class="memdesc:NumericVectorWithOffset_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline implementations for NumericVectorWithOffset <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SeparableArrayFunctionObject_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SeparableArrayFunctionObject_8h.html">SeparableArrayFunctionObject.h</a></td></tr>
<tr class="memdesc:SeparableArrayFunctionObject_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of class <a class="el" href="classstir_1_1SeparableArrayFunctionObject.html" title="This class implements an n -dimensional ArrayFunctionObject whose operation is separable. ">stir::SeparableArrayFunctionObject</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:SeparableMetzArrayFilter_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SeparableMetzArrayFilter_8h.html">SeparableMetzArrayFilter.h</a></td></tr>
<tr class="memdesc:SeparableMetzArrayFilter_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of class <a class="el" href="classstir_1_1SeparableMetzArrayFilter.html" title="Separable Metz filtering in n - dimensions. ">stir::SeparableMetzArrayFilter</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:VectorWithOffset_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorWithOffset_8h.html">VectorWithOffset.h</a></td></tr>
<tr class="memdesc:VectorWithOffset_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines the <a class="el" href="classstir_1_1VectorWithOffset.html" title="A templated class for vectors, but with indices starting not from 0. ">stir::VectorWithOffset</a> class <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:VectorWithOffset_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="VectorWithOffset_8inl.html">VectorWithOffset.inl</a></td></tr>
<tr class="memdesc:VectorWithOffset_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline implementations of <a class="el" href="classstir_1_1VectorWithOffset.html" title="A templated class for vectors, but with indices starting not from 0. ">stir::VectorWithOffset</a> <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:test__Array_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="test__Array_8cxx.html">test_Array.cxx</a></td></tr>
<tr class="memdesc:test__Array_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests for the <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">stir::Array</a> class <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1Array.html">stir::Array&lt; num_dimensions, elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines multi-dimensional (numeric) arrays.  <a href="classstir_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1ArrayFilter1DUsingConvolution.html">stir::ArrayFilter1DUsingConvolution&lt; elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements convolution of a 1D array with an arbitrary (i.e. potentially non-symmetric) kernel.  <a href="classstir_1_1ArrayFilter1DUsingConvolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1ArrayFilter1DUsingConvolutionSymmetricKernel.html">stir::ArrayFilter1DUsingConvolutionSymmetricKernel&lt; elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements convolution of a 1D array with a symmetric kernel.  <a href="classstir_1_1ArrayFilter1DUsingConvolutionSymmetricKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1ArrayFilterUsingRealDFTWithPadding.html">stir::ArrayFilterUsingRealDFTWithPadding&lt; num_dimensions, elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements convolution of an array of real numbers with an arbitrary (i.e. potentially non-symmetric) kernel using DFTs.  <a href="classstir_1_1ArrayFilterUsingRealDFTWithPadding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1ArrayFunctionObject.html">stir::ArrayFunctionObject&lt; num_dimensions, elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for operations on n-dimensional Arrays.  <a href="classstir_1_1ArrayFunctionObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1ArrayFunctionObject__1ArgumentImplementation.html">stir::ArrayFunctionObject_1ArgumentImplementation&lt; num_dimensions, elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience class for children of <a class="el" href="classstir_1_1ArrayFunctionObject.html" title="A class for operations on n-dimensional Arrays. ">ArrayFunctionObject</a>. It implements the 2 argument operator() in terms of the in-place version.  <a href="classstir_1_1ArrayFunctionObject__1ArgumentImplementation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1ArrayFunctionObject__2ArgumentImplementation.html">stir::ArrayFunctionObject_2ArgumentImplementation&lt; num_dimensions, elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience class for children of <a class="el" href="classstir_1_1ArrayFunctionObject.html" title="A class for operations on n-dimensional Arrays. ">ArrayFunctionObject</a>. It implements the in-place operator() in terms of the 2 argument version.  <a href="classstir_1_1ArrayFunctionObject__2ArgumentImplementation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1BoundaryConditions.html">stir::BoundaryConditions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preliminary class to specify boundary conditions for filters.  <a href="classstir_1_1BoundaryConditions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1FullArrayIterator.html">stir::FullArrayIterator&lt; topleveliterT, restiterT, elemT, _Ref, _Ptr &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class <a class="el" href="classstir_1_1FullArrayIterator.html" title="Class FullArrayIterator implements (forward) iterators that go through all elements of an Array...">FullArrayIterator</a> implements (forward) iterators that go through all elements of an <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a>.  <a href="classstir_1_1FullArrayIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1IndexRange.html">stir::IndexRange&lt; num_dimensions &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines ranges which can be 'irregular'.  <a href="classstir_1_1IndexRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1IndexRange2D.html">stir::IndexRange2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a 'convenience' class for 2D index ranges.  <a href="classstir_1_1IndexRange2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1IndexRange3D.html">stir::IndexRange3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a 'convenience' class for 3D index ranges. Provides an easier constructor for regular ranges.  <a href="classstir_1_1IndexRange3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1IndexRange4D.html">stir::IndexRange4D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience class for 4D index ranges.  <a href="classstir_1_1IndexRange4D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1MaximalArrayFilter3D.html">stir::MaximalArrayFilter3D&lt; elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements erosion on 3D arrays.  <a href="classstir_1_1MaximalArrayFilter3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1MedianArrayFilter3D.html">stir::MedianArrayFilter3D&lt; elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements median filtering on 3D arrays.  <a href="classstir_1_1MedianArrayFilter3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1MinimalArrayFilter3D.html">stir::MinimalArrayFilter3D&lt; elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements erosion on 3D arrays.  <a href="classstir_1_1MinimalArrayFilter3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1NumericVectorWithOffset.html">stir::NumericVectorWithOffset&lt; T, elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">like <a class="el" href="classstir_1_1VectorWithOffset.html" title="A templated class for vectors, but with indices starting not from 0. ">VectorWithOffset</a>, but with changes in various numeric operators  <a href="classstir_1_1NumericVectorWithOffset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1SeparableArrayFunctionObject.html">stir::SeparableArrayFunctionObject&lt; num_dimensions, elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements an <code>n</code> -dimensional <a class="el" href="classstir_1_1ArrayFunctionObject.html" title="A class for operations on n-dimensional Arrays. ">ArrayFunctionObject</a> whose operation is separable.  <a href="classstir_1_1SeparableArrayFunctionObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1SeparableGaussianArrayFilter.html">stir::SeparableGaussianArrayFilter&lt; num_dimensions, elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separable Gaussian filtering in <code>n</code> - dimensions.  <a href="classstir_1_1SeparableGaussianArrayFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1SeparableMetzArrayFilter.html">stir::SeparableMetzArrayFilter&lt; num_dimensions, elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separable Metz filtering in <code>n</code> - dimensions.  <a href="classstir_1_1SeparableMetzArrayFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1detail_1_1VectorWithOffset__iter.html">stir::detail::VectorWithOffset_iter&lt; elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">templated class for the iterators used by <a class="el" href="classstir_1_1VectorWithOffset.html" title="A templated class for vectors, but with indices starting not from 0. ">VectorWithOffset</a>.  <a href="classstir_1_1detail_1_1VectorWithOffset__iter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html">stir::VectorWithOffset&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A templated class for vectors, but with indices starting not from 0.  <a href="classstir_1_1VectorWithOffset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1SeparableGaussianArrayFilterTests.html">stir::SeparableGaussianArrayFilterTests</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests <a class="el" href="classstir_1_1SeparableGaussianArrayFilter.html" title="Separable Gaussian filtering in n - dimensions. ">SeparableGaussianArrayFilter</a> functionalityCurrently only very basic tests on normalisation.  <a href="classstir_1_1SeparableGaussianArrayFilterTests.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1SeparableMetzArrayFilterTests.html">stir::SeparableMetzArrayFilterTests</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests <a class="el" href="classstir_1_1SeparableMetzArrayFilter.html" title="Separable Metz filtering in n - dimensions. ">SeparableMetzArrayFilter</a> functionalityCurrently only very basic tests on normalisation.  <a href="classstir_1_1SeparableMetzArrayFilterTests.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaed499ce03e8ed268bdefbce1c9b12319"><td class="memTemplParams" colspan="2">template&lt;class elemT &gt; </td></tr>
<tr class="memitem:gaed499ce03e8ed268bdefbce1c9b12319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#gaed499ce03e8ed268bdefbce1c9b12319">stir::in_place_log</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;v)</td></tr>
<tr class="memdesc:gaed499ce03e8ed268bdefbce1c9b12319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements by their logarithm, 1D version.  <a href="group__Array.html#gaed499ce03e8ed268bdefbce1c9b12319">More...</a><br /></td></tr>
<tr class="separator:gaed499ce03e8ed268bdefbce1c9b12319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f97351a1c6034e8168f8629a00379c0"><td class="memTemplParams" colspan="2">template&lt;int num_dimensions, class elemT &gt; </td></tr>
<tr class="memitem:ga5f97351a1c6034e8168f8629a00379c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga5f97351a1c6034e8168f8629a00379c0">stir::in_place_log</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp;v)</td></tr>
<tr class="memdesc:ga5f97351a1c6034e8168f8629a00379c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply log to each element of the multi-dimensional array  <a href="group__Array.html#ga5f97351a1c6034e8168f8629a00379c0">More...</a><br /></td></tr>
<tr class="separator:ga5f97351a1c6034e8168f8629a00379c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26d891efa680f66d87ae6f3e5691f8e"><td class="memTemplParams" colspan="2">template&lt;class elemT &gt; </td></tr>
<tr class="memitem:gae26d891efa680f66d87ae6f3e5691f8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#gae26d891efa680f66d87ae6f3e5691f8e">stir::in_place_exp</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;v)</td></tr>
<tr class="memdesc:gae26d891efa680f66d87ae6f3e5691f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements by their exponentiation, 1D version.  <a href="group__Array.html#gae26d891efa680f66d87ae6f3e5691f8e">More...</a><br /></td></tr>
<tr class="separator:gae26d891efa680f66d87ae6f3e5691f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1cab1692b8f296ad359d60efa491c2"><td class="memTemplParams" colspan="2">template&lt;int num_dimensions, class elemT &gt; </td></tr>
<tr class="memitem:ga5b1cab1692b8f296ad359d60efa491c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga5b1cab1692b8f296ad359d60efa491c2">stir::in_place_exp</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp;v)</td></tr>
<tr class="memdesc:ga5b1cab1692b8f296ad359d60efa491c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply exp to each element of the multi-dimensional array  <a href="group__Array.html#ga5b1cab1692b8f296ad359d60efa491c2">More...</a><br /></td></tr>
<tr class="separator:ga5b1cab1692b8f296ad359d60efa491c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bdf4204b0d79ce85a14f8b77bf0045b"><td class="memTemplParams" colspan="2">template&lt;class elemT &gt; </td></tr>
<tr class="memitem:ga0bdf4204b0d79ce85a14f8b77bf0045b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga0bdf4204b0d79ce85a14f8b77bf0045b">stir::in_place_abs</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;v)</td></tr>
<tr class="memdesc:ga0bdf4204b0d79ce85a14f8b77bf0045b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements by their absolute value, 1D version.  <a href="group__Array.html#ga0bdf4204b0d79ce85a14f8b77bf0045b">More...</a><br /></td></tr>
<tr class="separator:ga0bdf4204b0d79ce85a14f8b77bf0045b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5138c38421e8f8e618d678a8796f58"><td class="memTemplParams" colspan="2">template&lt;int num_dimensions, class elemT &gt; </td></tr>
<tr class="memitem:gaea5138c38421e8f8e618d678a8796f58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#gaea5138c38421e8f8e618d678a8796f58">stir::in_place_abs</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp;v)</td></tr>
<tr class="memdesc:gaea5138c38421e8f8e618d678a8796f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">store absolute value of each element of the multi-dimensional array  <a href="group__Array.html#gaea5138c38421e8f8e618d678a8796f58">More...</a><br /></td></tr>
<tr class="separator:gaea5138c38421e8f8e618d678a8796f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76807fa3ee90ce0e5dedb092f3507690"><td class="memTemplParams" colspan="2">template&lt;class T , class FUNCTION &gt; </td></tr>
<tr class="memitem:ga76807fa3ee90ce0e5dedb092f3507690"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga76807fa3ee90ce0e5dedb092f3507690">stir::in_place_apply_function</a> (T &amp;v, FUNCTION f)</td></tr>
<tr class="memdesc:ga76807fa3ee90ce0e5dedb092f3507690"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply any function(object) to each element of the multi-dimensional array  <a href="group__Array.html#ga76807fa3ee90ce0e5dedb092f3507690">More...</a><br /></td></tr>
<tr class="separator:ga76807fa3ee90ce0e5dedb092f3507690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga252955f8443f3f8c60326c17af5e5ad6"><td class="memTemplParams" colspan="2">template&lt;int num_dim, typename elemT , typename FunctionObjectPtr &gt; </td></tr>
<tr class="memitem:ga252955f8443f3f8c60326c17af5e5ad6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga252955f8443f3f8c60326c17af5e5ad6">stir::in_place_apply_array_function_on_1st_index</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;array, FunctionObjectPtr f)</td></tr>
<tr class="memdesc:ga252955f8443f3f8c60326c17af5e5ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function object on all possible 1d arrays extracted by keeping all indices fixed, except the first one.  <a href="group__Array.html#ga252955f8443f3f8c60326c17af5e5ad6">More...</a><br /></td></tr>
<tr class="separator:ga252955f8443f3f8c60326c17af5e5ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88587c349f737be1cf681d5a37e17932"><td class="memTemplParams" colspan="2">template&lt;int num_dim, typename elemT , typename FunctionObjectPtr &gt; </td></tr>
<tr class="memitem:ga88587c349f737be1cf681d5a37e17932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga88587c349f737be1cf681d5a37e17932">stir::apply_array_function_on_1st_index</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;out_array, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;in_array, FunctionObjectPtr f)</td></tr>
<tr class="memdesc:ga88587c349f737be1cf681d5a37e17932"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply any function(object) to each element of the multi-dimensional array, storing results in a different array  <a href="group__Array.html#ga88587c349f737be1cf681d5a37e17932">More...</a><br /></td></tr>
<tr class="separator:ga88587c349f737be1cf681d5a37e17932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e3e07cb7fddb64dd189f1ea1bca40f"><td class="memTemplParams" colspan="2">template&lt;int num_dim, typename elemT , typename FunctionObjectPtrIter &gt; </td></tr>
<tr class="memitem:ga95e3e07cb7fddb64dd189f1ea1bca40f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga95e3e07cb7fddb64dd189f1ea1bca40f">stir::in_place_apply_array_functions_on_each_index</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;array, FunctionObjectPtrIter start, FunctionObjectPtrIter stop)</td></tr>
<tr class="memdesc:ga95e3e07cb7fddb64dd189f1ea1bca40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a sequence of 1d array-function objects on every dimension of the input array.  <a href="group__Array.html#ga95e3e07cb7fddb64dd189f1ea1bca40f">More...</a><br /></td></tr>
<tr class="separator:ga95e3e07cb7fddb64dd189f1ea1bca40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9c7a9df2f7a64dae97b59371d35668"><td class="memTemplParams" colspan="2">template&lt;int num_dim, typename elemT , typename FunctionObjectPtrIter &gt; </td></tr>
<tr class="memitem:gacc9c7a9df2f7a64dae97b59371d35668"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#gacc9c7a9df2f7a64dae97b59371d35668">stir::apply_array_functions_on_each_index</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;out_array, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;in_array, FunctionObjectPtrIter start, FunctionObjectPtrIter stop)</td></tr>
<tr class="memdesc:gacc9c7a9df2f7a64dae97b59371d35668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a sequence of 1d array-function objects on every dimension of the input array, store in output array.  <a href="group__Array.html#gacc9c7a9df2f7a64dae97b59371d35668">More...</a><br /></td></tr>
<tr class="separator:gacc9c7a9df2f7a64dae97b59371d35668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf86ba23c82d49d0fc41609a760dca0a3"><td class="memTemplParams" colspan="2">template&lt;int num_dim, typename elemT &gt; </td></tr>
<tr class="memitem:gaf86ba23c82d49d0fc41609a760dca0a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#gaf86ba23c82d49d0fc41609a760dca0a3">stir::apply_array_functions_on_each_index</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;out_array, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;in_array, ActualFunctionObjectPtrIter start, ActualFunctionObjectPtrIter stop)</td></tr>
<tr class="memdesc:gaf86ba23c82d49d0fc41609a760dca0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a sequence of 1d array-function objects of a specific type on every dimension of the input array, store in output array.  <a href="group__Array.html#gaf86ba23c82d49d0fc41609a760dca0a3">More...</a><br /></td></tr>
<tr class="separator:gaf86ba23c82d49d0fc41609a760dca0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbbc1523fd5f3a5d7a15c0ffa6b54ae8"><td class="memTemplParams" colspan="2"><a id="gadbbc1523fd5f3a5d7a15c0ffa6b54ae8"></a>
template&lt;typename elemT &gt; </td></tr>
<tr class="memitem:gadbbc1523fd5f3a5d7a15c0ffa6b54ae8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#gadbbc1523fd5f3a5d7a15c0ffa6b54ae8">stir::apply_array_functions_on_each_index</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;out_array, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;in_array, ActualFunctionObjectPtrIter start, ActualFunctionObjectPtrIter stop)</td></tr>
<tr class="memdesc:gadbbc1523fd5f3a5d7a15c0ffa6b54ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">1d specialisation of above <br /></td></tr>
<tr class="separator:gadbbc1523fd5f3a5d7a15c0ffa6b54ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80955274e451a9249f63084d6acc847a"><td class="memTemplParams" colspan="2"><a id="ga80955274e451a9249f63084d6acc847a"></a>
template&lt;typename elemT , typename FunctionObjectPtrIter &gt; </td></tr>
<tr class="memitem:ga80955274e451a9249f63084d6acc847a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga80955274e451a9249f63084d6acc847a">stir::apply_array_functions_on_each_index</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;out_array, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;in_array, FunctionObjectPtrIter start, FunctionObjectPtrIter stop)</td></tr>
<tr class="memdesc:ga80955274e451a9249f63084d6acc847a"><td class="mdescLeft">&#160;</td><td class="mdescRight">1d specialisation for general function objects <br /></td></tr>
<tr class="separator:ga80955274e451a9249f63084d6acc847a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga585c22e0a650f60c6263a1f9041629e7"><td class="memTemplParams" colspan="2">template&lt;class elemT &gt; </td></tr>
<tr class="memitem:ga585c22e0a650f60c6263a1f9041629e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga585c22e0a650f60c6263a1f9041629e7">stir::assign_to_subregion</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, elemT &gt; &amp;input_array, const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, int &gt; &amp;mask_location, const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, int &gt; &amp;half_size, const elemT &amp;value)</td></tr>
<tr class="memdesc:ga585c22e0a650f60c6263a1f9041629e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign a value to a sub-region of an array  <a href="group__Array.html#ga585c22e0a650f60c6263a1f9041629e7">More...</a><br /></td></tr>
<tr class="separator:ga585c22e0a650f60c6263a1f9041629e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe965212ea5976e7250826a720d65ccc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gabe965212ea5976e7250826a720d65ccc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#gabe965212ea5976e7250826a720d65ccc">stir::find_unweighted_centre_of_gravity_1d</a> (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&lt; T &gt; &amp;row)</td></tr>
<tr class="memdesc:gabe965212ea5976e7250826a720d65ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute centre of gravity of a vector but without dividing by its sum.  <a href="group__Array.html#gabe965212ea5976e7250826a720d65ccc">More...</a><br /></td></tr>
<tr class="separator:gabe965212ea5976e7250826a720d65ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12ab323ce3931767afce1f04eee1d862"><td class="memTemplParams" colspan="2">template&lt;int num_dimensions, class T &gt; </td></tr>
<tr class="memitem:ga12ab323ce3931767afce1f04eee1d862"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; num_dimensions, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga12ab323ce3931767afce1f04eee1d862">stir::find_unweighted_centre_of_gravity</a> (const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T &gt; &amp;)</td></tr>
<tr class="memdesc:ga12ab323ce3931767afce1f04eee1d862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute centre of gravity of an <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a> but without dividing by its sum.  <a href="group__Array.html#ga12ab323ce3931767afce1f04eee1d862">More...</a><br /></td></tr>
<tr class="separator:ga12ab323ce3931767afce1f04eee1d862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf12e02ec82783789364617c30650bc9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacf12e02ec82783789364617c30650bc9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#gacf12e02ec82783789364617c30650bc9">stir::find_unweighted_centre_of_gravity</a> (const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, T &gt; &amp;)</td></tr>
<tr class="memdesc:gacf12e02ec82783789364617c30650bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute centre of gravity of a 1D <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a> but without dividing by its sum.  <a href="group__Array.html#gacf12e02ec82783789364617c30650bc9">More...</a><br /></td></tr>
<tr class="separator:gacf12e02ec82783789364617c30650bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e0944415644cae8cbbd0b9f299f25d2"><td class="memTemplParams" colspan="2">template&lt;int num_dimensions, class T &gt; </td></tr>
<tr class="memitem:ga2e0944415644cae8cbbd0b9f299f25d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; num_dimensions, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga2e0944415644cae8cbbd0b9f299f25d2">stir::find_centre_of_gravity</a> (const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T &gt; &amp;)</td></tr>
<tr class="memdesc:ga2e0944415644cae8cbbd0b9f299f25d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute centre of gravity of an <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a>.  <a href="group__Array.html#ga2e0944415644cae8cbbd0b9f299f25d2">More...</a><br /></td></tr>
<tr class="separator:ga2e0944415644cae8cbbd0b9f299f25d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f741be6636950138b5fe1803b083b7c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga1f741be6636950138b5fe1803b083b7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga1f741be6636950138b5fe1803b083b7c">stir::find_centre_of_gravity_in_mm_per_plane</a> (<a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&lt; <a class="el" href="classstir_1_1CartesianCoordinate3D.html">CartesianCoordinate3D</a>&lt; float &gt; &gt; &amp;allCoG, <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&lt; T &gt; &amp;weights, const <a class="el" href="classstir_1_1VoxelsOnCartesianGrid.html">VoxelsOnCartesianGrid</a>&lt; T &gt; &amp;image)</td></tr>
<tr class="memdesc:ga1f741be6636950138b5fe1803b083b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes centre of gravity for each plane.  <a href="group__Array.html#ga1f741be6636950138b5fe1803b083b7c">More...</a><br /></td></tr>
<tr class="separator:ga1f741be6636950138b5fe1803b083b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11c05dcba3ccd6ef648d4a217a009d6f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga11c05dcba3ccd6ef648d4a217a009d6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1CartesianCoordinate3D.html">CartesianCoordinate3D</a>&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga11c05dcba3ccd6ef648d4a217a009d6f">stir::find_centre_of_gravity_in_mm</a> (const <a class="el" href="classstir_1_1VoxelsOnCartesianGrid.html">VoxelsOnCartesianGrid</a>&lt; T &gt; &amp;image)</td></tr>
<tr class="memdesc:ga11c05dcba3ccd6ef648d4a217a009d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes centre of gravity of an image.  <a href="group__Array.html#ga11c05dcba3ccd6ef648d4a217a009d6f">More...</a><br /></td></tr>
<tr class="separator:ga11c05dcba3ccd6ef648d4a217a009d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5bb010e50caacfa64f8568fbef591cd"><td class="memTemplParams" colspan="2">template&lt;int num_dimensions, class T1 , class T2 , class scaleT &gt; </td></tr>
<tr class="memitem:gaa5bb010e50caacfa64f8568fbef591cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#gaa5bb010e50caacfa64f8568fbef591cd">stir::find_scale_factor</a> (scaleT &amp;scale_factor, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T1 &gt; &amp;data_in, const <a class="el" href="classstir_1_1NumericInfo.html">NumericInfo</a>&lt; T2 &gt; info_for_out_type)</td></tr>
<tr class="memdesc:gaa5bb010e50caacfa64f8568fbef591cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that finds a scale factor to use when converting data to a new type.  <a href="group__Array.html#gaa5bb010e50caacfa64f8568fbef591cd">More...</a><br /></td></tr>
<tr class="separator:gaa5bb010e50caacfa64f8568fbef591cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa732f225afedbdd7e23c51ac7a879769"><td class="memTemplParams" colspan="2">template&lt;int num_dimensions, class T1 , class T2 , class scaleT &gt; </td></tr>
<tr class="memitem:gaa732f225afedbdd7e23c51ac7a879769"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#gaa732f225afedbdd7e23c51ac7a879769">stir::convert_array</a> (scaleT &amp;scale_factor, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T1 &gt; &amp;data_in, const <a class="el" href="classstir_1_1NumericInfo.html">NumericInfo</a>&lt; T2 &gt; info2)</td></tr>
<tr class="memdesc:gaa732f225afedbdd7e23c51ac7a879769"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that returns a new <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a> (of the same dimension) with elements of type <code>T2</code>.  <a href="group__Array.html#gaa732f225afedbdd7e23c51ac7a879769">More...</a><br /></td></tr>
<tr class="separator:gaa732f225afedbdd7e23c51ac7a879769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8508ec2aa627b002cfcd8d30e2824bf"><td class="memTemplParams" colspan="2">template&lt;int num_dimensions, class T1 , class T2 , class scaleT &gt; </td></tr>
<tr class="memitem:gaf8508ec2aa627b002cfcd8d30e2824bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#gaf8508ec2aa627b002cfcd8d30e2824bf">stir::convert_array</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T2 &gt; &amp;data_out, scaleT &amp;scale_factor, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T1 &gt; &amp;data_in)</td></tr>
<tr class="memdesc:gaf8508ec2aa627b002cfcd8d30e2824bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the <code>data_in</code> <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a> to <code>data_out</code> (with elements of different types) such that <code>data_in</code> == <code>data_out</code> * <code>scale_factor</code>.  <a href="group__Array.html#gaf8508ec2aa627b002cfcd8d30e2824bf">More...</a><br /></td></tr>
<tr class="separator:gaf8508ec2aa627b002cfcd8d30e2824bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82c5a21cfed57f62935092125be4f1b6"><td class="memTemplParams" colspan="2">template&lt;class InputIteratorT , class T2 , class scaleT &gt; </td></tr>
<tr class="memitem:ga82c5a21cfed57f62935092125be4f1b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga82c5a21cfed57f62935092125be4f1b6">stir::find_scale_factor</a> (scaleT &amp;scale_factor, const InputIteratorT &amp;begin, const InputIteratorT &amp;end, const <a class="el" href="classstir_1_1NumericInfo.html">NumericInfo</a>&lt; T2 &gt; info_for_out_type)</td></tr>
<tr class="memdesc:ga82c5a21cfed57f62935092125be4f1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that finds a scale factor to use when converting data to a new type.  <a href="group__Array.html#ga82c5a21cfed57f62935092125be4f1b6">More...</a><br /></td></tr>
<tr class="separator:ga82c5a21cfed57f62935092125be4f1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56484b2412114338773aa3eab2fb1f6b"><td class="memTemplParams" colspan="2">template&lt;class OutputIteratorT , class InputIteratorT , class scaleT &gt; </td></tr>
<tr class="memitem:ga56484b2412114338773aa3eab2fb1f6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Array.html#ga56484b2412114338773aa3eab2fb1f6b">stir::convert_range</a> (const OutputIteratorT &amp;out_begin, scaleT &amp;scale_factor, const InputIteratorT &amp;in_begin, const InputIteratorT &amp;in_end)</td></tr>
<tr class="memdesc:ga56484b2412114338773aa3eab2fb1f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the data in the input range to the output range (with elements of different types) such that <code>data_in</code> == <code>data_out</code> * <code>scale_factor</code>.  <a href="group__Array.html#ga56484b2412114338773aa3eab2fb1f6b">More...</a><br /></td></tr>
<tr class="separator:ga56484b2412114338773aa3eab2fb1f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaed499ce03e8ed268bdefbce1c9b12319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed499ce03e8ed268bdefbce1c9b12319">&#9670;&nbsp;</a></span>in_place_log() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class elemT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp; stir::in_place_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace elements by their logarithm, 1D version. </p>

<p class="reference">Referenced by <a class="el" href="group__Array.html#ga5f97351a1c6034e8168f8629a00379c0">stir::in_place_log()</a>, and <a class="el" href="classstir_1_1ArrayTests.html#adb5a8ae3de33bae386fb37c578f6e698">stir::ArrayTests::run_tests()</a>.</p>

</div>
</div>
<a id="ga5f97351a1c6034e8168f8629a00379c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f97351a1c6034e8168f8629a00379c0">&#9670;&nbsp;</a></span>in_place_log() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dimensions, class elemT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp; stir::in_place_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply log to each element of the multi-dimensional array </p>

<p class="reference">References <a class="el" href="classstir_1_1VectorWithOffset.html#a23a3bcc84639216e608406803d98f14e">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::get_max_index()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::get_min_index()</a>, and <a class="el" href="group__Array.html#gaed499ce03e8ed268bdefbce1c9b12319">stir::in_place_log()</a>.</p>

</div>
</div>
<a id="gae26d891efa680f66d87ae6f3e5691f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26d891efa680f66d87ae6f3e5691f8e">&#9670;&nbsp;</a></span>in_place_exp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class elemT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp; stir::in_place_exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace elements by their exponentiation, 1D version. </p>

<p class="reference">References <a class="el" href="classstir_1_1VectorWithOffset.html#a23a3bcc84639216e608406803d98f14e">stir::VectorWithOffset&lt; T &gt;::get_max_index()</a>, and <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">stir::VectorWithOffset&lt; T &gt;::get_min_index()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1BinNormalisationFromAttenuationImage.html#a2b4a4511bcf57c9d71b68be0a8eb1aff">stir::BinNormalisationFromAttenuationImage::apply()</a>, <a class="el" href="group__Array.html#ga5b1cab1692b8f296ad359d60efa491c2">stir::in_place_exp()</a>, <a class="el" href="classstir_1_1ArrayTests.html#adb5a8ae3de33bae386fb37c578f6e698">stir::ArrayTests::run_tests()</a>, and <a class="el" href="classstir_1_1BinNormalisationFromAttenuationImage.html#af37ae22c039dac3435f7c8e3548b2d42">stir::BinNormalisationFromAttenuationImage::undo()</a>.</p>

</div>
</div>
<a id="ga5b1cab1692b8f296ad359d60efa491c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b1cab1692b8f296ad359d60efa491c2">&#9670;&nbsp;</a></span>in_place_exp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dimensions, class elemT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp; stir::in_place_exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply exp to each element of the multi-dimensional array </p>

<p class="reference">References <a class="el" href="classstir_1_1VectorWithOffset.html#a23a3bcc84639216e608406803d98f14e">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::get_max_index()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::get_min_index()</a>, and <a class="el" href="group__Array.html#gae26d891efa680f66d87ae6f3e5691f8e">stir::in_place_exp()</a>.</p>

</div>
</div>
<a id="ga0bdf4204b0d79ce85a14f8b77bf0045b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bdf4204b0d79ce85a14f8b77bf0045b">&#9670;&nbsp;</a></span>in_place_abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class elemT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp; stir::in_place_abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace elements by their absolute value, 1D version. </p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation does not work with complex numbers. </dd></dl>

<p class="reference">References <a class="el" href="classstir_1_1VectorWithOffset.html#a23a3bcc84639216e608406803d98f14e">stir::VectorWithOffset&lt; T &gt;::get_max_index()</a>, and <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">stir::VectorWithOffset&lt; T &gt;::get_min_index()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1ReconstructionTests.html#a9b0fc408499588803887349bddbea9cb">stir::ReconstructionTests&lt; target_type &gt;::compare()</a>, and <a class="el" href="group__Array.html#gaea5138c38421e8f8e618d678a8796f58">stir::in_place_abs()</a>.</p>

</div>
</div>
<a id="gaea5138c38421e8f8e618d678a8796f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea5138c38421e8f8e618d678a8796f58">&#9670;&nbsp;</a></span>in_place_abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dimensions, class elemT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp; stir::in_place_abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>store absolute value of each element of the multi-dimensional array </p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation does not work with complex numbers. </dd></dl>

<p class="reference">References <a class="el" href="classstir_1_1VectorWithOffset.html#a23a3bcc84639216e608406803d98f14e">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::get_max_index()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::get_min_index()</a>, and <a class="el" href="group__Array.html#ga0bdf4204b0d79ce85a14f8b77bf0045b">stir::in_place_abs()</a>.</p>

</div>
</div>
<a id="ga76807fa3ee90ce0e5dedb092f3507690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76807fa3ee90ce0e5dedb092f3507690">&#9670;&nbsp;</a></span>in_place_apply_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class FUNCTION &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; stir::in_place_apply_function </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTION&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply any function(object) to each element of the multi-dimensional array </p>
<p>Each element will be replaced by </p><div class="fragment"><div class="line">elem = f(elem);</div></div><!-- fragment --><p>Requires that type <code>T</code> has <code>begin_all()</code> and <code>end_all()</code> functions. </p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1ScatterEstimation.html#a20adf5073f27f5c112203fa1aef4cfc8">stir::ScatterEstimation::process_data()</a>, and <a class="el" href="classstir_1_1ArrayTests.html#adb5a8ae3de33bae386fb37c578f6e698">stir::ArrayTests::run_tests()</a>.</p>

</div>
</div>
<a id="ga252955f8443f3f8c60326c17af5e5ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga252955f8443f3f8c60326c17af5e5ad6">&#9670;&nbsp;</a></span>in_place_apply_array_function_on_1st_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dim, typename elemT , typename FunctionObjectPtr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::in_place_apply_array_function_on_1st_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObjectPtr&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function object on all possible 1d arrays extracted by keeping all indices fixed, except the first one. </p>
<p>For the 2d case, this amounts to applying a function on all columns of the matrix.</p>
<p>For a 3d case, the following pseudo-code illustrates what happens. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> all i2,i3</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> all i</div><div class="line">  {</div><div class="line">    a[i] = array[i][i2][i3];</div><div class="line">  }</div><div class="line">  (*f)(a);</div><div class="line">  <span class="keywordflow">for</span> all i</div><div class="line">  {</div><div class="line">    array[i][i2][i3] = a[i];</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The array has to be regular. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd><p class="startdd">Add a 1D specialisation as the current implementation would be really inefficient in this case. </p>
<p class="enddd">Add a specialisation such that this function would handle function objects and (smart) pointers to function objects. At the moment, it's only the latter. </p>
</dd></dl>

<p class="reference">References <a class="el" href="classstir_1_1VectorWithOffset.html#a23a3bcc84639216e608406803d98f14e">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::get_max_index()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::get_min_index()</a>, and <a class="el" href="classstir_1_1Array.html#a0c55638d8e5ddd950370b07e3f6eb7f9">stir::Array&lt; num_dimensions, elemT &gt;::is_regular()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__Array.html#ga95e3e07cb7fddb64dd189f1ea1bca40f">stir::in_place_apply_array_functions_on_each_index()</a>.</p>

</div>
</div>
<a id="ga88587c349f737be1cf681d5a37e17932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88587c349f737be1cf681d5a37e17932">&#9670;&nbsp;</a></span>apply_array_function_on_1st_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dim, typename elemT , typename FunctionObjectPtr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::apply_array_function_on_1st_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObjectPtr&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply any function(object) to each element of the multi-dimensional array, storing results in a different array </p>
<dl class="section warning"><dt>Warning</dt><dd>Both in_array and out_array have to have regular ranges. Moreover, they have to have matching ranges except for the outermost level. The (binary) function is applied as <div class="fragment"><div class="line">(*f)(out_array1d, in_array1d)</div></div><!-- fragment --> <em>f</em> should not modify the index range of the output argument. </dd></dl>

<p class="reference">References <a class="el" href="classstir_1_1VectorWithOffset.html#a23a3bcc84639216e608406803d98f14e">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::get_max_index()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::get_min_index()</a>, and <a class="el" href="classstir_1_1Array.html#a0c55638d8e5ddd950370b07e3f6eb7f9">stir::Array&lt; num_dimensions, elemT &gt;::is_regular()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__Array.html#gacc9c7a9df2f7a64dae97b59371d35668">stir::apply_array_functions_on_each_index()</a>.</p>

</div>
</div>
<a id="ga95e3e07cb7fddb64dd189f1ea1bca40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95e3e07cb7fddb64dd189f1ea1bca40f">&#9670;&nbsp;</a></span>in_place_apply_array_functions_on_each_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dim, typename elemT , typename FunctionObjectPtrIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::in_place_apply_array_functions_on_each_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObjectPtrIter&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObjectPtrIter&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a sequence of 1d array-function objects on every dimension of the input array. </p>
<p>The sequence of function object pointers is specified by iterators. There must be num_dim function objects in the sequence, i.e. stop-start==num_dim.</p>
<p>The n-th function object (**(start+n)) is applied on the n-th index of the array. So, (*start) is applied using in_place_apply_array_function_on_1st_index(array, *start). Similarly, (*(start+1) is applied using in_place_apply_array_function_on_1st_index(array[i], *(start+1)) for every i. And so on. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>Add a specialisation such that this function would handle function objects and (smart) pointers to function objects. At the moment, it's only the latter. </dd></dl>

<p class="reference">References <a class="el" href="classstir_1_1VectorWithOffset.html#a147a665c5ab7818c5197fac452bcff9b">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::begin()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#ab5ea6073b3daf75f23f1b545d0b6593f">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::end()</a>, and <a class="el" href="group__Array.html#ga252955f8443f3f8c60326c17af5e5ad6">stir::in_place_apply_array_function_on_1st_index()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1SeparableArrayFunctionObject.html#aaf72b6ab784babfdaa614ef7e5902bef">stir::SeparableArrayFunctionObject&lt; num_dimensions, elemT &gt;::SeparableArrayFunctionObject()</a>.</p>

</div>
</div>
<a id="gacc9c7a9df2f7a64dae97b59371d35668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc9c7a9df2f7a64dae97b59371d35668">&#9670;&nbsp;</a></span>apply_array_functions_on_each_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dim, typename elemT , typename FunctionObjectPtrIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::apply_array_functions_on_each_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObjectPtrIter&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObjectPtrIter&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a sequence of 1d array-function objects on every dimension of the input array, store in output array. </p>
<p>The sequence of function object pointers is specified by iterators. There must be num_dim function objects in the sequence, i.e. stop-start==num_dim.</p>
<p>The n-th function object (**(start+n)) is applied on the n-th indices of the arrays. So, (*start) is applied using </p><div class="fragment"><div class="line"><a class="code" href="group__Array.html#ga88587c349f737be1cf681d5a37e17932">apply_array_function_on_1st_index</a>(out_array, in_array, *start).</div></div><!-- fragment --><p> and so on. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Add a specialisation such that this function would handle iterators of function objects and (smart) pointers to function objects. At the moment, it's only the latter. </dd></dl>

<p class="reference">References <a class="el" href="group__Array.html#ga88587c349f737be1cf681d5a37e17932">stir::apply_array_function_on_1st_index()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#a23a3bcc84639216e608406803d98f14e">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::get_max_index()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::get_min_index()</a>, <a class="el" href="classstir_1_1Array.html#a75983a3289d6190a0848a3a240938cfd">stir::Array&lt; num_dimensions, elemT &gt;::get_regular_range()</a>, and <a class="el" href="classstir_1_1Array.html#a0c55638d8e5ddd950370b07e3f6eb7f9">stir::Array&lt; num_dimensions, elemT &gt;::is_regular()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1SeparableArrayFunctionObject.html#aaf72b6ab784babfdaa614ef7e5902bef">stir::SeparableArrayFunctionObject&lt; num_dimensions, elemT &gt;::SeparableArrayFunctionObject()</a>.</p>

</div>
</div>
<a id="gaf86ba23c82d49d0fc41609a760dca0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf86ba23c82d49d0fc41609a760dca0a3">&#9670;&nbsp;</a></span>apply_array_functions_on_each_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dim, typename elemT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::apply_array_functions_on_each_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dim, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ActualFunctionObjectPtrIter&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ActualFunctionObjectPtrIter&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a sequence of 1d array-function objects of a specific type on every dimension of the input array, store in output array. </p>
<p>This function uses optimisations possible because <a class="el" href="classstir_1_1ArrayFunctionObject.html" title="A class for operations on n-dimensional Arrays. ">ArrayFunctionObject</a> gives information on sizes etc. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>Modify such that this function would handle function objects and (smart) pointers to <a class="el" href="classstir_1_1ArrayFunctionObject.html" title="A class for operations on n-dimensional Arrays. ">ArrayFunctionObject</a> objects. At the moment, it's only the latter. </dd></dl>

</div>
</div>
<a id="ga585c22e0a650f60c6263a1f9041629e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga585c22e0a650f60c6263a1f9041629e7">&#9670;&nbsp;</a></span>assign_to_subregion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class elemT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::assign_to_subregion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>half_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const elemT &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign a value to a sub-region of an array </p>
<p>sets all values for indices between <em>mask_location</em> - <em>half_size</em> and <em>mask_location</em> + <em>half_size</em> to <em>value</em>, taking care of staying inside the index-range of the array. </p>

<p class="reference">References <a class="el" href="classstir_1_1VectorWithOffset.html#a23a3bcc84639216e608406803d98f14e">stir::VectorWithOffset&lt; T &gt;::get_max_index()</a>, and <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">stir::VectorWithOffset&lt; T &gt;::get_min_index()</a>.</p>

</div>
</div>
<a id="gabe965212ea5976e7250826a720d65ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe965212ea5976e7250826a720d65ccc">&#9670;&nbsp;</a></span>find_unweighted_centre_of_gravity_1d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stir::find_unweighted_centre_of_gravity_1d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute centre of gravity of a vector but without dividing by its sum. </p>
<p>The unweighted centre of gravity is computed as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_k = \sum_{i} i A_{i} \]" src="form_3.png"/>
</p>
 
<p class="reference">Referenced by <a class="el" href="group__Array.html#gacf12e02ec82783789364617c30650bc9">stir::find_unweighted_centre_of_gravity()</a>.</p>

</div>
</div>
<a id="ga12ab323ce3931767afce1f04eee1d862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12ab323ce3931767afce1f04eee1d862">&#9670;&nbsp;</a></span>find_unweighted_centre_of_gravity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dimensions, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; num_dimensions, T &gt; stir::find_unweighted_centre_of_gravity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute centre of gravity of an <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a> but without dividing by its sum. </p>
<p>Each coordinate of the unweighted centre of gravity is computed as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_k = \sum_{i_1...i_n} i_k A_{i_1...i_n} \]" src="form_4.png"/>
</p>
 
<p class="reference">References <a class="el" href="classstir_1_1VectorWithOffset.html#aec5c52350ad01a1b87d03c85a0eb0060">stir::VectorWithOffset&lt; Array&lt; num_dimensions-1, elemT &gt; &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__Array.html#ga2e0944415644cae8cbbd0b9f299f25d2">stir::find_centre_of_gravity()</a>.</p>

</div>
</div>
<a id="gacf12e02ec82783789364617c30650bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf12e02ec82783789364617c30650bc9">&#9670;&nbsp;</a></span>find_unweighted_centre_of_gravity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T stir::find_unweighted_centre_of_gravity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute centre of gravity of a 1D <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a> but without dividing by its sum. </p>
<p>Conceptually the same as the n-dimensional version, but returns a <code>T</code>, not a <a class="el" href="classstir_1_1BasicCoordinate.html" title="class BasicCoordinate&lt;int num_dimensions, typename coordT&gt; defines num_dimensions -dimensional coordi...">BasicCoordinate</a>&lt;1,T&gt;. </p>

<p class="reference">References <a class="el" href="group__Array.html#gabe965212ea5976e7250826a720d65ccc">stir::find_unweighted_centre_of_gravity_1d()</a>.</p>

</div>
</div>
<a id="ga2e0944415644cae8cbbd0b9f299f25d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e0944415644cae8cbbd0b9f299f25d2">&#9670;&nbsp;</a></span>find_centre_of_gravity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dimensions, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; num_dimensions, T &gt; stir::find_centre_of_gravity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute centre of gravity of an <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a>. </p>
<p>Calls find_unweighted_centre_of_gravity and divides the result with the sum of all the elements in the array.</p>
<dl class="section warning"><dt>Warning</dt><dd>When the sum is 0, <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f" title="Print error with format string a la printf and throw exception. ">error()</a> is called. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo:</a></b></dt><dd>better error handling </dd></dl>

<p class="reference">References <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f">stir::error()</a>, <a class="el" href="group__Array.html#ga12ab323ce3931767afce1f04eee1d862">stir::find_unweighted_centre_of_gravity()</a>, <a class="el" href="group__buildblock.html#gaae6c0f5d36d3219fb266eca61f85c187">stir::sum()</a>, and <a class="el" href="classstir_1_1Array.html#ab264a137a11b26dd484292408ee70044">stir::Array&lt; num_dimensions, elemT &gt;::sum()</a>.</p>

</div>
</div>
<a id="ga1f741be6636950138b5fe1803b083b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f741be6636950138b5fe1803b083b7c">&#9670;&nbsp;</a></span>find_centre_of_gravity_in_mm_per_plane()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stir::find_centre_of_gravity_in_mm_per_plane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&lt; <a class="el" href="classstir_1_1CartesianCoordinate3D.html">CartesianCoordinate3D</a>&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>allCoG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1VoxelsOnCartesianGrid.html">VoxelsOnCartesianGrid</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes centre of gravity for each plane. </p>
<p>The result is in mm in STIR physical coordinates, i.e. taking the origin into account.</p>
<p>The result can be used to find the central line of a (uniform) object, for instance a cylinder. The output of this function can by used by <a class="el" href="group__buildblock.html#ga6791494ac912a0c7675f5768b5dd99fd" title="Implements standard linear regression on VectorWithOffset data. ">linear_regression()</a>.</p>
<p>The weight is currently simply the sum of the voxel values in that plane, thresholded to be at least 0. If the weight is 0, the x,y coordinates are simply set to 0. </p>

</div>
</div>
<a id="ga11c05dcba3ccd6ef648d4a217a009d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11c05dcba3ccd6ef648d4a217a009d6f">&#9670;&nbsp;</a></span>find_centre_of_gravity_in_mm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1CartesianCoordinate3D.html">CartesianCoordinate3D</a>&lt; float &gt; stir::find_centre_of_gravity_in_mm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1VoxelsOnCartesianGrid.html">VoxelsOnCartesianGrid</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes centre of gravity of an image. </p>
<p>The result is in mm in STIR physical coordinates, i.e. taking the origin into account. </p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1MatchTrackerAndScanner.html#abe1dd1c5151d5af0c48853a9dd91a9cd">stir::MatchTrackerAndScanner::run()</a>.</p>

</div>
</div>
<a id="gaa5bb010e50caacfa64f8568fbef591cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5bb010e50caacfa64f8568fbef591cd">&#9670;&nbsp;</a></span>find_scale_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dimensions, class T1 , class T2 , class scaleT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::find_scale_factor </td>
          <td>(</td>
          <td class="paramtype">scaleT &amp;&#160;</td>
          <td class="paramname"><em>scale_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1NumericInfo.html">NumericInfo</a>&lt; T2 &gt;&#160;</td>
          <td class="paramname"><em>info_for_out_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A function that finds a scale factor to use when converting data to a new type. </p>
<p>The scale factor is such that (<em>data_in</em> / <em>scale_factor</em>) will fit in the maximum range for the output type.</p>
<p>When input and output types are identical, <em>scale_factor</em> is set to 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale_factor</td><td>a reference to a (float or double) variable which will be set to the scale factor such that (ignoring types) <div class="fragment"><div class="line">data_in == data_out * scale_factor </div></div><!-- fragment --> If scale_factor is initialised to 0, the maximum range of <em>T2</em> is used. If scale_factor != 0, find_scale_factor attempts to use the given scale_factor, unless the T2 range doesn't fit. In that case, the same scale_factor is used as in the 0 case.</td></tr>
    <tr><td class="paramname">data_in</td><td>some <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a> object, elements are of some numeric type <em>T1</em> </td></tr>
    <tr><td class="paramname">info_for_out_type</td><td><em>T2</em> is the desired output type</td></tr>
  </table>
  </dd>
</dl>
<p>Note that there is an effective threshold at 0 currently (i.e. negative numbers are ignored) when <em>T2</em> is an unsigned type.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Array.html#gaa732f225afedbdd7e23c51ac7a879769" title="A function that returns a new Array (of the same dimension) with elements of type T2...">convert_array</a> </dd></dl>

<p class="reference">References <a class="el" href="classstir_1_1Array.html#a887028a2daad51cd19237dc272651cdc">stir::Array&lt; num_dimensions, elemT &gt;::begin_all()</a>, and <a class="el" href="classstir_1_1Array.html#a3674afccb86b90f13ee648c3e6935475">stir::Array&lt; num_dimensions, elemT &gt;::end_all()</a>.</p>

</div>
</div>
<a id="gaa732f225afedbdd7e23c51ac7a879769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa732f225afedbdd7e23c51ac7a879769">&#9670;&nbsp;</a></span>convert_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dimensions, class T1 , class T2 , class scaleT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T2 &gt; stir::convert_array </td>
          <td>(</td>
          <td class="paramtype">scaleT &amp;&#160;</td>
          <td class="paramname"><em>scale_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1NumericInfo.html">NumericInfo</a>&lt; T2 &gt;&#160;</td>
          <td class="paramname"><em>info2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A function that returns a new <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a> (of the same dimension) with elements of type <code>T2</code>. </p>
<p>Result is (approximately) <em>data_in</em> / <em>scale_factor</em>.</p>
<dl class="section user"><dt>example </dt><dd><div class="fragment"><div class="line">Array&lt;2,float&gt; data_out = <a class="code" href="group__Array.html#gaa732f225afedbdd7e23c51ac7a879769">convert_array</a>(scale_factor, data_in, NumericInfo&lt;float&gt;())</div></div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale_factor</td><td>a reference to a (float or double) variable which will be set to the scale factor such that (ignoring types) <div class="fragment"><div class="line">data_in == data_out * scale_factor </div></div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Array.html#gaa5bb010e50caacfa64f8568fbef591cd" title="A function that finds a scale factor to use when converting data to a new type. ">find_scale_factor</a> for more <a class="el" href="group__buildblock.html#ga58339978ae5e7a02db3ba4d82bff5ab6" title="Use this function for writing informational messages. ">info</a> on the determination of <em>scale_factor</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_in</td><td>some <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a> object, elements are of some numeric type <em>T1</em> </td></tr>
    <tr><td class="paramname">info2</td><td><em>T2</em> is the desired output type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data_out : an <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a> object whose elements are of numeric type T2.</dd></dl>
<p>When the output type is integer, rounding is used.</p>
<p>Note that there is an effective threshold at 0 currently (i.e. negative numbers are cut out) when T2 is an unsigned type. </p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1convert__array__Tests.html#ad055bda1fda6f68cdccb15e9c32caa56">stir::convert_array_Tests::run_tests()</a>.</p>

</div>
</div>
<a id="gaf8508ec2aa627b002cfcd8d30e2824bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8508ec2aa627b002cfcd8d30e2824bf">&#9670;&nbsp;</a></span>convert_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dimensions, class T1 , class T2 , class scaleT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::convert_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scaleT &amp;&#160;</td>
          <td class="paramname"><em>scale_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the <code>data_in</code> <a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a> to <code>data_out</code> (with elements of different types) such that <code>data_in</code> == <code>data_out</code> * <code>scale_factor</code>. </p>
<dl class="section user"><dt>example </dt><dd><div class="fragment"><div class="line"><a class="code" href="group__Array.html#gaa732f225afedbdd7e23c51ac7a879769">convert_array</a>(data_out, scale_factor, data_in);</div></div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd>convert_array(scale_factor, data_in, info2) for more <a class="el" href="group__buildblock.html#ga58339978ae5e7a02db3ba4d82bff5ab6" title="Use this function for writing informational messages. ">info</a> </dd></dl>

<p class="reference">References <a class="el" href="classstir_1_1Array.html#a887028a2daad51cd19237dc272651cdc">stir::Array&lt; num_dimensions, elemT &gt;::begin_all()</a>, <a class="el" href="group__Array.html#ga56484b2412114338773aa3eab2fb1f6b">stir::convert_range()</a>, and <a class="el" href="classstir_1_1Array.html#a3674afccb86b90f13ee648c3e6935475">stir::Array&lt; num_dimensions, elemT &gt;::end_all()</a>.</p>

</div>
</div>
<a id="ga82c5a21cfed57f62935092125be4f1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82c5a21cfed57f62935092125be4f1b6">&#9670;&nbsp;</a></span>find_scale_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIteratorT , class T2 , class scaleT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::find_scale_factor </td>
          <td>(</td>
          <td class="paramtype">scaleT &amp;&#160;</td>
          <td class="paramname"><em>scale_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIteratorT &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIteratorT &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1NumericInfo.html">NumericInfo</a>&lt; T2 &gt;&#160;</td>
          <td class="paramname"><em>info_for_out_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A function that finds a scale factor to use when converting data to a new type. </p>
<p>This function works with input data given as an iterator range. </p><dl class="section see"><dt>See also</dt><dd>find_scale_factor(scale_factor,data_in,info_for_out_type) </dd></dl>

</div>
</div>
<a id="ga56484b2412114338773aa3eab2fb1f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56484b2412114338773aa3eab2fb1f6b">&#9670;&nbsp;</a></span>convert_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIteratorT , class InputIteratorT , class scaleT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::convert_range </td>
          <td>(</td>
          <td class="paramtype">const OutputIteratorT &amp;&#160;</td>
          <td class="paramname"><em>out_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scaleT &amp;&#160;</td>
          <td class="paramname"><em>scale_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIteratorT &amp;&#160;</td>
          <td class="paramname"><em>in_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIteratorT &amp;&#160;</td>
          <td class="paramname"><em>in_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the data in the input range to the output range (with elements of different types) such that <code>data_in</code> == <code>data_out</code> * <code>scale_factor</code>. </p>
<p>Note order of arguments. Output-range occurs first (as standard in STIR). </p><dl class="section user"><dt>example </dt><dd><div class="fragment"><div class="line"><a class="code" href="group__Array.html#ga56484b2412114338773aa3eab2fb1f6b">convert_range</a>(data_out.begin_all(), scale_factor, </div><div class="line">              data_in.begin_all(), data_in.end_all());</div></div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd>convert_array(scale_factor, data_in, info2) for more <a class="el" href="group__buildblock.html#ga58339978ae5e7a02db3ba4d82bff5ab6" title="Use this function for writing informational messages. ">info</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Array.html#gaf8508ec2aa627b002cfcd8d30e2824bf">stir::convert_array()</a>, and <a class="el" href="classstir_1_1convert__array__Tests.html#ad055bda1fda6f68cdccb15e9c32caa56">stir::convert_array_Tests::run_tests()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 7 2021 07:21:19 for STIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
