<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STIR: stir::VectorWithOffset&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STIR
   &#160;<span id="projectnumber">4.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestir.html">stir</a></li><li class="navelem"><a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classstir_1_1VectorWithOffset-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">stir::VectorWithOffset&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__STIR.html">STIR</a> &raquo; <a class="el" href="group__STIR__library.html">STIR library</a> &raquo; <a class="el" href="group__buildblock.html">Basic building blocks</a> &raquo; <a class="el" href="group__Array.html">Items relating to vectors and (multi-dimensional) arrays</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A templated class for vectors, but with indices starting not from 0.  
 <a href="classstir_1_1VectorWithOffset.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="VectorWithOffset_8h_source.html">stir/VectorWithOffset.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for stir::VectorWithOffset&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classstir_1_1VectorWithOffset__inherit__graph.png" border="0" usemap="#stir_1_1VectorWithOffset_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="stir_1_1VectorWithOffset_3_01T_01_4_inherit__map" id="stir_1_1VectorWithOffset_3_01T_01_4_inherit__map">
<area shape="rect" id="node2" href="classstir_1_1NumericVectorWithOffset.html" title="like VectorWithOffset, but with changes in various numeric operators " alt="" coords="533,384,787,411"/>
<area shape="rect" id="node22" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; shared_ptr\&lt; stir::ArrayFunction\lObject\&lt; 1, elemT \&gt; \&gt; \&gt;" alt="" coords="541,809,779,865"/>
<area shape="rect" id="node23" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; shared_ptr\&lt; stir::DataProcessor\l\&lt; TargetT \&gt; \&gt; \&gt;" alt="" coords="538,889,782,945"/>
<area shape="rect" id="node24" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; stir::VectorWithOffset\l\&lt; elemT \&gt; \&gt;" alt="" coords="572,969,748,1025"/>
<area shape="rect" id="node25" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; stir::VectorWithOffset\l\&lt; shared_ptr\&lt; RingNumPairs \&gt; \&gt; \&gt;" alt="" coords="531,1049,789,1105"/>
<area shape="rect" id="node26" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; float \&gt;" alt="" coords="579,1130,741,1171"/>
<area shape="rect" id="node27" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; elemT \&gt;" alt="" coords="579,743,741,785"/>
<area shape="rect" id="node28" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; int \&gt;" alt="" coords="579,1195,741,1237"/>
<area shape="rect" id="node29" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; stir::QuadraticPrior\l\&lt; float \&gt; \&gt;" alt="" coords="579,1261,741,1317"/>
<area shape="rect" id="node30" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; Array\&lt; num_dimensions\l&#45;1, elemT \&gt; \&gt;" alt="" coords="561,663,759,719"/>
<area shape="rect" id="node31" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; stir::VectorWithOffset\l\&lt; ViewTangPosSwap \&gt; \&gt;" alt="" coords="567,1341,753,1397"/>
<area shape="rect" id="node32" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; stir::VectorWithOffset\l\&lt; MapProjMatrixElemsForOneBin \&gt; \&gt;" alt="" coords="527,1421,793,1477"/>
<area shape="rect" id="node33" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; stir::VectorWithOffset\l\&lt; int \&gt; \&gt;" alt="" coords="572,1501,748,1557"/>
<area shape="rect" id="node34" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; shared_ptr\&lt; TargetT \&gt; \&gt;" alt="" coords="561,1582,759,1623"/>
<area shape="rect" id="node35" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; stir::VectorWithOffset\l\&lt; Det1Det2 \&gt; \&gt;" alt="" coords="572,1648,748,1704"/>
<area shape="rect" id="node36" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; stir::PoissonLogLikelihood\lWithLinearModelForMeanAndProjData \&gt;" alt="" coords="519,1728,801,1784"/>
<area shape="rect" id="node37" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; shared_ptr\&lt; stir::BinNormalisation \&gt; \&gt;" alt="" coords="513,1809,807,1850"/>
<area shape="rect" id="node38" href="classstir_1_1VectorWithOffset.html" title="stir::VectorWithOffset\l\&lt; IndexRange\&lt; num_dimensions&#45;1 \&gt; \&gt;" alt="" coords="519,1874,801,1915"/>
<area shape="rect" id="node3" href="classstir_1_1Array.html" title="Array\&lt; 1, float \&gt;" alt="" coords="1081,603,1213,629"/>
<area shape="rect" id="node4" href="classstir_1_1Array.html" title="Array\&lt; 1, T \&gt;" alt="" coords="1092,5,1203,32"/>
<area shape="rect" id="node5" href="classstir_1_1Array.html" title="Array\&lt; 2, float \&gt;" alt="" coords="1081,56,1213,83"/>
<area shape="rect" id="node7" href="classstir_1_1Array.html" title="Array\&lt; 2, int \&gt;" alt="" coords="1087,107,1207,133"/>
<area shape="rect" id="node8" href="classstir_1_1Array.html" title="Array\&lt; 3, float \&gt;" alt="" coords="1081,157,1213,184"/>
<area shape="rect" id="node9" href="classstir_1_1Array.html" title="Array\&lt; 3, std::pair\l\&lt; stir::BasicCoordinate\l\&lt; 3, elemT \&gt;, elemT \&gt; \&gt;" alt="" coords="1053,208,1241,264"/>
<area shape="rect" id="node10" href="classstir_1_1Array.html" title="Array\&lt; 3, stir::BasicCoordinate\l\&lt; 3, elemT \&gt; \&gt;" alt="" coords="1036,289,1259,330"/>
<area shape="rect" id="node11" href="classstir_1_1Array.html" title="Array\&lt; 4, float \&gt;" alt="" coords="1081,355,1213,381"/>
<area shape="rect" id="node12" href="classstir_1_1Array.html" title="Array\&lt; num_dimensions,\l out_elemT \&gt;" alt="" coords="1054,406,1241,447"/>
<area shape="rect" id="node13" href="classstir_1_1Array.html" title="Array\&lt; num_dimensions,\l std::complex\&lt; elemT \&gt; \&gt;" alt="" coords="1049,471,1245,513"/>
<area shape="rect" id="node14" href="classstir_1_1Array.html" title="Array\&lt; num_dimensions,\l std::complex\&lt; float \&gt; \&gt;" alt="" coords="1054,537,1241,578"/>
<area shape="rect" id="node15" href="classstir_1_1NumericVectorWithOffset.html" title="stir::NumericVectorWithOffset\l\&lt; Array\&lt; num_dimensions&#45;1,\l elemT \&gt;, elemT \&gt;" alt="" coords="1039,653,1255,709"/>
<area shape="rect" id="node20" href="classstir_1_1NumericVectorWithOffset.html" title="stir::NumericVectorWithOffset\l\&lt; elemT, elemT \&gt;" alt="" coords="1039,743,1255,785"/>
<area shape="rect" id="node6" href="classstir_1_1Viewgram.html" title="stir::Viewgram\&lt; float \&gt;" alt="" coords="1485,56,1661,83"/>
<area shape="rect" id="node16" href="classstir_1_1Array.html" title="stir::Array\&lt; 2, elemT \&gt;" alt="" coords="1897,505,2070,532"/>
<area shape="rect" id="node17" href="classstir_1_1Array.html" title="stir::Array\&lt; 3, elemT \&gt;" alt="" coords="1897,579,2070,605"/>
<area shape="rect" id="node18" href="classstir_1_1Array.html" title="stir::Array\&lt; num_dimensions\l&#45;1, elemT \&gt;" alt="" coords="1877,675,2089,717"/>
<area shape="rect" id="node19" href="classstir_1_1Array.html" title="This class defines multi&#45;dimensional (numeric) arrays. " alt="" coords="1465,579,1681,621"/>
<area shape="rect" id="node21" href="classstir_1_1Array_3_011_00_01elemT_01_4.html" title="The 1&#45;dimensional (partial) specialisation of Array. " alt="" coords="1487,769,1660,796"/>
<area shape="rect" id="node39" href="classstir_1_1IndexRange.html" title="stir::IndexRange\&lt; 2 \&gt;" alt="" coords="1490,1728,1657,1755"/>
<area shape="rect" id="node41" href="classstir_1_1IndexRange.html" title="stir::IndexRange\&lt; 3 \&gt;" alt="" coords="1490,2023,1657,2049"/>
<area shape="rect" id="node43" href="classstir_1_1IndexRange.html" title="stir::IndexRange\&lt; 4 \&gt;" alt="" coords="1490,1819,1657,1845"/>
<area shape="rect" id="node45" href="classstir_1_1IndexRange.html" title="stir::IndexRange\&lt; num\l_dimensions&#45;1 \&gt;" alt="" coords="1487,1917,1659,1958"/>
<area shape="rect" id="node46" href="classstir_1_1IndexRange.html" title="This class defines ranges which can be &#39;irregular&#39;. " alt="" coords="1061,1874,1233,1915"/>
<area shape="rect" id="node40" href="classstir_1_1IndexRange2D.html" title="a &#39;convenience&#39; class for 2D index ranges. " alt="" coords="1910,1728,2057,1755"/>
<area shape="rect" id="node42" href="classstir_1_1IndexRange3D.html" title="a &#39;convenience&#39; class for 3D index ranges. Provides an easier constructor for regular ranges..." alt="" coords="1910,2023,2057,2049"/>
<area shape="rect" id="node44" href="classstir_1_1IndexRange4D.html" title="A convenience class for 4D index ranges. " alt="" coords="1910,1819,2057,1845"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9cc2cdc27359a727046a7390a7304edd"><td class="memItemLeft" align="right" valign="top"><a id="a9cc2cdc27359a727046a7390a7304edd"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a9cc2cdc27359a727046a7390a7304edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">typedefs for iterator support</div></td></tr>
<tr class="memitem:aa8e4459a7c7d929ec347bcc4311793dc"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#aa8e4459a7c7d929ec347bcc4311793dc">value_type</a></td></tr>
<tr class="separator:aa8e4459a7c7d929ec347bcc4311793dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5429c0f64832adf47182872ce1ff37dd"><td class="memItemLeft" align="right" valign="top"><a id="a5429c0f64832adf47182872ce1ff37dd"></a>
typedef <a class="el" href="classstir_1_1VectorWithOffset.html#aa8e4459a7c7d929ec347bcc4311793dc">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a5429c0f64832adf47182872ce1ff37dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f5bfa4975a429081d50243a79bce80"><td class="memItemLeft" align="right" valign="top"><a id="af0f5bfa4975a429081d50243a79bce80"></a>
typedef const <a class="el" href="classstir_1_1VectorWithOffset.html#aa8e4459a7c7d929ec347bcc4311793dc">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:af0f5bfa4975a429081d50243a79bce80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927c1394482d76dbdd8101fac655440a"><td class="memItemLeft" align="right" valign="top"><a id="a927c1394482d76dbdd8101fac655440a"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a927c1394482d76dbdd8101fac655440a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ea63441cb07b5aaf674de0895387ed"><td class="memItemLeft" align="right" valign="top"><a id="a85ea63441cb07b5aaf674de0895387ed"></a>
typedef <a class="el" href="classstir_1_1detail_1_1VectorWithOffset__iter.html">detail::VectorWithOffset_iter</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a85ea63441cb07b5aaf674de0895387ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49509482270e44b48d9ff73a98fc729e"><td class="memItemLeft" align="right" valign="top"><a id="a49509482270e44b48d9ff73a98fc729e"></a>
typedef <a class="el" href="classstir_1_1detail_1_1VectorWithOffset__iter.html">detail::VectorWithOffset_iter</a>&lt; T const  &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a49509482270e44b48d9ff73a98fc729e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dbfec6b3a902f9deb269321119cdbf"><td class="memItemLeft" align="right" valign="top"><a id="a51dbfec6b3a902f9deb269321119cdbf"></a>
typedef boost::reverse_iterator&lt; <a class="el" href="classstir_1_1detail_1_1VectorWithOffset__iter.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a51dbfec6b3a902f9deb269321119cdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171492ec6b18ca3a0493b2dc65599f7e"><td class="memItemLeft" align="right" valign="top"><a id="a171492ec6b18ca3a0493b2dc65599f7e"></a>
typedef boost::reverse_iterator&lt; <a class="el" href="classstir_1_1detail_1_1VectorWithOffset__iter.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a171492ec6b18ca3a0493b2dc65599f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abcf7832a5c22ea80e153d7353435c1b9"><td class="memItemLeft" align="right" valign="top"><a id="abcf7832a5c22ea80e153d7353435c1b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#abcf7832a5c22ea80e153d7353435c1b9">VectorWithOffset</a> ()</td></tr>
<tr class="memdesc:abcf7832a5c22ea80e153d7353435c1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor: creates a vector of length 0. <br /></td></tr>
<tr class="separator:abcf7832a5c22ea80e153d7353435c1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1504b670494d19cefe2731d51120fbef"><td class="memItemLeft" align="right" valign="top"><a id="a1504b670494d19cefe2731d51120fbef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a1504b670494d19cefe2731d51120fbef">VectorWithOffset</a> (const int hsz)</td></tr>
<tr class="memdesc:a1504b670494d19cefe2731d51120fbef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classstir_1_1VectorWithOffset.html" title="A templated class for vectors, but with indices starting not from 0. ">VectorWithOffset</a> of given length (initialised with <code>T()</code>) <br /></td></tr>
<tr class="separator:a1504b670494d19cefe2731d51120fbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f8c543d657fdc6b302c8b2ddb1d703"><td class="memItemLeft" align="right" valign="top"><a id="a88f8c543d657fdc6b302c8b2ddb1d703"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a88f8c543d657fdc6b302c8b2ddb1d703">VectorWithOffset</a> (const int min_index, const int max_index)</td></tr>
<tr class="memdesc:a88f8c543d657fdc6b302c8b2ddb1d703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classstir_1_1VectorWithOffset.html" title="A templated class for vectors, but with indices starting not from 0. ">VectorWithOffset</a> with offset <code>min_index</code> (initialised with <code>T()</code>) <br /></td></tr>
<tr class="separator:a88f8c543d657fdc6b302c8b2ddb1d703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980564ce71e114a887176d1952c0a30b"><td class="memItemLeft" align="right" valign="top"><a id="a980564ce71e114a887176d1952c0a30b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a980564ce71e114a887176d1952c0a30b">VectorWithOffset</a> (const int hsz, T *const data_ptr, T *const end_of_data_ptr)</td></tr>
<tr class="memdesc:a980564ce71e114a887176d1952c0a30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classstir_1_1VectorWithOffset.html" title="A templated class for vectors, but with indices starting not from 0. ">VectorWithOffset</a> of given length using existing data (no initialisation) <br /></td></tr>
<tr class="separator:a980564ce71e114a887176d1952c0a30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9740a16b5acdb6bc11b0bac6d463528"><td class="memItemLeft" align="right" valign="top"><a id="af9740a16b5acdb6bc11b0bac6d463528"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#af9740a16b5acdb6bc11b0bac6d463528">VectorWithOffset</a> (const int min_index, const int max_index, T *const data_ptr, T *const end_of_data_ptr)</td></tr>
<tr class="memdesc:af9740a16b5acdb6bc11b0bac6d463528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classstir_1_1VectorWithOffset.html" title="A templated class for vectors, but with indices starting not from 0. ">VectorWithOffset</a> with offset <code>min_index</code> using existing data (no initialisation) <br /></td></tr>
<tr class="separator:af9740a16b5acdb6bc11b0bac6d463528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7869e0fefe59c1f80f0d06ead3c198"><td class="memItemLeft" align="right" valign="top"><a id="a1a7869e0fefe59c1f80f0d06ead3c198"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a1a7869e0fefe59c1f80f0d06ead3c198">VectorWithOffset</a> (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;il)</td></tr>
<tr class="memdesc:a1a7869e0fefe59c1f80f0d06ead3c198"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor <br /></td></tr>
<tr class="separator:a1a7869e0fefe59c1f80f0d06ead3c198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d97ed50529e8a0c8553b6234079eba"><td class="memItemLeft" align="right" valign="top"><a id="af9d97ed50529e8a0c8553b6234079eba"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#af9d97ed50529e8a0c8553b6234079eba">~VectorWithOffset</a> ()</td></tr>
<tr class="memdesc:af9d97ed50529e8a0c8553b6234079eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:af9d97ed50529e8a0c8553b6234079eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac191bacb3ad44a3fd32b794c96a5f819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#ac191bacb3ad44a3fd32b794c96a5f819">recycle</a> ()</td></tr>
<tr class="memdesc:ac191bacb3ad44a3fd32b794c96a5f819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all memory and make object as if default-constructed.  <a href="#ac191bacb3ad44a3fd32b794c96a5f819">More...</a><br /></td></tr>
<tr class="separator:ac191bacb3ad44a3fd32b794c96a5f819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e60b03d8b77246e2f436290a31ff3c2"><td class="memItemLeft" align="right" valign="top"><a id="a8e60b03d8b77246e2f436290a31ff3c2"></a>
<a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a8e60b03d8b77246e2f436290a31ff3c2">operator=</a> (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;il)</td></tr>
<tr class="memdesc:a8e60b03d8b77246e2f436290a31ff3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment operator with another vector <br /></td></tr>
<tr class="separator:a8e60b03d8b77246e2f436290a31ff3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d056b87272092120185f22afbef36ac"><td class="memItemLeft" align="right" valign="top"><a id="a5d056b87272092120185f22afbef36ac"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a5d056b87272092120185f22afbef36ac">operator[]</a> (int i)</td></tr>
<tr class="memdesc:a5d056b87272092120185f22afbef36ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">allow array-style access, read/write <br /></td></tr>
<tr class="separator:a5d056b87272092120185f22afbef36ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3b8277a612db588c7430a68c15063e"><td class="memItemLeft" align="right" valign="top"><a id="aaf3b8277a612db588c7430a68c15063e"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#aaf3b8277a612db588c7430a68c15063e">operator[]</a> (int i) const</td></tr>
<tr class="memdesc:aaf3b8277a612db588c7430a68c15063e"><td class="mdescLeft">&#160;</td><td class="mdescRight">array access, read-only <br /></td></tr>
<tr class="separator:aaf3b8277a612db588c7430a68c15063e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6386928b15e2d6080dd1b9ca63f10d1"><td class="memItemLeft" align="right" valign="top"><a id="ab6386928b15e2d6080dd1b9ca63f10d1"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#ab6386928b15e2d6080dd1b9ca63f10d1">at</a> (int i)</td></tr>
<tr class="memdesc:ab6386928b15e2d6080dd1b9ca63f10d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">allow array-style access, read/write, but with range checking (throws std::out_of_range) <br /></td></tr>
<tr class="separator:ab6386928b15e2d6080dd1b9ca63f10d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9296a5686a8098752eaf92d8d6f3847"><td class="memItemLeft" align="right" valign="top"><a id="ad9296a5686a8098752eaf92d8d6f3847"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#ad9296a5686a8098752eaf92d8d6f3847">at</a> (int i) const</td></tr>
<tr class="memdesc:ad9296a5686a8098752eaf92d8d6f3847"><td class="mdescLeft">&#160;</td><td class="mdescRight">array access, read-only, but with range checking (throws std::out_of_range) <br /></td></tr>
<tr class="separator:ad9296a5686a8098752eaf92d8d6f3847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4706aa7b4eb81d5ea72c4869824d57"><td class="memItemLeft" align="right" valign="top"><a id="acf4706aa7b4eb81d5ea72c4869824d57"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#acf4706aa7b4eb81d5ea72c4869824d57">empty</a> () const</td></tr>
<tr class="memdesc:acf4706aa7b4eb81d5ea72c4869824d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the vector is empty <br /></td></tr>
<tr class="separator:acf4706aa7b4eb81d5ea72c4869824d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cbbc39532fa95ee7121cb251ab43d0"><td class="memItemLeft" align="right" valign="top"><a id="ac3cbbc39532fa95ee7121cb251ab43d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#ac3cbbc39532fa95ee7121cb251ab43d0">fill</a> (const T &amp;n)</td></tr>
<tr class="memdesc:ac3cbbc39532fa95ee7121cb251ab43d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill elements with value <em>n</em> <br /></td></tr>
<tr class="separator:ac3cbbc39532fa95ee7121cb251ab43d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">index range operations</div></td></tr>
<tr class="memitem:a9179fdbe02bc4cb22fde51599537e2b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a9179fdbe02bc4cb22fde51599537e2b5">get_length</a> () const</td></tr>
<tr class="memdesc:a9179fdbe02bc4cb22fde51599537e2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return number of elements in this vector  <a href="#a9179fdbe02bc4cb22fde51599537e2b5">More...</a><br /></td></tr>
<tr class="separator:a9179fdbe02bc4cb22fde51599537e2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5c52350ad01a1b87d03c85a0eb0060"><td class="memItemLeft" align="right" valign="top"><a id="aec5c52350ad01a1b87d03c85a0eb0060"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#aec5c52350ad01a1b87d03c85a0eb0060">size</a> () const</td></tr>
<tr class="memdesc:aec5c52350ad01a1b87d03c85a0eb0060"><td class="mdescLeft">&#160;</td><td class="mdescRight">return number of elements in this vector <br /></td></tr>
<tr class="separator:aec5c52350ad01a1b87d03c85a0eb0060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60196eb5ff5b91256df466ca4ddbd7fa"><td class="memItemLeft" align="right" valign="top"><a id="a60196eb5ff5b91256df466ca4ddbd7fa"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">get_min_index</a> () const</td></tr>
<tr class="memdesc:a60196eb5ff5b91256df466ca4ddbd7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">get value of first valid index <br /></td></tr>
<tr class="separator:a60196eb5ff5b91256df466ca4ddbd7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a3bcc84639216e608406803d98f14e"><td class="memItemLeft" align="right" valign="top"><a id="a23a3bcc84639216e608406803d98f14e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a23a3bcc84639216e608406803d98f14e">get_max_index</a> () const</td></tr>
<tr class="memdesc:a23a3bcc84639216e608406803d98f14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get value of last valid index <br /></td></tr>
<tr class="separator:a23a3bcc84639216e608406803d98f14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24e78ff5902bd2f09d2738b8041736c"><td class="memItemLeft" align="right" valign="top"><a id="aa24e78ff5902bd2f09d2738b8041736c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#aa24e78ff5902bd2f09d2738b8041736c">set_offset</a> (const int min_index)</td></tr>
<tr class="memdesc:aa24e78ff5902bd2f09d2738b8041736c"><td class="mdescLeft">&#160;</td><td class="mdescRight">change value of starting index <br /></td></tr>
<tr class="separator:aa24e78ff5902bd2f09d2738b8041736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd415055b8ff81ace8cbf1c54a65350"><td class="memItemLeft" align="right" valign="top"><a id="a9fd415055b8ff81ace8cbf1c54a65350"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a9fd415055b8ff81ace8cbf1c54a65350">set_min_index</a> (const int min_index)</td></tr>
<tr class="memdesc:a9fd415055b8ff81ace8cbf1c54a65350"><td class="mdescLeft">&#160;</td><td class="mdescRight">identical to <a class="el" href="classstir_1_1VectorWithOffset.html#aa24e78ff5902bd2f09d2738b8041736c" title="change value of starting index ">set_offset()</a> <br /></td></tr>
<tr class="separator:a9fd415055b8ff81ace8cbf1c54a65350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38df200757ae21edbf5dcc495b0e63d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a38df200757ae21edbf5dcc495b0e63d4">grow</a> (const int min_index, const int max_index)</td></tr>
<tr class="memdesc:a38df200757ae21edbf5dcc495b0e63d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">grow the range of the vector, new elements are set to <code>T()</code>  <a href="#a38df200757ae21edbf5dcc495b0e63d4">More...</a><br /></td></tr>
<tr class="separator:a38df200757ae21edbf5dcc495b0e63d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae270ee579120b0b96033d9472c9acfec"><td class="memItemLeft" align="right" valign="top"><a id="ae270ee579120b0b96033d9472c9acfec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#ae270ee579120b0b96033d9472c9acfec">grow</a> (const unsigned int new_size)</td></tr>
<tr class="memdesc:ae270ee579120b0b96033d9472c9acfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">grow the range of the vector from 0 to new_size-1, new elements are set to <code>T()</code> <br /></td></tr>
<tr class="separator:ae270ee579120b0b96033d9472c9acfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0410b14fbc21f5b11632738dbca877"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#aed0410b14fbc21f5b11632738dbca877">resize</a> (const int min_index, const int max_index)</td></tr>
<tr class="memdesc:aed0410b14fbc21f5b11632738dbca877"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the range of the vector, new elements are set to <code>T()</code>  <a href="#aed0410b14fbc21f5b11632738dbca877">More...</a><br /></td></tr>
<tr class="separator:aed0410b14fbc21f5b11632738dbca877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae004d6afb65cd638863788ecf9d323b1"><td class="memItemLeft" align="right" valign="top"><a id="ae004d6afb65cd638863788ecf9d323b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#ae004d6afb65cd638863788ecf9d323b1">resize</a> (const unsigned int new_size)</td></tr>
<tr class="memdesc:ae004d6afb65cd638863788ecf9d323b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the range of the vector from 0 to new_size-1, new elements are set to <code>T()</code> <br /></td></tr>
<tr class="separator:ae004d6afb65cd638863788ecf9d323b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737237fe3ff32e3f6da2f0463e414a32"><td class="memItemLeft" align="right" valign="top"><a id="a737237fe3ff32e3f6da2f0463e414a32"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a737237fe3ff32e3f6da2f0463e414a32">reserve</a> (const int min_index, const int max_index)</td></tr>
<tr class="memdesc:a737237fe3ff32e3f6da2f0463e414a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">make the allocated range at least from <em>min_index</em> to <em>max_index</em> <br /></td></tr>
<tr class="separator:a737237fe3ff32e3f6da2f0463e414a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63670ee608334fd578f8dac0a6c63cc7"><td class="memItemLeft" align="right" valign="top"><a id="a63670ee608334fd578f8dac0a6c63cc7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a63670ee608334fd578f8dac0a6c63cc7">reserve</a> (const unsigned int new_size)</td></tr>
<tr class="memdesc:a63670ee608334fd578f8dac0a6c63cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">make the allocated range at least from 0 to new_size-1 <br /></td></tr>
<tr class="separator:a63670ee608334fd578f8dac0a6c63cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407ea687fe151421552cfd591ff8db81"><td class="memItemLeft" align="right" valign="top"><a id="a407ea687fe151421552cfd591ff8db81"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a407ea687fe151421552cfd591ff8db81">capacity</a> () const</td></tr>
<tr class="memdesc:a407ea687fe151421552cfd591ff8db81"><td class="mdescLeft">&#160;</td><td class="mdescRight">get allocated size <br /></td></tr>
<tr class="separator:a407ea687fe151421552cfd591ff8db81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68696b46943dfbd63124b3287bad24d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a68696b46943dfbd63124b3287bad24d6">owns_memory_for_data</a> () const</td></tr>
<tr class="memdesc:a68696b46943dfbd63124b3287bad24d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if this object owns the memory for the data  <a href="#a68696b46943dfbd63124b3287bad24d6">More...</a><br /></td></tr>
<tr class="separator:a68696b46943dfbd63124b3287bad24d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd11c494f2c0ce80781004068ba705fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#acd11c494f2c0ce80781004068ba705fb">get_capacity_min_index</a> () const</td></tr>
<tr class="memdesc:acd11c494f2c0ce80781004068ba705fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">get min_index within allocated range  <a href="#acd11c494f2c0ce80781004068ba705fb">More...</a><br /></td></tr>
<tr class="separator:acd11c494f2c0ce80781004068ba705fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc49c87e5bee68fac33646558001bb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#abbc49c87e5bee68fac33646558001bb8">get_capacity_max_index</a> () const</td></tr>
<tr class="memdesc:abbc49c87e5bee68fac33646558001bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">get max_index within allocated range  <a href="#abbc49c87e5bee68fac33646558001bb8">More...</a><br /></td></tr>
<tr class="separator:abbc49c87e5bee68fac33646558001bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">comparison operators</div></td></tr>
<tr class="memitem:a92ea9a9053897c0ab7ccd1f370816a91"><td class="memItemLeft" align="right" valign="top"><a id="a92ea9a9053897c0ab7ccd1f370816a91"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;iv) const</td></tr>
<tr class="separator:a92ea9a9053897c0ab7ccd1f370816a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1a2eb47979aefdaeb9f136f8b1c09b"><td class="memItemLeft" align="right" valign="top"><a id="aec1a2eb47979aefdaeb9f136f8b1c09b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;iv) const</td></tr>
<tr class="separator:aec1a2eb47979aefdaeb9f136f8b1c09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">access to the data via a pointer</div></td></tr>
<tr class="memitem:aa1941fe125da49b6aa82d05e86f090ac"><td class="memItemLeft" align="right" valign="top"><a id="aa1941fe125da49b6aa82d05e86f090ac"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#aa1941fe125da49b6aa82d05e86f090ac">get_data_ptr</a> ()</td></tr>
<tr class="memdesc:aa1941fe125da49b6aa82d05e86f090ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">member function for access to the data via a T* <br /></td></tr>
<tr class="separator:aa1941fe125da49b6aa82d05e86f090ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc02652d904daa1a68642d811e8dee5"><td class="memItemLeft" align="right" valign="top"><a id="a5dc02652d904daa1a68642d811e8dee5"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a5dc02652d904daa1a68642d811e8dee5">get_const_data_ptr</a> () const</td></tr>
<tr class="memdesc:a5dc02652d904daa1a68642d811e8dee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">member function for access to the data via a const T* <br /></td></tr>
<tr class="separator:a5dc02652d904daa1a68642d811e8dee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5ec338892b62cad731355530628c31"><td class="memItemLeft" align="right" valign="top"><a id="a6d5ec338892b62cad731355530628c31"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a6d5ec338892b62cad731355530628c31">release_data_ptr</a> ()</td></tr>
<tr class="memdesc:a6d5ec338892b62cad731355530628c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">signal end of access to T* <br /></td></tr>
<tr class="separator:a6d5ec338892b62cad731355530628c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bc75b62129576f3a8c09c3b850d89f"><td class="memItemLeft" align="right" valign="top"><a id="a06bc75b62129576f3a8c09c3b850d89f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a06bc75b62129576f3a8c09c3b850d89f">release_const_data_ptr</a> () const</td></tr>
<tr class="memdesc:a06bc75b62129576f3a8c09c3b850d89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">signal end of access to const T* <br /></td></tr>
<tr class="separator:a06bc75b62129576f3a8c09c3b850d89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">basic iterator support</div></td></tr>
<tr class="memitem:ad29792ed78c33cf9465e0365fb261547"><td class="memItemLeft" align="right" valign="top"><a id="ad29792ed78c33cf9465e0365fb261547"></a>
<a class="el" href="classstir_1_1detail_1_1VectorWithOffset__iter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#ad29792ed78c33cf9465e0365fb261547">begin</a> ()</td></tr>
<tr class="memdesc:ad29792ed78c33cf9465e0365fb261547"><td class="mdescLeft">&#160;</td><td class="mdescRight">use to initialise an iterator to the first element of the vector <br /></td></tr>
<tr class="separator:ad29792ed78c33cf9465e0365fb261547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e9ce426bd39576c209de94ca476b70"><td class="memItemLeft" align="right" valign="top"><a id="a14e9ce426bd39576c209de94ca476b70"></a>
<a class="el" href="classstir_1_1detail_1_1VectorWithOffset__iter.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a14e9ce426bd39576c209de94ca476b70">begin</a> () const</td></tr>
<tr class="memdesc:a14e9ce426bd39576c209de94ca476b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">use to initialise an iterator to the first element of the (const) vector <br /></td></tr>
<tr class="separator:a14e9ce426bd39576c209de94ca476b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab808970194605ce7c58fe1cdaaf5ddf8"><td class="memItemLeft" align="right" valign="top"><a id="ab808970194605ce7c58fe1cdaaf5ddf8"></a>
<a class="el" href="classstir_1_1detail_1_1VectorWithOffset__iter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#ab808970194605ce7c58fe1cdaaf5ddf8">end</a> ()</td></tr>
<tr class="memdesc:ab808970194605ce7c58fe1cdaaf5ddf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator 'past' the last element of the vector <br /></td></tr>
<tr class="separator:ab808970194605ce7c58fe1cdaaf5ddf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e6c14ffeecef3a3f7d15a7dda57e80"><td class="memItemLeft" align="right" valign="top"><a id="ad4e6c14ffeecef3a3f7d15a7dda57e80"></a>
<a class="el" href="classstir_1_1detail_1_1VectorWithOffset__iter.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#ad4e6c14ffeecef3a3f7d15a7dda57e80">end</a> () const</td></tr>
<tr class="memdesc:ad4e6c14ffeecef3a3f7d15a7dda57e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator 'past' the last element of the (const) vector <br /></td></tr>
<tr class="separator:ad4e6c14ffeecef3a3f7d15a7dda57e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93c3231dde8a8188dd26db2532b4533"><td class="memItemLeft" align="right" valign="top"><a id="af93c3231dde8a8188dd26db2532b4533"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> ()</td></tr>
<tr class="separator:af93c3231dde8a8188dd26db2532b4533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9636d934f23381423c5ce92ba6baa7"><td class="memItemLeft" align="right" valign="top"><a id="aea9636d934f23381423c5ce92ba6baa7"></a>
reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> ()</td></tr>
<tr class="separator:aea9636d934f23381423c5ce92ba6baa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93e8847c617d589b6d36fa7528bc491"><td class="memItemLeft" align="right" valign="top"><a id="ad93e8847c617d589b6d36fa7528bc491"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const</td></tr>
<tr class="separator:ad93e8847c617d589b6d36fa7528bc491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6f9619628762f134a3b0cbd4572f76"><td class="memItemLeft" align="right" valign="top"><a id="ace6f9619628762f134a3b0cbd4572f76"></a>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const</td></tr>
<tr class="separator:ace6f9619628762f134a3b0cbd4572f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">arithmetic assignment operators with objects of the same type</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section warning"><dt>Warning</dt><dd>Arguments must have matching index ranges. Otherwise <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f" title="Print error with format string a la printf and throw exception. ">error()</a> is called. </dd></dl>
</div></td></tr>
<tr class="memitem:a26c7e99828f520011392726b15643882"><td class="memItemLeft" align="right" valign="top"><a id="a26c7e99828f520011392726b15643882"></a>
<a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a26c7e99828f520011392726b15643882">operator+=</a> (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;v)</td></tr>
<tr class="memdesc:a26c7e99828f520011392726b15643882"><td class="mdescLeft">&#160;</td><td class="mdescRight">adding elements of <code>v</code> to the current vector <br /></td></tr>
<tr class="separator:a26c7e99828f520011392726b15643882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa930f87dc3d1fe5a5cb8b8b7552e1e3e"><td class="memItemLeft" align="right" valign="top"><a id="aa930f87dc3d1fe5a5cb8b8b7552e1e3e"></a>
<a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#aa930f87dc3d1fe5a5cb8b8b7552e1e3e">operator-=</a> (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;v)</td></tr>
<tr class="memdesc:aa930f87dc3d1fe5a5cb8b8b7552e1e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracting elements of <code>v</code> from the current vector <br /></td></tr>
<tr class="separator:aa930f87dc3d1fe5a5cb8b8b7552e1e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e90268689567302054bfc04ad30106"><td class="memItemLeft" align="right" valign="top"><a id="ad1e90268689567302054bfc04ad30106"></a>
<a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#ad1e90268689567302054bfc04ad30106">operator*=</a> (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;v)</td></tr>
<tr class="memdesc:ad1e90268689567302054bfc04ad30106"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplying elements of the current vector with elements of <code>v</code> <br /></td></tr>
<tr class="separator:ad1e90268689567302054bfc04ad30106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a04c4a0624925e61afc9e733252846"><td class="memItemLeft" align="right" valign="top"><a id="ac8a04c4a0624925e61afc9e733252846"></a>
<a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#ac8a04c4a0624925e61afc9e733252846">operator/=</a> (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;v)</td></tr>
<tr class="memdesc:ac8a04c4a0624925e61afc9e733252846"><td class="mdescLeft">&#160;</td><td class="mdescRight">dividing all elements of the current vector by elements of <code>v</code> <br /></td></tr>
<tr class="separator:ac8a04c4a0624925e61afc9e733252846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">arithmetic operators with objects of the same type</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section warning"><dt>Warning</dt><dd>Arguments must have matching index ranges. Otherwise <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f" title="Print error with format string a la printf and throw exception. ">error()</a> is called. </dd>
<dd>
current implementation involves a temporary copy of the data, unless you have a really smart compiler. </dd></dl>
</div></td></tr>
<tr class="memitem:a22bcb4ff3ed62d972160c72b0651a5e6"><td class="memItemLeft" align="right" valign="top"><a id="a22bcb4ff3ed62d972160c72b0651a5e6"></a>
<a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a22bcb4ff3ed62d972160c72b0651a5e6">operator+</a> (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;v) const</td></tr>
<tr class="memdesc:a22bcb4ff3ed62d972160c72b0651a5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">adding vectors, element by element <br /></td></tr>
<tr class="separator:a22bcb4ff3ed62d972160c72b0651a5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946227843abaff31c621668ec967bbc6"><td class="memItemLeft" align="right" valign="top"><a id="a946227843abaff31c621668ec967bbc6"></a>
<a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a946227843abaff31c621668ec967bbc6">operator-</a> (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;v) const</td></tr>
<tr class="memdesc:a946227843abaff31c621668ec967bbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtracting vectors, element by element <br /></td></tr>
<tr class="separator:a946227843abaff31c621668ec967bbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1ccd94c1c638033270d0a91b2152df"><td class="memItemLeft" align="right" valign="top"><a id="a1c1ccd94c1c638033270d0a91b2152df"></a>
<a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a1c1ccd94c1c638033270d0a91b2152df">operator*</a> (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;v) const</td></tr>
<tr class="memdesc:a1c1ccd94c1c638033270d0a91b2152df"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplying vectors, element by element <br /></td></tr>
<tr class="separator:a1c1ccd94c1c638033270d0a91b2152df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44402215a51784402dfb52a0ffc1886b"><td class="memItemLeft" align="right" valign="top"><a id="a44402215a51784402dfb52a0ffc1886b"></a>
<a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a44402215a51784402dfb52a0ffc1886b">operator/</a> (const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a> &amp;v) const</td></tr>
<tr class="memdesc:a44402215a51784402dfb52a0ffc1886b"><td class="mdescLeft">&#160;</td><td class="mdescRight">dividing vectors, element by element <br /></td></tr>
<tr class="separator:a44402215a51784402dfb52a0ffc1886b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a18a1331e3af6ea9a1d5b5ff177f4ae19"><td class="memItemLeft" align="right" valign="top"><a id="a18a1331e3af6ea9a1d5b5ff177f4ae19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#a18a1331e3af6ea9a1d5b5ff177f4ae19">check_state</a> () const</td></tr>
<tr class="memdesc:a18a1331e3af6ea9a1d5b5ff177f4ae19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called internally to see if all variables are consistent. <br /></td></tr>
<tr class="separator:a18a1331e3af6ea9a1d5b5ff177f4ae19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aebb7f773557682e1a3bfd55612974164"><td class="memItemLeft" align="right" valign="top"><a id="aebb7f773557682e1a3bfd55612974164"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1VectorWithOffset.html#aebb7f773557682e1a3bfd55612974164">num</a></td></tr>
<tr class="memdesc:aebb7f773557682e1a3bfd55612974164"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to (*this)[0] (taking <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa" title="get value of first valid index ">get_min_index()</a> into account that is). <br /></td></tr>
<tr class="separator:aebb7f773557682e1a3bfd55612974164"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class stir::VectorWithOffset&lt; T &gt;</h3>

<p>A templated class for vectors, but with indices starting not from 0. </p>
<p>Elements are guaranteed to be stored contiguously. (Emergency) methods are provided for accessing the data via a <code>T*</code>.</p>
<p>This class tries to mimic std::vector for the most common methods, but it is much more conservative in its memory allocations. The only memory that is allocated is what you asked for (although the allocated memory hardly ever shrinks, except when calling <a class="el" href="classstir_1_1VectorWithOffset.html#ac191bacb3ad44a3fd32b794c96a5f819" title="Free all memory and make object as if default-constructed. ">recycle()</a>). So, std::vector::push_back() etc are not provided, as they would be horribly inefficient for the current class (ok, except if you would have called <a class="el" href="classstir_1_1VectorWithOffset.html#a737237fe3ff32e3f6da2f0463e414a32" title="make the allocated range at least from min_index to max_index ">reserve()</a> first).</p>
<p>It is possible to construct a <a class="el" href="classstir_1_1VectorWithOffset.html" title="A templated class for vectors, but with indices starting not from 0. ">VectorWithOffset</a> that uses existing memory. It will then never deallocate that memory obviously. Note that when growing the vector (or assigning a bigger vector), the vector will allocate new memory. Any modifications to the vector then will no longer be connected to the original data block. This can always be tested using <a class="el" href="classstir_1_1VectorWithOffset.html#a68696b46943dfbd63124b3287bad24d6" title="check if this object owns the memory for the data ">owns_memory_for_data()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This class does not satisfy full Container requirements. </dd>
<dd>
Current implementation relies on shifting a <code>T*</code> outside the range of allocated data. This is not guaranteed to be valid by ANSI C++. It is fine however as long as the <code>min_index</code> is negative and such that <code>abs(min_index)</code> is smaller than <code>max_index</code>. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000159">Todo:</a></b></dt><dd>add allocator template as in std::vector. This is non-trivial as we would have to use uninitialized_copy etc. in some places. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa8e4459a7c7d929ec347bcc4311793dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e4459a7c7d929ec347bcc4311793dc">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classstir_1_1VectorWithOffset.html">stir::VectorWithOffset</a>&lt; T &gt;::<a class="el" href="classstir_1_1VectorWithOffset.html#aa8e4459a7c7d929ec347bcc4311793dc">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Most of these should really not be needed because we use boost::iterator_adaptor now. However, some are used directly in STIR code. (Maybe they shouldn't....) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac191bacb3ad44a3fd32b794c96a5f819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac191bacb3ad44a3fd32b794c96a5f819">&#9670;&nbsp;</a></span>recycle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstir_1_1VectorWithOffset.html">stir::VectorWithOffset</a>&lt; T &gt;::recycle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free all memory and make object as if default-constructed. </p>
<p>This is not the same as resize(0), as the latter does not deallocate the memory (i.e. does not change the <a class="el" href="classstir_1_1VectorWithOffset.html#a407ea687fe151421552cfd591ff8db81" title="get allocated size ">capacity()</a>). </p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1SeparableGaussianArrayFilter.html#acd2467607703d27c0359a2cf020fab05">stir::SeparableGaussianArrayFilter&lt; num_dimensions, elemT &gt;::SeparableGaussianArrayFilter()</a>.</p>

</div>
</div>
<a id="a9179fdbe02bc4cb22fde51599537e2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9179fdbe02bc4cb22fde51599537e2b5">&#9670;&nbsp;</a></span>get_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstir_1_1VectorWithOffset.html">stir::VectorWithOffset</a>&lt; T &gt;::get_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return number of elements in this vector </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Use <a class="el" href="classstir_1_1VectorWithOffset.html#aec5c52350ad01a1b87d03c85a0eb0060" title="return number of elements in this vector ">size()</a> instead. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classstir_1_1ArrayFilter1DUsingConvolutionSymmetricKernel.html#a45877ecba48e0ded95eedae05c2540a2">stir::ArrayFilter1DUsingConvolutionSymmetricKernel&lt; elemT &gt;::ArrayFilter1DUsingConvolutionSymmetricKernel()</a>, <a class="el" href="classstir_1_1QuadraticPrior.html#a5dc50b7f8caf38874c0d8610950822a7">stir::QuadraticPrior&lt; float &gt;::compute_gradient()</a>, <a class="el" href="classstir_1_1QuadraticPrior.html#ace819eb248600e65ce6347a0e3c14084">stir::QuadraticPrior&lt; float &gt;::compute_Hessian()</a>, <a class="el" href="classstir_1_1QuadraticPrior.html#a6f6ad894c01b826c2846e9255d6b8ff1">stir::QuadraticPrior&lt; float &gt;::compute_value()</a>, <a class="el" href="classstir_1_1ArrayFilter1DUsingConvolutionSymmetricKernel.html#ad14c1c24430343fed7e37004a8edcc62">stir::ArrayFilter1DUsingConvolutionSymmetricKernel&lt; elemT &gt;::is_trivial()</a>, <a class="el" href="classstir_1_1ArrayFilter1DUsingConvolution.html#a8717fff151c9c76e7daa4cfe45e0e3a8">stir::ArrayFilter1DUsingConvolution&lt; elemT &gt;::is_trivial()</a>, <a class="el" href="namespacestir.html#a393dc726c87c1c9872a2ce19c4535eaf">stir::make_det_pair_data()</a>, <a class="el" href="classstir_1_1QuadraticPrior.html#ae95158d59c032a23cf29566455aa4394">stir::QuadraticPrior&lt; float &gt;::parabolic_surrogate_curvature()</a>, <a class="el" href="classstir_1_1ProjDataInfoCylindrical.html#a480daa46e80e5919615937c31b25260d">stir::ProjDataInfoCylindrical::ProjDataInfoCylindrical()</a>, and <a class="el" href="namespacestir.html#a7d4bf01dc3ff997b598b5fc5ec3ae0d5">stir::truncate_end_planes()</a>.</p>

</div>
</div>
<a id="a38df200757ae21edbf5dcc495b0e63d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38df200757ae21edbf5dcc495b0e63d4">&#9670;&nbsp;</a></span>grow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classstir_1_1VectorWithOffset.html">stir::VectorWithOffset</a>&lt; T &gt;::grow </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>min_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>grow the range of the vector, new elements are set to <code>T()</code> </p>
<p>Currently, it is only checked with assert() if old range is a subinterval of the new range.</p>
<p><a class="el" href="classstir_1_1VectorWithOffset.html#a38df200757ae21edbf5dcc495b0e63d4" title="grow the range of the vector, new elements are set to T() ">grow()</a> currently simply calls <a class="el" href="classstir_1_1VectorWithOffset.html#aed0410b14fbc21f5b11632738dbca877" title="change the range of the vector, new elements are set to T() ">resize()</a>. However, if you overload <a class="el" href="classstir_1_1VectorWithOffset.html#aed0410b14fbc21f5b11632738dbca877" title="change the range of the vector, new elements are set to T() ">resize()</a> in a derived class, it is probably safest to overload <a class="el" href="classstir_1_1VectorWithOffset.html#a38df200757ae21edbf5dcc495b0e63d4" title="grow the range of the vector, new elements are set to T() ">grow()</a> as well. </p>

<p>Reimplemented in <a class="el" href="classstir_1_1Array_3_011_00_01elemT_01_4.html#a61f8a49fd674b7340dc5707545048370">stir::Array&lt; 1, elemT &gt;</a>.</p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1ArrayFilter1DUsingConvolutionSymmetricKernel.html#ad14c1c24430343fed7e37004a8edcc62">stir::ArrayFilter1DUsingConvolutionSymmetricKernel&lt; elemT &gt;::is_trivial()</a>, <a class="el" href="namespacestir.html#a393dc726c87c1c9872a2ce19c4535eaf">stir::make_det_pair_data()</a>, and <a class="el" href="classstir_1_1SeparableGaussianArrayFilter.html#acd2467607703d27c0359a2cf020fab05">stir::SeparableGaussianArrayFilter&lt; num_dimensions, elemT &gt;::SeparableGaussianArrayFilter()</a>.</p>

</div>
</div>
<a id="aed0410b14fbc21f5b11632738dbca877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0410b14fbc21f5b11632738dbca877">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classstir_1_1VectorWithOffset.html">stir::VectorWithOffset</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>min_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>change the range of the vector, new elements are set to <code>T()</code> </p>
<p>New memory is allocated if the range grows outside the range specified by <a class="el" href="classstir_1_1VectorWithOffset.html#acd11c494f2c0ce80781004068ba705fb" title="get min_index within allocated range ">get_capacity_min_index()</a> till <a class="el" href="classstir_1_1VectorWithOffset.html#abbc49c87e5bee68fac33646558001bb8" title="get max_index within allocated range ">get_capacity_max_index()</a>. Data is then copied and old memory deallocated (unless <a class="el" href="classstir_1_1VectorWithOffset.html#a68696b46943dfbd63124b3287bad24d6" title="check if this object owns the memory for the data ">owns_memory_for_data()</a> is false).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000160">Todo:</a></b></dt><dd>in principle reallocation could be avoided when the new range would fit in the old one by shifting. </dd></dl>

<p>Reimplemented in <a class="el" href="classstir_1_1Array_3_011_00_01elemT_01_4.html#a64ab96d84eb305ad7e723ddd5e958803">stir::Array&lt; 1, elemT &gt;</a>.</p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1IOTests__ParametricDiscretisedDensity.html#aafed383820a9ae586ee04dd6d088ee6b">stir::IOTests_ParametricDiscretisedDensity::create_image()</a>, <a class="el" href="group__projdata.html#ga6ca5b8f25160eda3d22c15a7dfa64a5e">stir::get_scale_factors_per_sinogram()</a>, <a class="el" href="classstir_1_1ScatterSimulation.html#a8bed3211dee815fef24e0eed74a9db35">stir::ScatterSimulation::initialise_cache_for_scattpoint_det_integrals_over_activity()</a>, <a class="el" href="classstir_1_1ScatterSimulation.html#ad64dc03896944736f0b4244211ea81d1">stir::ScatterSimulation::initialise_cache_for_scattpoint_det_integrals_over_attenuation()</a>, <a class="el" href="classstir_1_1ProjDataInfoCylindrical.html#a480daa46e80e5919615937c31b25260d">stir::ProjDataInfoCylindrical::ProjDataInfoCylindrical()</a>, and <a class="el" href="classstir_1_1ScatterEstimation.html#ace6b465e634d39ff125681d5b384d1bd">stir::ScatterEstimation::upsample_and_fit_scatter_estimate()</a>.</p>

</div>
</div>
<a id="a68696b46943dfbd63124b3287bad24d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68696b46943dfbd63124b3287bad24d6">&#9670;&nbsp;</a></span>owns_memory_for_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstir_1_1VectorWithOffset.html">stir::VectorWithOffset</a>&lt; T &gt;::owns_memory_for_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if this object owns the memory for the data </p>
<p>Will be false if one of the constructors is used that passes in a data block. </p>

</div>
</div>
<a id="acd11c494f2c0ce80781004068ba705fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd11c494f2c0ce80781004068ba705fb">&#9670;&nbsp;</a></span>get_capacity_min_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstir_1_1VectorWithOffset.html">stir::VectorWithOffset</a>&lt; T &gt;::get_capacity_min_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get min_index within allocated range </p>
<p>This value depends on <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa" title="get value of first valid index ">get_min_index()</a> and hence will change after calling <a class="el" href="classstir_1_1VectorWithOffset.html#a9fd415055b8ff81ace8cbf1c54a65350" title="identical to set_offset() ">set_min_index()</a>.</p>
<p>For a vector of 0 length, this function returns 0. </p>

</div>
</div>
<a id="abbc49c87e5bee68fac33646558001bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc49c87e5bee68fac33646558001bb8">&#9670;&nbsp;</a></span>get_capacity_max_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classstir_1_1VectorWithOffset.html">stir::VectorWithOffset</a>&lt; T &gt;::get_capacity_max_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get max_index within allocated range </p>
<p>This value depends on <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa" title="get value of first valid index ">get_min_index()</a> and hence will change after calling <a class="el" href="classstir_1_1VectorWithOffset.html#a9fd415055b8ff81ace8cbf1c54a65350" title="identical to set_offset() ">set_min_index()</a>.</p>
<p>For a vector of 0 length, this function returns <a class="el" href="classstir_1_1VectorWithOffset.html#a407ea687fe151421552cfd591ff8db81" title="get allocated size ">capacity()</a>-1. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/sirfuser/devel/STIRdistrib/STIR/src/include/stir/<a class="el" href="ArrayFilter1DUsingConvolution_8h_source.html">ArrayFilter1DUsingConvolution.h</a></li>
<li>/home/sirfuser/devel/STIRdistrib/STIR/src/include/stir/<a class="el" href="VectorWithOffset_8h_source.html">VectorWithOffset.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 22 2020 09:05:33 for STIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
