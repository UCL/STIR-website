<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STIR: Numerical algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STIR
   &#160;<span id="projectnumber">6.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Numerical algorithms<div class="ingroups"><a class="el" href="group__STIR.html">STIR</a> &raquo; <a class="el" href="group__STIR__library.html">STIR library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Numerical algorithms:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__numerics.png" border="0" alt="" usemap="#group____numerics"/>
<map name="group____numerics" id="group____numerics">
<area shape="rect" id="node1" href="group__BSpline.html" title="Classes and functions\l for B&#45;spline interpolation." alt="" coords="382,5,553,47"/>
<area shape="rect" id="node2" href="group__STIR__library.html" title="STIR library" alt="" coords="5,130,97,157"/>
<area shape="rect" id="node3" href="group__DFT.html" title="Discrete Fourier transforms" alt="" coords="377,71,558,98"/>
<area shape="rect" id="node4" href="group__test.html" title="Tests of the basic\l building blocks" alt="" coords="404,123,531,164"/>
<area shape="rect" id="node6" href="group__distributable.html" title="distributable building\l blocks" alt="" coords="397,188,537,229"/>
<area shape="rect" id="node7" href="group__ancillary.html" title="Items related to ancillary\l information such as radionuclide,\l patient info etc" alt="" coords="359,254,576,310"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__DFT"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DFT.html">Discrete Fourier transforms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__BSpline"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BSpline.html">Classes and functions for B-spline interpolation.</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:determinant_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="determinant_8h.html">determinant.h</a></td></tr>
<tr class="memdesc:determinant_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of <a class="el" href="group__numerics.html#ga8de80007a01f8e495d0ee8d87280f1c4" title="Compute the determinant of a matrix. ">stir::determinant()</a> function for matrices. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:divide_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="divide_8h.html">divide.h</a></td></tr>
<tr class="memdesc:divide_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of <a class="el" href="group__numerics.html#ga2135eeda219aa6700b50580389a12771" title="division of two ranges, 0/0 = 0 ">stir::divide</a> <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:divide_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="divide_8inl.html">divide.inl</a></td></tr>
<tr class="memdesc:divide_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of <a class="el" href="group__numerics.html#ga2135eeda219aa6700b50580389a12771" title="division of two ranges, 0/0 = 0 ">stir::divide</a> <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:erf_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="erf_8h.html">erf.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:FastErf_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FastErf_8h.html">FastErf.h</a></td></tr>
<tr class="memdesc:FastErf_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of an erf interpolation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:FastErf_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FastErf_8inl.html">FastErf.inl</a></td></tr>
<tr class="memdesc:FastErf_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of an erf interpolation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ieeefp_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ieeefp_8h.html">ieeefp.h</a></td></tr>
<tr class="memdesc:ieeefp_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of work-around macros STIR_isnan and STIR_finite for a few non-portable IEEE floating point functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:integrate__discrete__function_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="integrate__discrete__function_8h.html">integrate_discrete_function.h</a></td></tr>
<tr class="memdesc:integrate__discrete__function_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of <a class="el" href="group__numerics.html#gae4be7a4f83838ee58c1b9b6b01f10f0c" title="numerical integration of a 1D functionThis is a simple integral implementation using rectangular (=0)...">stir::integrate_discrete_function</a> function. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:IR__filters_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IR__filters_8h.html">IR_filters.h</a></td></tr>
<tr class="memdesc:IR__filters_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the IIR and FIR filters. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:IR__filters_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IR__filters_8inl.html">IR_filters.inl</a></td></tr>
<tr class="memdesc:IR__filters_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements the IR_filters <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:MatrixFunction_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MatrixFunction_8h.html">MatrixFunction.h</a></td></tr>
<tr class="memdesc:MatrixFunction_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of functions for matrices. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:MatrixFunction_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MatrixFunction_8inl.html">MatrixFunction.inl</a></td></tr>
<tr class="memdesc:MatrixFunction_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of functions for matrices. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:max__eigenvector_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="max__eigenvector_8h.html">max_eigenvector.h</a></td></tr>
<tr class="memdesc:max__eigenvector_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of functions for computing eigenvectors. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:norm_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="norm_8h.html">norm.h</a></td></tr>
<tr class="memdesc:norm_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of the <a class="el" href="group__Coordinate.html#ga4770b3db3002116b144d80af7afdef39" title="compute sqrt(inner_product(p1,p1)) ">stir::norm()</a>, <a class="el" href="group__Coordinate.html#ga5d087edb9c8d2db898c61f64cbdcc846" title="compute (inner_product(p1,p1)) ">stir::norm_squared()</a> functions and <a class="el" href="structstir_1_1NormSquared.html" title="A helper class that computes the square of the norm of numeric data. ">stir::NormSquared</a> unary function. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:norm_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="norm_8inl.html">norm.inl</a></td></tr>
<tr class="memdesc:norm_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <a class="el" href="group__Coordinate.html#ga4770b3db3002116b144d80af7afdef39" title="compute sqrt(inner_product(p1,p1)) ">stir::norm()</a>, <a class="el" href="group__Coordinate.html#ga5d087edb9c8d2db898c61f64cbdcc846" title="compute (inner_product(p1,p1)) ">stir::norm_squared()</a> functions and <a class="el" href="structstir_1_1NormSquared.html" title="A helper class that computes the square of the norm of numeric data. ">stir::NormSquared</a> unary function. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:overlap__interpolate_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="overlap__interpolate_8h.html">overlap_interpolate.h</a></td></tr>
<tr class="memdesc:overlap__interpolate_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of <a class="el" href="group__numerics.html#gae67e702dedcca1a7d8427e1a0590797b" title="&#39;overlap&#39; interpolation (i.e. count preserving) for vectors. ">stir::overlap_interpolate</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:overlap__interpolate_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="overlap__interpolate_8inl.html">overlap_interpolate.inl</a></td></tr>
<tr class="memdesc:overlap__interpolate_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of inline versions of <a class="el" href="group__numerics.html#gae67e702dedcca1a7d8427e1a0590797b" title="&#39;overlap&#39; interpolation (i.e. count preserving) for vectors. ">stir::overlap_interpolate</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sampling__functions_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sampling__functions_8h.html">sampling_functions.h</a></td></tr>
<tr class="memdesc:sampling__functions_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampling functions (currently only <a class="el" href="group__numerics.html#ga3d41e73fca815d036389b83d7eda9584" title="Generic function to get the values of a 3D function on a regular grid. ">stir::sample_function_on_regular_grid</a>) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:stir__NumericalRecipes_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stir__NumericalRecipes_8h.html">stir_NumericalRecipes.h</a></td></tr>
<tr class="memdesc:stir__NumericalRecipes_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">functions to convert from data in Numerical Recipes format to STIR arrays. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:linear__extrapolation_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linear__extrapolation_8h.html">linear_extrapolation.h</a></td></tr>
<tr class="memdesc:linear__extrapolation_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">stir::linear_extrapolation <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:more__interpolators_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="more__interpolators_8h.html">more_interpolators.h</a></td></tr>
<tr class="memdesc:more__interpolators_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to interpolate data. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:more__interpolators_8inl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="more__interpolators_8inl.html">more_interpolators.inl</a></td></tr>
<tr class="memdesc:more__interpolators_8inl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to interpolate data. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:determinant_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="determinant_8cxx.html">determinant.cxx</a></td></tr>
<tr class="memdesc:determinant_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__numerics.html#ga8de80007a01f8e495d0ee8d87280f1c4" title="Compute the determinant of a matrix. ">stir::determinant()</a> function for matrices. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacestir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestir.html">stir</a></td></tr>
<tr class="memdesc:namespacestir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the STIR library (and some/most of its applications) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1PullLinearInterpolator.html">stir::PullLinearInterpolator&lt; elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function object to pull interpolated values from the input array into the grid points of the output array.  <a href="classstir_1_1PullLinearInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1PushTransposeLinearInterpolator.html">stir::PushTransposeLinearInterpolator&lt; elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function object to push values at the grid of the input array into the output array.  <a href="classstir_1_1PushTransposeLinearInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1PullNearestNeighbourInterpolator.html">stir::PullNearestNeighbourInterpolator&lt; elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function object to pull interpolated values from the input array into the grid points of the output array.  <a href="classstir_1_1PullNearestNeighbourInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1PushNearestNeighbourInterpolator.html">stir::PushNearestNeighbourInterpolator&lt; elemT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function object to push values at the grid of the input array into the output array.  <a href="classstir_1_1PushNearestNeighbourInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8de80007a01f8e495d0ee8d87280f1c4"><td class="memTemplParams" colspan="2">template&lt;class elemT &gt; </td></tr>
<tr class="memitem:ga8de80007a01f8e495d0ee8d87280f1c4"><td class="memTemplItemLeft" align="right" valign="top">elemT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#ga8de80007a01f8e495d0ee8d87280f1c4">stir::determinant</a> (const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 2, elemT &gt; &amp;m)</td></tr>
<tr class="memdesc:ga8de80007a01f8e495d0ee8d87280f1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of a matrix.  <a href="group__numerics.html#ga8de80007a01f8e495d0ee8d87280f1c4">More...</a><br /></td></tr>
<tr class="separator:ga8de80007a01f8e495d0ee8d87280f1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2135eeda219aa6700b50580389a12771"><td class="memTemplParams" colspan="2">template&lt;class NumeratorIterT , class DenominatorIterT , class small_numT &gt; </td></tr>
<tr class="memitem:ga2135eeda219aa6700b50580389a12771"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#ga2135eeda219aa6700b50580389a12771">stir::divide</a> (const NumeratorIterT &amp;numerator_begin, const NumeratorIterT &amp;numerator_end, const DenominatorIterT &amp;denominator_begin, const small_numT small_num)</td></tr>
<tr class="memdesc:ga2135eeda219aa6700b50580389a12771"><td class="mdescLeft">&#160;</td><td class="mdescRight">division of two ranges, 0/0 = 0  <a href="group__numerics.html#ga2135eeda219aa6700b50580389a12771">More...</a><br /></td></tr>
<tr class="separator:ga2135eeda219aa6700b50580389a12771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4be7a4f83838ee58c1b9b6b01f10f0c"><td class="memTemplParams" colspan="2">template&lt;typename elemT &gt; </td></tr>
<tr class="memitem:gae4be7a4f83838ee58c1b9b6b01f10f0c"><td class="memTemplItemLeft" align="right" valign="top">elemT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#gae4be7a4f83838ee58c1b9b6b01f10f0c">stir::integrate_discrete_function</a> (const std::vector&lt; elemT &gt; &amp;coordinates, const std::vector&lt; elemT &gt; &amp;values, const int interpolation_order=1)</td></tr>
<tr class="memdesc:gae4be7a4f83838ee58c1b9b6b01f10f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">numerical integration of a 1D functionThis is a simple integral implementation using rectangular (=0) or trapezoidal (=1) approximation. It currently integrates over the complete range specified.  <a href="group__numerics.html#gae4be7a4f83838ee58c1b9b6b01f10f0c">More...</a><br /></td></tr>
<tr class="separator:gae4be7a4f83838ee58c1b9b6b01f10f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf89fe263ca8190c22691680019d27425"><td class="memTemplParams" colspan="2">template&lt;class elemT &gt; </td></tr>
<tr class="memitem:gaf89fe263ca8190c22691680019d27425"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#gaf89fe263ca8190c22691680019d27425">stir::absolute_max_eigenvector_using_power_method</a> (elemT &amp;max_eigenvalue, <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;max_eigenvector, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 2, elemT &gt; &amp;m, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;start, const double tolerance=.01, const unsigned long max_num_iterations=10000UL)</td></tr>
<tr class="memdesc:gaf89fe263ca8190c22691680019d27425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalue with the largest absolute value and corresponding eigenvector of a matrix by using the power method.  <a href="group__numerics.html#gaf89fe263ca8190c22691680019d27425">More...</a><br /></td></tr>
<tr class="separator:gaf89fe263ca8190c22691680019d27425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f8b20733c8815ede894044aa71ef5e"><td class="memTemplParams" colspan="2">template&lt;class elemT &gt; </td></tr>
<tr class="memitem:ga25f8b20733c8815ede894044aa71ef5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#ga25f8b20733c8815ede894044aa71ef5e">stir::absolute_max_eigenvector_using_shifted_power_method</a> (elemT &amp;max_eigenvalue, <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;max_eigenvector, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 2, elemT &gt; &amp;m, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;start, const elemT shift, const double tolerance=.03, const unsigned long max_num_iterations=10000UL)</td></tr>
<tr class="memdesc:ga25f8b20733c8815ede894044aa71ef5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalue with the largest absolute value and corresponding eigenvector of a matrix by using the shifted power method.  <a href="group__numerics.html#ga25f8b20733c8815ede894044aa71ef5e">More...</a><br /></td></tr>
<tr class="separator:ga25f8b20733c8815ede894044aa71ef5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37432709a9e70ddd8b94d65f0e82e4f7"><td class="memTemplParams" colspan="2">template&lt;class elemT &gt; </td></tr>
<tr class="memitem:ga37432709a9e70ddd8b94d65f0e82e4f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#ga37432709a9e70ddd8b94d65f0e82e4f7">stir::max_eigenvector_using_power_method</a> (elemT &amp;max_eigenvalue, <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;max_eigenvector, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 2, elemT &gt; &amp;m, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;start, const double tolerance=.03, const unsigned long max_num_iterations=10000UL)</td></tr>
<tr class="memdesc:ga37432709a9e70ddd8b94d65f0e82e4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalue with the largest value and corresponding eigenvector of a matrix by using the power method.  <a href="group__numerics.html#ga37432709a9e70ddd8b94d65f0e82e4f7">More...</a><br /></td></tr>
<tr class="separator:ga37432709a9e70ddd8b94d65f0e82e4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae67e702dedcca1a7d8427e1a0590797b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae67e702dedcca1a7d8427e1a0590797b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#gae67e702dedcca1a7d8427e1a0590797b">stir::overlap_interpolate</a> (<a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&lt; T &gt; &amp;out_data, const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&lt; T &gt; &amp;in_data, const float zoom, const float offset, const bool assign_rest_with_zeroes=true)</td></tr>
<tr class="memdesc:gae67e702dedcca1a7d8427e1a0590797b"><td class="mdescLeft">&#160;</td><td class="mdescRight">'overlap' interpolation (i.e. count preserving) for vectors.  <a href="group__numerics.html#gae67e702dedcca1a7d8427e1a0590797b">More...</a><br /></td></tr>
<tr class="separator:gae67e702dedcca1a7d8427e1a0590797b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga102332ccbd16abe782b51031a7d18913"><td class="memTemplParams" colspan="2">template&lt;typename out_iter_t , typename out_coord_iter_t , typename in_iter_t , typename in_coord_iter_t &gt; </td></tr>
<tr class="memitem:ga102332ccbd16abe782b51031a7d18913"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#ga102332ccbd16abe782b51031a7d18913">stir::overlap_interpolate</a> (const out_iter_t out_begin, const out_iter_t out_end, const out_coord_iter_t out_coord_begin, const out_coord_iter_t out_coord_end, const in_iter_t in_begin, in_iter_t in_end, const in_coord_iter_t in_coord_begin, const in_coord_iter_t in_coord_end, const bool only_add_to_output=false, const bool assign_rest_with_zeroes=true)</td></tr>
<tr class="memdesc:ga102332ccbd16abe782b51031a7d18913"><td class="mdescLeft">&#160;</td><td class="mdescRight">'overlap' interpolation for iterators, with arbitrary 'bin' sizes.  <a href="group__numerics.html#ga102332ccbd16abe782b51031a7d18913">More...</a><br /></td></tr>
<tr class="separator:ga102332ccbd16abe782b51031a7d18913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d41e73fca815d036389b83d7eda9584"><td class="memTemplParams" colspan="2">template&lt;class FunctionType , class elemT , class positionT &gt; </td></tr>
<tr class="memitem:ga3d41e73fca815d036389b83d7eda9584"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#ga3d41e73fca815d036389b83d7eda9584">stir::sample_function_on_regular_grid</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, elemT &gt; &amp;out, FunctionType func, const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, positionT &gt; &amp;offset, const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, positionT &gt; &amp;step)</td></tr>
<tr class="memdesc:ga3d41e73fca815d036389b83d7eda9584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function to get the values of a 3D function on a regular grid.  <a href="group__numerics.html#ga3d41e73fca815d036389b83d7eda9584">More...</a><br /></td></tr>
<tr class="separator:ga3d41e73fca815d036389b83d7eda9584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga549f9e20e437106d1d66219e5386100b"><td class="memTemplParams" colspan="2">template&lt;typename elemT , typename FunctionType , typename Lambda &gt; </td></tr>
<tr class="memitem:ga549f9e20e437106d1d66219e5386100b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#ga549f9e20e437106d1d66219e5386100b">stir::sample_function_using_index_converter</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, elemT &gt; &amp;out, FunctionType func, Lambda &amp;&amp;index_converter)</td></tr>
<tr class="memdesc:ga549f9e20e437106d1d66219e5386100b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function to get the values of a 3D function on a grid.  <a href="group__numerics.html#ga549f9e20e437106d1d66219e5386100b">More...</a><br /></td></tr>
<tr class="separator:ga549f9e20e437106d1d66219e5386100b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ea1b16f83a5ee1fe9e13a0fe906f191"><td class="memTemplParams" colspan="2">template&lt;class elemT , class positionT &gt; </td></tr>
<tr class="memitem:ga7ea1b16f83a5ee1fe9e13a0fe906f191"><td class="memTemplItemLeft" align="right" valign="top">elemT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#ga7ea1b16f83a5ee1fe9e13a0fe906f191">stir::pull_nearest_neighbour_interpolate</a> (const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, elemT &gt; &amp;in, const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, positionT &gt; &amp;point_in_input_coords)</td></tr>
<tr class="memdesc:ga7ea1b16f83a5ee1fe9e13a0fe906f191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull <em>value</em> from the input array using nearest neigbour interpolation.  <a href="group__numerics.html#ga7ea1b16f83a5ee1fe9e13a0fe906f191">More...</a><br /></td></tr>
<tr class="separator:ga7ea1b16f83a5ee1fe9e13a0fe906f191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga687c7b6806d9f144e778de54ca689a2f"><td class="memTemplParams" colspan="2">template&lt;int num_dimensions, class elemT , class positionT , class valueT &gt; </td></tr>
<tr class="memitem:ga687c7b6806d9f144e778de54ca689a2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#ga687c7b6806d9f144e778de54ca689a2f">stir::push_nearest_neighbour_interpolate</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp;out, const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; num_dimensions, positionT &gt; &amp;point_in_output_coords, valueT value)</td></tr>
<tr class="memdesc:ga687c7b6806d9f144e778de54ca689a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push <em>value</em> into the output array using nearest neigbour interpolation.  <a href="group__numerics.html#ga687c7b6806d9f144e778de54ca689a2f">More...</a><br /></td></tr>
<tr class="separator:ga687c7b6806d9f144e778de54ca689a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d64047f77525dc4ebc7beea989ce291"><td class="memTemplParams" colspan="2"><a id="ga1d64047f77525dc4ebc7beea989ce291"></a>
template&lt;class elemT , class positionT &gt; </td></tr>
<tr class="memitem:ga1d64047f77525dc4ebc7beea989ce291"><td class="memTemplItemLeft" align="right" valign="top">elemT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#ga1d64047f77525dc4ebc7beea989ce291">stir::pull_linear_interpolate</a> (const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, elemT &gt; &amp;in, const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, positionT &gt; &amp;point_in_input_coords)</td></tr>
<tr class="memdesc:ga1d64047f77525dc4ebc7beea989ce291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an interpolated value according to <em>point_in_input_coords</em>. <br /></td></tr>
<tr class="separator:ga1d64047f77525dc4ebc7beea989ce291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d9a302ef1f558d83c26470a5572ad0"><td class="memTemplParams" colspan="2"><a id="ga48d9a302ef1f558d83c26470a5572ad0"></a>
template&lt;class elemT , class positionT , class valueT &gt; </td></tr>
<tr class="memitem:ga48d9a302ef1f558d83c26470a5572ad0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#ga48d9a302ef1f558d83c26470a5572ad0">stir::push_transpose_linear_interpolate</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, elemT &gt; &amp;out, const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, positionT &gt; &amp;point_in_output_coords, valueT value)</td></tr>
<tr class="memdesc:ga48d9a302ef1f558d83c26470a5572ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push <em>value</em> into the output array using the transpose of linear interpolation. <br /></td></tr>
<tr class="separator:ga48d9a302ef1f558d83c26470a5572ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80041a7f116159124e16bb749b993813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__numerics.html#ga80041a7f116159124e16bb749b993813">stir::extend_segment</a> (const <a class="el" href="classstir_1_1SegmentBySinogram.html">SegmentBySinogram</a>&lt; float &gt; &amp;segment, const int view_extension=5, const int axial_extension=5, const int tangential_extension=5)</td></tr>
<tr class="memdesc:ga80041a7f116159124e16bb749b993813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension of direct projection data.  <a href="group__numerics.html#ga80041a7f116159124e16bb749b993813">More...</a><br /></td></tr>
<tr class="separator:ga80041a7f116159124e16bb749b993813"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
functions specific for 1D Arrays</h2></td></tr>
<tr class="memitem:gac1b6c0fcc71e04a15917f95760eb0d4e"><td class="memTemplParams" colspan="2">template&lt;class elemT &gt; </td></tr>
<tr class="memitem:gac1b6c0fcc71e04a15917f95760eb0d4e"><td class="memTemplItemLeft" align="right" valign="top">elemT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#gac1b6c0fcc71e04a15917f95760eb0d4e">stir::inner_product</a> (const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;v1, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;v2)</td></tr>
<tr class="memdesc:gac1b6c0fcc71e04a15917f95760eb0d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner product of 2 1D arrays.  <a href="group__numerics.html#gac1b6c0fcc71e04a15917f95760eb0d4e">More...</a><br /></td></tr>
<tr class="separator:gac1b6c0fcc71e04a15917f95760eb0d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab81c63526659055d87aeb3493f065f8b"><td class="memTemplParams" colspan="2"><a id="gab81c63526659055d87aeb3493f065f8b"></a>
template&lt;class elemT &gt; </td></tr>
<tr class="memitem:gab81c63526659055d87aeb3493f065f8b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__numerics.html#gab81c63526659055d87aeb3493f065f8b">stir::angle</a> (const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;v1, const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;v2)</td></tr>
<tr class="memdesc:gab81c63526659055d87aeb3493f065f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">angle between 2 1D arrays <br /></td></tr>
<tr class="separator:gab81c63526659055d87aeb3493f065f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga80041a7f116159124e16bb749b993813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80041a7f116159124e16bb749b993813">&#9670;&nbsp;</a></span>extend_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, float &gt; stir::extend_segment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1SegmentBySinogram.html">SegmentBySinogram</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>view_extension</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>axial_extension</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>tangential_extension</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extension of direct projection data. </p>
<p>Functions that extend the given sinogram or segment in the view direction taking periodicity into account, if exists. If the sinogram is not symmetric in tangential position, the values are extrapolated by nearest neighbour known values.</p>
<p>This is probably only useful before calling interpolation routines, or for FORE.</p>
<p>Generic function to extend a segment in any or all directions. Axially and tangentially, the segment is filled with the nearest existing value. In view direction, the function wraps around for <a class="el" href="classstir_1_1ProjData.html" title="The (abstract) base class for the projection data. ">stir::ProjData</a> that cover 180° or 360° degrees, and throws an error for other angular coverages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">segment</td><td>segment to be extended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">view_extension</td><td>how many views to add either side of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axial_extension</td><td>how many axial bins to add either side of the segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tangential_extension</td><td>how many tangential bins to add either side of the segment </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__buildblock.html#ga583ed7652f3528c16157897a96203bfd">_PI</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#a23a3bcc84639216e608406803d98f14e">stir::VectorWithOffset&lt; Array&lt; num_dimensions - 1, elemT &gt; &gt;::get_max_index()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">stir::VectorWithOffset&lt; Array&lt; num_dimensions - 1, elemT &gt; &gt;::get_min_index()</a>, <a class="el" href="classstir_1_1Segment.html#ad042b71f7e146af0b634f55b6823c577">stir::Segment&lt; elemT &gt;::get_proj_data_info_sptr()</a>, and <a class="el" href="classstir_1_1Array.html#a65d8d70124654379b1bc507829e14b67">stir::Array&lt; num_dimensions, elemT &gt;::grow()</a>.</p>

</div>
</div>
<a id="ga8de80007a01f8e495d0ee8d87280f1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8de80007a01f8e495d0ee8d87280f1c4">&#9670;&nbsp;</a></span>determinant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class elemT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">elemT stir::determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 2, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the determinant of a matrix. </p>
<p>Matrix indices can start from any number.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000107">Todo:</a></b></dt><dd>Only works for low dimensions for now. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classstir_1_1Shape3DWithOrientation.html#ae4feb24b76a3619e4457ddb21a7ea890">stir::Shape3DWithOrientation::get_volume_of_unit_cell()</a>.</p>

</div>
</div>
<a id="ga2135eeda219aa6700b50580389a12771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2135eeda219aa6700b50580389a12771">&#9670;&nbsp;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NumeratorIterT , class DenominatorIterT , class small_numT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::divide </td>
          <td>(</td>
          <td class="paramtype">const NumeratorIterT &amp;&#160;</td>
          <td class="paramname"><em>numerator_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumeratorIterT &amp;&#160;</td>
          <td class="paramname"><em>numerator_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenominatorIterT &amp;&#160;</td>
          <td class="paramname"><em>denominator_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const small_numT&#160;</td>
          <td class="paramname"><em>small_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>division of two ranges, 0/0 = 0 </p>
<p>This function sets 0/0 to 0 (not the usual NaN). It is for instance useful in Poisson log-likelihood computation.</p>
<p>Because of potential numerical rounding problems, we test if a number is 0 by comparing its absolute value with a small value, which is determined by multiplying the maximum in the <code>numerator</code> range with <em>small_num</em>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function does not test for non-zero numbers by 0. Results in that case will likely depend on your processor and/or compiler settings. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classstir_1_1BinNormalisationPETFromComponents.html#a9bc04167c7743ea33ba5f864be5ee866">stir::BinNormalisationPETFromComponents::apply()</a>, <a class="el" href="classstir_1_1KOSMAPOSLReconstruction.html#a74b1aeff4fbf3a7d949557367c673286">stir::KOSMAPOSLReconstruction&lt; TargetT &gt;::compute_kernelised_image()</a>, and <a class="el" href="classstir_1_1OSMAPOSLReconstruction.html#aba6cfbd054d95fbead2fd68cab40327d">stir::OSMAPOSLReconstruction&lt; TargetT &gt;::update_estimate()</a>.</p>

</div>
</div>
<a id="gae4be7a4f83838ee58c1b9b6b01f10f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4be7a4f83838ee58c1b9b6b01f10f0c">&#9670;&nbsp;</a></span>integrate_discrete_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename elemT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">elemT stir::integrate_discrete_function </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>interpolation_order</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>numerical integration of a 1D functionThis is a simple integral implementation using rectangular (=0) or trapezoidal (=1) approximation. It currently integrates over the complete range specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordinates</td><td>Coordinates at which the function samples are given </td></tr>
    <tr><td class="paramname">values</td><td>Function values </td></tr>
    <tr><td class="paramname">interpolation_order</td><td>has to be 0 or 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Type <code>elemT</code> should not be an integral type. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classstir_1_1PlasmaData.html#a96be0f19043f9c2bd94a13788942e5c2">stir::PlasmaData::get_sample_data_in_frames()</a>, and <a class="el" href="classstir_1_1integrate__discrete__functionTests.html#a00a98bcbff89b9c7c0d8f8f9ee29c6e9">stir::integrate_discrete_functionTests::run_tests()</a>.</p>

</div>
</div>
<a id="gac1b6c0fcc71e04a15917f95760eb0d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1b6c0fcc71e04a15917f95760eb0d4e">&#9670;&nbsp;</a></span>inner_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class elemT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">elemT stir::inner_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inner product of 2 1D arrays. </p>
<p>This returns the sum of multiplication of elements of <em>conjugate(v1)</em> and <em>v2</em>.</p>
<p>Implementation is appropriate for complex numbers.</p>
<p>Arguments must have the same index range. </p>

</div>
</div>
<a id="gaf89fe263ca8190c22691680019d27425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf89fe263ca8190c22691680019d27425">&#9670;&nbsp;</a></span>absolute_max_eigenvector_using_power_method()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class elemT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Succeeded.html">Succeeded</a> stir::absolute_max_eigenvector_using_power_method </td>
          <td>(</td>
          <td class="paramtype">elemT &amp;&#160;</td>
          <td class="paramname"><em>max_eigenvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_eigenvector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 2, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>max_num_iterations</em> = <code>10000UL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the eigenvalue with the largest absolute value and corresponding eigenvector of a matrix by using the power method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">max_eigenvalue</td><td>will be set to the eigenvalue found </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_eigenvector</td><td>will be set to the eigenvector found, and is normalised to 1 (using the l2-norm). The sign choice is determined by normalising the largest element in the eigenvector to 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>is the input matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>is a starting vector for the iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>determines when iterations can stop </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_num_iterations</td><td>is used to prevent an infinite loop</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Succeeded::yes if <em>max_num_iterations</em> was not reached. However, you probably want to check if the norm of the difference between <code>m.max_eigenvector</code> and <code> max_eigenvalue*max_eigenvector</code> is small (compared to max_eigenvalue).</dd></dl>
<p>Computation uses the <em>power</em> method, see for instance <a href="http://www.maths.lth.se/na/courses/FMN050/FMN050-05/eigenE.pdf">http://www.maths.lth.se/na/courses/FMN050/FMN050-05/eigenE.pdf</a>.</p>
<p>The method consists in computing </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[v^{n+1}=m.v^{n}\]" src="form_36.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[v^{n+1}/=\mathrm{norm}(v^{n+1})\]" src="form_37.png"/>
</p>
<p> with <img class="formulaInl" alt="$ v^{0}=\mathrm{start} $" src="form_38.png"/> for <img class="formulaInl" alt="$ n$" src="form_39.png"/> big enough such that <img class="formulaInl" alt="$ \mathrm{norm}(v^{n+1}-v^{n})$" src="form_40.png"/> becomes smaller than <em>tolerance</em>. The eigenvalue is then computed using the Rayleigh quotient </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[v.m.v \over v.v \]" src="form_41.png"/>
</p>
<p>This will converge to the eigenvector which has the largest absolute eigenvalue. The method fails when the matrix has more than 1 largest absolute eigenvalue (e.g. with opposite sign). </p>

<p class="reference">References <a class="el" href="group__buildblock.html#ga41eadff7411db8b2528ab653432c523b">stir::abs_max_element()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#a147a665c5ab7818c5197fac452bcff9b">stir::VectorWithOffset&lt; T &gt;::begin()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#ab5ea6073b3daf75f23f1b545d0b6593f">stir::VectorWithOffset&lt; T &gt;::end()</a>, <a class="el" href="group__Coordinate.html#ga2f556ccc1c78f5ee93aac477d852701a">stir::inner_product()</a>, <a class="el" href="classstir_1_1Array.html#a0c55638d8e5ddd950370b07e3f6eb7f9">stir::Array&lt; num_dimensions, elemT &gt;::is_regular()</a>, <a class="el" href="namespacestir.html#af8da845d01b2f49d54d7cddc2b6d778b">stir::matrix_multiply()</a>, <a class="el" href="group__Coordinate.html#ga4770b3db3002116b144d80af7afdef39">stir::norm()</a>, <a class="el" href="group__Coordinate.html#ga5d087edb9c8d2db898c61f64cbdcc846">stir::norm_squared()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#aec5c52350ad01a1b87d03c85a0eb0060">stir::VectorWithOffset&lt; T &gt;::size()</a>, and <a class="el" href="group__buildblock.html#gac418d503952396274cda09838ccab659">stir::square()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__numerics.html#ga25f8b20733c8815ede894044aa71ef5e">stir::absolute_max_eigenvector_using_shifted_power_method()</a>, and <a class="el" href="group__numerics.html#ga37432709a9e70ddd8b94d65f0e82e4f7">stir::max_eigenvector_using_power_method()</a>.</p>

</div>
</div>
<a id="ga25f8b20733c8815ede894044aa71ef5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25f8b20733c8815ede894044aa71ef5e">&#9670;&nbsp;</a></span>absolute_max_eigenvector_using_shifted_power_method()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class elemT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Succeeded.html">Succeeded</a> stir::absolute_max_eigenvector_using_shifted_power_method </td>
          <td>(</td>
          <td class="paramtype">elemT &amp;&#160;</td>
          <td class="paramname"><em>max_eigenvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_eigenvector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 2, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const elemT&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>.03</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>max_num_iterations</em> = <code>10000UL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the eigenvalue with the largest absolute value and corresponding eigenvector of a matrix by using the shifted power method. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__numerics.html#ga25f8b20733c8815ede894044aa71ef5e" title="Compute the eigenvalue with the largest absolute value and corresponding eigenvector of a matrix by u...">absolute_max_eigenvector_using_shifted_power_method()</a>.</dd></dl>
<p>The current method calls the normal power method for <code>m-shift*I</code> and shifts the eigenvalue back to the eigenvalue for <code>m</code>.</p>
<p>This method can be used to enhance the convergence rate if you know more about the eigenvalues. It can also be used to find another eigenvalue by shifting with the maximum eigenvalue. </p>

<p class="reference">References <a class="el" href="group__numerics.html#gaf89fe263ca8190c22691680019d27425">stir::absolute_max_eigenvector_using_power_method()</a>, <a class="el" href="namespacestir.html#a1dcd3841c17897adb3eb41b798453297">stir::diagonal_matrix()</a>, <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f">stir::error()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">stir::VectorWithOffset&lt; T &gt;::get_min_index()</a>, and <a class="el" href="classstir_1_1VectorWithOffset.html#aec5c52350ad01a1b87d03c85a0eb0060">stir::VectorWithOffset&lt; T &gt;::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__numerics.html#ga37432709a9e70ddd8b94d65f0e82e4f7">stir::max_eigenvector_using_power_method()</a>.</p>

</div>
</div>
<a id="ga37432709a9e70ddd8b94d65f0e82e4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37432709a9e70ddd8b94d65f0e82e4f7">&#9670;&nbsp;</a></span>max_eigenvector_using_power_method()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class elemT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Succeeded.html">Succeeded</a> stir::max_eigenvector_using_power_method </td>
          <td>(</td>
          <td class="paramtype">elemT &amp;&#160;</td>
          <td class="paramname"><em>max_eigenvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_eigenvector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 2, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>.03</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>max_num_iterations</em> = <code>10000UL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the eigenvalue with the largest value and corresponding eigenvector of a matrix by using the power method. </p>
<dl class="section warning"><dt>Warning</dt><dd>This assumes that all eigenvalues are real.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__numerics.html#ga25f8b20733c8815ede894044aa71ef5e" title="Compute the eigenvalue with the largest absolute value and corresponding eigenvector of a matrix by u...">absolute_max_eigenvector_using_shifted_power_method()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>is the input matrix, which has to be real-symmetric</td></tr>
  </table>
  </dd>
</dl>
<p>This will attempt to find the eigenvector which has the largest eigenvalue. The method fails when the matrix has a negative eigenvalue of the same magnitude as the largest eigenvalue.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000109">Todo:</a></b></dt><dd>the algorithm would work with hermitian matrices, but the code needs one small adjustment. </dd></dl>

<p class="reference">References <a class="el" href="group__numerics.html#gaf89fe263ca8190c22691680019d27425">stir::absolute_max_eigenvector_using_power_method()</a>, and <a class="el" href="group__numerics.html#ga25f8b20733c8815ede894044aa71ef5e">stir::absolute_max_eigenvector_using_shifted_power_method()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1RigidObject3DTransformation.html#ae50cebd519cbea6fe9587d0de02cc893">stir::RigidObject3DTransformation::find_closest_transformation()</a>.</p>

</div>
</div>
<a id="gae67e702dedcca1a7d8427e1a0590797b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae67e702dedcca1a7d8427e1a0590797b">&#9670;&nbsp;</a></span>overlap_interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stir::overlap_interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1VectorWithOffset.html">VectorWithOffset</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>zoom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>assign_rest_with_zeroes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>'overlap' interpolation (i.e. count preserving) for vectors. </p>
<p>This is an implementation of 'overlap' interpolation on arbitrary data types (using templates).</p>
<p>This type of interpolation considers the data as the samples of a step-wise function. The interpolated array again represents a step-wise function, such that the counts (i.e. integrals) are preserved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zoom</td><td>The spacing between the new points is determined by the 'zoom' parameter: e.g. zoom less than 1 stretches the bin size with a factor 1/zoom.</td></tr>
    <tr><td class="paramname">offset</td><td>(measured in 'units' of the in_data) allows to shift the range of values you want to compute. In particular, having positive offset shifts the data to the left (if in_data and out_data have the same range of indices). Note that a similar (but less general) effect to using 'offset' can be achieved by adjusting the min and max indices of the out_data.</td></tr>
    <tr><td class="paramname">assign_rest_with_zeroes</td><td>If <code>false</code> does not set values in <code>out_data</code> which do not overlap with <code>in_data</code>. If <code>true</code> those data are set to 0. (The effect being the same as first doing <code>out_data.fill(0)</code> before calling overlap_interpolate).</td></tr>
  </table>
  </dd>
</dl>
<p>For an index x_out (in <code>out_data</code> coordinates), the corresponding <code>in_data</code> coordinates is <code>x_in = x_out/zoom + offset</code> (The convention is used that the 'bins' are centered around the coordinate value.)</p>
<dl class="section warning"><dt>Warning</dt><dd>when T involves integral types, there is no rounding but truncation.</dd></dl>
<dl class="section user"><dt>Examples:</dt><dd></dd></dl>
<pre class="fragment">in_data = {a,b,c,d} indices from 0 to 3
zoom = .5
offset = .5
out_data = {a+b, c+d} indices from 0 to 1

in_data = {a,b,c,d} indices from 0 to 3
zoom = .5
offset = -.5
out_data = {a,b+c,d} indices from 0 to 2

in_data = {a,b,c} indices from -1 to 1
zoom = .5
offset = 0
out_data = {a/2, a/2+b+c/2, c/2} indices from -1 to 1
</pre><dl class="section user"><dt>Implementation details:</dt><dd></dd></dl>
<p>Because this implementation works for arbitrary (numeric) types T, it is slightly more complicated than would be necessary for (say) floats. In particular,<br />
</p><ul>
<li>we do our best to avoid creating temporary objects of type T<br />
</li>
<li>we zero values by using multiplication with 0 <br />
 (actually we use T::operator*=(0)). This is to allow the case where T::operator=(int) does not exist (in particular, in our higher dimensional arrays).</li>
</ul>
<dl class="section user"><dt>History:</dt><dd><ul>
<li>
first version by Kris Thielemans with suggestions by Alexey Zverovich. (loosely based on a 1D version by Claire Labbe) </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__numerics.html#gae67e702dedcca1a7d8427e1a0590797b" title="&#39;overlap&#39; interpolation (i.e. count preserving) for vectors. ">overlap_interpolate</a>(const out_iter_t out_begin, const out_iter_t out_end, const out_coord_iter_t out_coord_begin, const out_coord_iter_t out_coord_end, const in_iter_t in_begin, in_iter_t in_end, const in_coord_iter_t in_coord_begin, const in_coord_iter_t in_coord_end, const bool only_add_to_output=false, const bool assign_rest_with_zeroes) </dd></dl>

<p class="reference">Referenced by <a class="el" href="classstir_1_1ArcCorrection.html#afd486bc8f62fbc857d1908b9b058b2b2">stir::ArcCorrection::set_up()</a>, and <a class="el" href="namespacestir.html#ad83626cfc957b004ef1152bfdbedf945">stir::zoom_image()</a>.</p>

</div>
</div>
<a id="ga102332ccbd16abe782b51031a7d18913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga102332ccbd16abe782b51031a7d18913">&#9670;&nbsp;</a></span>overlap_interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename out_iter_t , typename out_coord_iter_t , typename in_iter_t , typename in_coord_iter_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::overlap_interpolate </td>
          <td>(</td>
          <td class="paramtype">const out_iter_t&#160;</td>
          <td class="paramname"><em>out_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const out_iter_t&#160;</td>
          <td class="paramname"><em>out_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const out_coord_iter_t&#160;</td>
          <td class="paramname"><em>out_coord_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const out_coord_iter_t&#160;</td>
          <td class="paramname"><em>out_coord_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const in_iter_t&#160;</td>
          <td class="paramname"><em>in_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in_iter_t&#160;</td>
          <td class="paramname"><em>in_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const in_coord_iter_t&#160;</td>
          <td class="paramname"><em>in_coord_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const in_coord_iter_t&#160;</td>
          <td class="paramname"><em>in_coord_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>only_add_to_output</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>assign_rest_with_zeroes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'overlap' interpolation for iterators, with arbitrary 'bin' sizes. </p>
<p>This type of interpolation considers the data as the samples of a step-wise function. The interpolated array again represents a step-wise function, such that the counts (i.e. integrals) are preserved.</p>
<p>In and out data are specified using iterators. For each, there is also a pair of iterators specifying the coordinates of the edges of the 'bins' (or 'boxes') in some arbitrary coordinate system (common between in and out parameters of course). Note that there should be one more coordinate than data (i.e. you have to specify the last edge as well). This is (only) checked with assert() statements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">only_add_to_output</td><td>If <code>false</code> will overwrite any data present in the output (aside from possibly the tails: see <code>assign_rest_with_zeroes</code>). If <code>true</code>, results will be added to the data. </td></tr>
    <tr><td class="paramname">assign_rest_with_zeroes</td><td>If <code>false</code> does not set values in the <code>out</code> range which do not overlap with <code>in</code> range. If <code>true</code> those data are set to 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>when the out iterators point to an integral type, there is no rounding but truncation.</dd></dl>
<dl class="section user"><dt>Examples:</dt><dd>Given 2 arrays and zoom and offset parameters <div class="fragment"><div class="line">Array&lt;1,float&gt; in = ...;</div><div class="line">Array&lt;1,float&gt; out = ...;</div><div class="line"><span class="keywordtype">float</span> zoom = ...; <span class="keywordtype">float</span> offset = ...;</div></div><!-- fragment --> the following pieces of code should give the same result (this is tested in test_interpolate): <div class="fragment"><div class="line"><a class="code" href="group__numerics.html#gae67e702dedcca1a7d8427e1a0590797b">overlap_interpolate</a>(out, in, zoom, offset, <span class="keyword">true</span>);</div></div><!-- fragment --> and <div class="fragment"><div class="line">Array&lt;1,float&gt; in_coords(in.get_min_index(), in.get_max_index()+1);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=in_coords.get_min_index(); i&lt;=in_coords.get_max_index(); ++i)</div><div class="line">  in_coords[i]=i-.5F;</div><div class="line">Array&lt;1,float&gt; out_coords(out.get_min_index(), out.get_max_index()+1);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=out_coords.get_min_index(); i&lt;=out_coords.get_max_index(); ++i)</div><div class="line">  out_coords[i]=(i-.5F)/zoom+offset;</div><div class="line"><a class="code" href="group__numerics.html#gae67e702dedcca1a7d8427e1a0590797b">overlap_interpolate</a>(out.begin(), out.end(),</div><div class="line">                    out_coords.begin(), out_coords.end(),</div><div class="line">                    in.begin(), in.end(),</div><div class="line">                    in_coords.begin(), in_coords.end()</div><div class="line">                    );</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Implementation details:</dt><dd></dd></dl>
<p>Because this implementation works for arbitrary (numeric) types, it is slightly more complicated than would be necessary for (say) floats. In particular, </p><ul>
<li>
we do our best to avoid creating temporary objects </li>
<li>
we zero values by using multiplication with 0. This is to allow the case where assignment with an int (or float) does not exist (in particular, in our higher dimensional arrays). </li>
</ul>
<p>The implementation is inline to avoid problems with template instantiations. </p><dl class="section user"><dt>History:</dt><dd><ul>
<li>
first version by Kris Thielemans </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3d41e73fca815d036389b83d7eda9584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d41e73fca815d036389b83d7eda9584">&#9670;&nbsp;</a></span>sample_function_on_regular_grid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctionType , class elemT , class positionT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::sample_function_on_regular_grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, positionT &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, positionT &gt; &amp;&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic function to get the values of a 3D function on a regular grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>array that will be filled with the function values. Its dimensions are used to find the coordinates where to sample the function (see below). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>function to sample </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>offset to use for coordinates (see below) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>step size to use for coordinates (see below)</td></tr>
  </table>
  </dd>
</dl>
<p>Symbolically, this function does the following computation for every index in the array </p><div class="fragment"><div class="line">out(index) = func(index * step - offset)</div></div><!-- fragment --><dl class="section user"><dt>requirement for type FunctionType</dt><dd>Due to the calling sequence above, the following has to be defined <div class="fragment"><div class="line">elemT FunctionType::operator(<span class="keyword">const</span> BasicCoordinate&lt;3, positionT&gt;&amp;)</div></div><!-- fragment --></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000110">Todo:</a></b></dt><dd>At the moment, only the 3D version is implemented, but this could be templated. </dd></dl>

<p class="reference">References <a class="el" href="classstir_1_1IndexRange.html#a8447f3ed2474bbd6e2fba16da8ab150c">stir::IndexRange&lt; num_dimensions &gt;::get_regular_range()</a>, and <a class="el" href="group__buildblock.html#ga45e27d9de6cdc69c146e791a825a20da">stir::warning()</a>.</p>

</div>
</div>
<a id="ga549f9e20e437106d1d66219e5386100b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga549f9e20e437106d1d66219e5386100b">&#9670;&nbsp;</a></span>sample_function_using_index_converter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename elemT , typename FunctionType , typename Lambda &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::sample_function_using_index_converter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda &amp;&amp;&#160;</td>
          <td class="paramname"><em>index_converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic function to get the values of a 3D function on a grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>array that will be filled with the function values. Its dimensions are used to find the coordinates where to sample the function (see below). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>function to sample </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index_converter</td><td>a lambda function converting indices in the out array to coordinates where the function shall be sampled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>requirement for type FunctionType</dt><dd>Due to the calling sequence above, the following has to be defined <div class="fragment"><div class="line">elemT FunctionType::operator(<span class="keyword">const</span> BasicCoordinate&lt;3, positionT&gt;&amp;)</div></div><!-- fragment --></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000111">Todo:</a></b></dt><dd>At the moment, only the 3D version is implemented, but this could be templated. </dd></dl>

<p class="reference">References <a class="el" href="classstir_1_1IndexRange.html#a8447f3ed2474bbd6e2fba16da8ab150c">stir::IndexRange&lt; num_dimensions &gt;::get_regular_range()</a>, and <a class="el" href="group__buildblock.html#ga45e27d9de6cdc69c146e791a825a20da">stir::warning()</a>.</p>

</div>
</div>
<a id="ga7ea1b16f83a5ee1fe9e13a0fe906f191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ea1b16f83a5ee1fe9e13a0fe906f191">&#9670;&nbsp;</a></span>pull_nearest_neighbour_interpolate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class elemT , class positionT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">elemT stir::pull_nearest_neighbour_interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 3, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; 3, positionT &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_in_input_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pull <em>value</em> from the input array using nearest neigbour interpolation. </p>
<p>Adds <em>value</em> to the grid point nearest to <em>point_in_output_coords</em> </p>

<p class="reference">References <a class="el" href="classstir_1_1VectorWithOffset.html#a23a3bcc84639216e608406803d98f14e">stir::VectorWithOffset&lt; T &gt;::get_max_index()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">stir::VectorWithOffset&lt; T &gt;::get_min_index()</a>, and <a class="el" href="namespacestir.html#a372ad4cac50cff397e0a334fe570ed18">stir::round()</a>.</p>

</div>
</div>
<a id="ga687c7b6806d9f144e778de54ca689a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga687c7b6806d9f144e778de54ca689a2f">&#9670;&nbsp;</a></span>push_nearest_neighbour_interpolate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dimensions, class elemT , class positionT , class valueT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stir::push_nearest_neighbour_interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, elemT &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstir_1_1BasicCoordinate.html">BasicCoordinate</a>&lt; num_dimensions, positionT &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_in_output_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">valueT&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push <em>value</em> into the output array using nearest neigbour interpolation. </p>
<p>Adds <em>value</em> to the grid point nearest to <em>point_in_output_coords</em> </p>

<p class="reference">References <a class="el" href="classstir_1_1VectorWithOffset.html#a23a3bcc84639216e608406803d98f14e">stir::VectorWithOffset&lt; Array&lt; num_dimensions - 1, elemT &gt; &gt;::get_max_index()</a>, <a class="el" href="classstir_1_1VectorWithOffset.html#a60196eb5ff5b91256df466ca4ddbd7fa">stir::VectorWithOffset&lt; Array&lt; num_dimensions - 1, elemT &gt; &gt;::get_min_index()</a>, and <a class="el" href="namespacestir.html#a372ad4cac50cff397e0a334fe570ed18">stir::round()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 23 2024 09:13:13 for STIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
