<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STIR: Discrete Fourier transforms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STIR
   &#160;<span id="projectnumber">4.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Discrete Fourier transforms<div class="ingroups"><a class="el" href="group__STIR.html">STIR</a> &raquo; <a class="el" href="group__STIR__library.html">STIR library</a> &raquo; <a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Discrete Fourier transforms:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__DFT.png" border="0" alt="" usemap="#group____DFT"/>
<map name="group____DFT" id="group____DFT">
<area shape="rect" id="node2" href="group__numerics.html" title="Numerical algorithms" alt="" coords="5,5,168,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:fourier_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8h.html">fourier.h</a></td></tr>
<tr class="memdesc:fourier_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for computing FFTs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:fourier_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fourier_8cxx.html">fourier.cxx</a></td></tr>
<tr class="memdesc:fourier_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for computing discrete fourier transforms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:test_2numerics_2test__Fourier_8cxx"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="test_2numerics_2test__Fourier_8cxx.html">test_Fourier.cxx</a></td></tr>
<tr class="memdesc:test_2numerics_2test__Fourier_8cxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for function in the DFT group. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6e9f0966e99dd2fc6c5112115f57a7e9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6e9f0966e99dd2fc6c5112115f57a7e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DFT.html#ga6e9f0966e99dd2fc6c5112115f57a7e9">stir::fourier</a> (T &amp;c, const int sign=1)</td></tr>
<tr class="memdesc:ga6e9f0966e99dd2fc6c5112115f57a7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute multi-dimensional discrete fourier transform.  <a href="group__DFT.html#ga6e9f0966e99dd2fc6c5112115f57a7e9">More...</a><br /></td></tr>
<tr class="separator:ga6e9f0966e99dd2fc6c5112115f57a7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38d56f39d09b8b3672d51bf34008d40a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga38d56f39d09b8b3672d51bf34008d40a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DFT.html#ga38d56f39d09b8b3672d51bf34008d40a">stir::inverse_fourier</a> (T &amp;c, const int sign=1)</td></tr>
<tr class="memdesc:ga38d56f39d09b8b3672d51bf34008d40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of the multi-dimensional discrete fourier transform.  <a href="group__DFT.html#ga38d56f39d09b8b3672d51bf34008d40a">More...</a><br /></td></tr>
<tr class="separator:ga38d56f39d09b8b3672d51bf34008d40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce1d0fc0582b40899b821605a241ae2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5ce1d0fc0582b40899b821605a241ae2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DFT.html#ga5ce1d0fc0582b40899b821605a241ae2">stir::fourier_1d</a> (T &amp;c, const int sign)</td></tr>
<tr class="memdesc:ga5ce1d0fc0582b40899b821605a241ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute one-dimensional discrete fourier transform of an array.  <a href="group__DFT.html#ga5ce1d0fc0582b40899b821605a241ae2">More...</a><br /></td></tr>
<tr class="separator:ga5ce1d0fc0582b40899b821605a241ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c05fa765304540d6704cb9644fac32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab9c05fa765304540d6704cb9644fac32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DFT.html#gab9c05fa765304540d6704cb9644fac32">stir::inverse_fourier_1d</a> (T &amp;c, const int sign=1)</td></tr>
<tr class="memdesc:gab9c05fa765304540d6704cb9644fac32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of the one-dimensional discrete fourier transform.  <a href="group__DFT.html#gab9c05fa765304540d6704cb9644fac32">More...</a><br /></td></tr>
<tr class="separator:gab9c05fa765304540d6704cb9644fac32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga881be303dec92c2fb910f70b8179a652"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga881be303dec92c2fb910f70b8179a652"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DFT.html#ga881be303dec92c2fb910f70b8179a652">stir::fourier_1d_for_real_data</a> (const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, T &gt; &amp;c, const int sign=1)</td></tr>
<tr class="memdesc:ga881be303dec92c2fb910f70b8179a652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute one-dimensional discrete fourier transform of a real array (of even size).  <a href="group__DFT.html#ga881be303dec92c2fb910f70b8179a652">More...</a><br /></td></tr>
<tr class="separator:ga881be303dec92c2fb910f70b8179a652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29615dcd9f6d0afe79026d1c96d22af0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga29615dcd9f6d0afe79026d1c96d22af0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DFT.html#ga29615dcd9f6d0afe79026d1c96d22af0">stir::inverse_fourier_1d_for_real_data</a> (const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, std::complex&lt; T &gt; &gt; &amp;c, const int sign=1)</td></tr>
<tr class="memdesc:ga29615dcd9f6d0afe79026d1c96d22af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of the one-dimensional discrete fourier transform of a real array (of even size).  <a href="group__DFT.html#ga29615dcd9f6d0afe79026d1c96d22af0">More...</a><br /></td></tr>
<tr class="separator:ga29615dcd9f6d0afe79026d1c96d22af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf16c068bc07b259903d8c6725ea26f06"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf16c068bc07b259903d8c6725ea26f06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DFT.html#gaf16c068bc07b259903d8c6725ea26f06">stir::inverse_fourier_1d_for_real_data_corrupting_input</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, std::complex&lt; T &gt; &gt; &amp;c, const int sign)</td></tr>
<tr class="memdesc:gaf16c068bc07b259903d8c6725ea26f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <a class="el" href="group__DFT.html#ga29615dcd9f6d0afe79026d1c96d22af0" title="Compute the inverse of the one-dimensional discrete fourier transform of a real array (of even size)...">inverse_fourier_1d_for_real_data()</a>, but avoiding the copy of the input array.  <a href="group__DFT.html#gaf16c068bc07b259903d8c6725ea26f06">More...</a><br /></td></tr>
<tr class="separator:gaf16c068bc07b259903d8c6725ea26f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c46b9cad81152690570df6293cf896"><td class="memTemplParams" colspan="2">template&lt;int num_dimensions, typename T &gt; </td></tr>
<tr class="memitem:gae7c46b9cad81152690570df6293cf896"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DFT.html#gae7c46b9cad81152690570df6293cf896">stir::fourier_for_real_data</a> (const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T &gt; &amp;c, const int sign=1)</td></tr>
<tr class="memdesc:gae7c46b9cad81152690570df6293cf896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute discrete fourier transform of a real array (with the last dimensions of even size).  <a href="group__DFT.html#gae7c46b9cad81152690570df6293cf896">More...</a><br /></td></tr>
<tr class="separator:gae7c46b9cad81152690570df6293cf896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92b644405e55adba21ad7cc2dd609864"><td class="memTemplParams" colspan="2">template&lt;int num_dimensions, typename T &gt; </td></tr>
<tr class="memitem:ga92b644405e55adba21ad7cc2dd609864"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DFT.html#ga92b644405e55adba21ad7cc2dd609864">stir::inverse_fourier_for_real_data</a> (const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, std::complex&lt; T &gt; &gt; &amp;c, const int sign=1)</td></tr>
<tr class="memdesc:ga92b644405e55adba21ad7cc2dd609864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of the discrete fourier transform of a real array (with the last dimension of even size).  <a href="group__DFT.html#ga92b644405e55adba21ad7cc2dd609864">More...</a><br /></td></tr>
<tr class="separator:ga92b644405e55adba21ad7cc2dd609864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec352e9ab3937a290dc51cabaf6901b"><td class="memTemplParams" colspan="2">template&lt;int num_dimensions, typename T &gt; </td></tr>
<tr class="memitem:ga9ec352e9ab3937a290dc51cabaf6901b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DFT.html#ga9ec352e9ab3937a290dc51cabaf6901b">stir::inverse_fourier_for_real_data_corrupting_input</a> (<a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, std::complex&lt; T &gt; &gt; &amp;c, const int sign=1)</td></tr>
<tr class="memdesc:ga9ec352e9ab3937a290dc51cabaf6901b"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <a class="el" href="group__DFT.html#ga92b644405e55adba21ad7cc2dd609864" title="Compute the inverse of the discrete fourier transform of a real array (with the last dimension of eve...">inverse_fourier_for_real_data()</a>, but avoiding the copy of the input array.  <a href="group__DFT.html#ga9ec352e9ab3937a290dc51cabaf6901b">More...</a><br /></td></tr>
<tr class="separator:ga9ec352e9ab3937a290dc51cabaf6901b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e81076ca4c51e5b9f6e43bddbb3a068"><td class="memTemplParams" colspan="2">template&lt;int num_dimensions, typename T &gt; </td></tr>
<tr class="memitem:ga5e81076ca4c51e5b9f6e43bddbb3a068"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, std::complex&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DFT.html#ga5e81076ca4c51e5b9f6e43bddbb3a068">stir::pos_frequencies_to_all</a> (const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, std::complex&lt; T &gt; &gt; &amp;c)</td></tr>
<tr class="memdesc:ga5e81076ca4c51e5b9f6e43bddbb3a068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds negative frequencies to the last dimension of a complex array by complex conjugation.  <a href="group__DFT.html#ga5e81076ca4c51e5b9f6e43bddbb3a068">More...</a><br /></td></tr>
<tr class="separator:ga5e81076ca4c51e5b9f6e43bddbb3a068"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6e9f0966e99dd2fc6c5112115f57a7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e9f0966e99dd2fc6c5112115f57a7e9">&#9670;&nbsp;</a></span>fourier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stir::fourier </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute multi-dimensional discrete fourier transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The type of <em>c</em> should normally be <code><a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a>&lt;n,std::complex&lt;T&gt; &gt;</code>. The function will then compute the <em>n-</em> dimensional fourier transform of the data, and store the result in <em>c</em>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>This can be used to implement a different convention for the DFT.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DFT.html#ga5ce1d0fc0582b40899b821605a241ae2" title="Compute one-dimensional discrete fourier transform of an array. ">fourier_1d</a> for conventions and restrictions</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Currently, the array has to have <code>get_min_index()==0</code> at each dimension. </dd></dl>

</div>
</div>
<a id="ga38d56f39d09b8b3672d51bf34008d40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38d56f39d09b8b3672d51bf34008d40a">&#9670;&nbsp;</a></span>inverse_fourier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::inverse_fourier </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the inverse of the multi-dimensional discrete fourier transform. </p>
<p>The scale factor is such that <code>inverse_fourier(fourier(c,sign),sign)==c</code>, aside from numerical error of course. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DFT.html#ga6e9f0966e99dd2fc6c5112115f57a7e9" title="Compute multi-dimensional discrete fourier transform. ">fourier</a> </dd></dl>

</div>
</div>
<a id="ga5ce1d0fc0582b40899b821605a241ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ce1d0fc0582b40899b821605a241ae2">&#9670;&nbsp;</a></span>fourier_1d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stir::fourier_1d </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute one-dimensional discrete fourier transform of an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">c</td><td>The type of <em>c</em> should normally be <code><a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a>&lt;n,std::complex&lt;T&gt; &gt;</code> (but see below). The function will then compute the one-dimensional fourier transform (i.e. on the 'outer' index) of the data, and store the result in <em>c</em>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>This can be used to implement a different convention for the DFT</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Currently, the array has to be indexed from 0. </dd>
<dd>
Currently, the length of the array has to be a power of 2.</dd></dl>
<p>The convention used is as follows. For a vector of length <em>n</em>, the result is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ r_s = \sum_{s=0}^{n-1} c_r e^{\mathrm{sign} 2\pi i r s/n} \]" src="form_31.png"/>
</p>
<p> This means that the zero-frequency will be returned in <code>c[0]</code></p>
<p>This function can be used with more general type of <em>c</em> (if instantiated in <a class="el" href="fourier_8cxx.html" title="Functions for computing discrete fourier transforms. ">fourier.cxx</a>). The type <em>T</em> has to be such that <em>T::value_type</em>, <em>T::reference</em> and <code> T::reference T::operator[](const int)</code> exist. Moreover, numerical operations <code>operator*=(T::reference, std::complex&lt;float&gt;)</code>, <code>operator+=(T::reference, T::value_type)</code> and <code>operator*=(T::reference, int)</code>, have to be defined as well. </p>

</div>
</div>
<a id="gab9c05fa765304540d6704cb9644fac32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9c05fa765304540d6704cb9644fac32">&#9670;&nbsp;</a></span>inverse_fourier_1d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stir::inverse_fourier_1d </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the inverse of the one-dimensional discrete fourier transform. </p>
<p>The scale factor is such that <code>inverse_fourier_1d(fourier_1d(c,sign),sign)==c</code>, aside from numerical error of course. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DFT.html#ga5ce1d0fc0582b40899b821605a241ae2" title="Compute one-dimensional discrete fourier transform of an array. ">fourier_1d()</a> </dd></dl>

</div>
</div>
<a id="ga881be303dec92c2fb910f70b8179a652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga881be303dec92c2fb910f70b8179a652">&#9670;&nbsp;</a></span>fourier_1d_for_real_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, std::complex&lt; T &gt; &gt; stir::fourier_1d_for_real_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute one-dimensional discrete fourier transform of a real array (of even size). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The type of <em>c</em> should normally be <code><a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a>&lt;1,float&gt;</code> (or <code>double</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>This can be used to implement a different convention for the DFT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The positive frequencies of the DFT as an array of complex numbers. That is, for <code>c.size()==2*n</code>, the returned array will have indices from <code>0</code> to <code>n</code>, with the 0 frequency at 0.</dd></dl>
<p>For a real array, the DFT is such that the values at negative frequencies are the complex conjugate of the value at the corresponding positive frequency. In addition, if the length of the real array is even, the DFT can be computed efficiently by creating a complex array of half the length (by putting the even-numbered elements as the real part, and the odd-numbered as the imaginary part).</p>
<p>This function implements the above and is hence (probably) a faster way to compute DFTs of real arrays. Note however, that in contrast to the Numerical Recipes routines, the result is not stored in the same memory location as the input. For a recent compiler that implements the Named-Return-Value-Optimisation, this should not be a problem in most cases.</p>
<p>Result is such that <code>pos_frequencies_to_all(fourier_1d_for_real_data(v,sign))==fourier(v,sign)</code> (this is meant symbolically. In code you'd have to make <code>v</code> into an array of complex numbers before passing to <code>fourier</code>).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DFT.html#ga5e81076ca4c51e5b9f6e43bddbb3a068" title="Adds negative frequencies to the last dimension of a complex array by complex conjugation. ">pos_frequencies_to_all()</a> </dd>
<dd>
<a class="el" href="group__DFT.html#ga5ce1d0fc0582b40899b821605a241ae2" title="Compute one-dimensional discrete fourier transform of an array. ">fourier_1d()</a> for conventions and restrictions</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Currently, the array has to have <code>get_min_index()==0</code>. </dd></dl>

</div>
</div>
<a id="ga29615dcd9f6d0afe79026d1c96d22af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29615dcd9f6d0afe79026d1c96d22af0">&#9670;&nbsp;</a></span>inverse_fourier_1d_for_real_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, T &gt; stir::inverse_fourier_1d_for_real_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, std::complex&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inverse of the one-dimensional discrete fourier transform of a real array (of even size). </p>
<dl class="section warning"><dt>Warning</dt><dd>Because of implementation issues, a temporary copy of the input data <code>c</code> has to be made. This obviously affects performance. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DFT.html#ga881be303dec92c2fb910f70b8179a652" title="Compute one-dimensional discrete fourier transform of a real array (of even size). ">fourier_1d_for_real_data()</a> </dd></dl>

</div>
</div>
<a id="gaf16c068bc07b259903d8c6725ea26f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf16c068bc07b259903d8c6725ea26f06">&#9670;&nbsp;</a></span>inverse_fourier_1d_for_real_data_corrupting_input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, T &gt; stir::inverse_fourier_1d_for_real_data_corrupting_input </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; 1, std::complex&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <a class="el" href="group__DFT.html#ga29615dcd9f6d0afe79026d1c96d22af0" title="Compute the inverse of the one-dimensional discrete fourier transform of a real array (of even size)...">inverse_fourier_1d_for_real_data()</a>, but avoiding the copy of the input array. </p>
<dl class="section warning"><dt>Warning</dt><dd>destroys values in (and resizes) first argument <em>c</em> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DFT.html#ga29615dcd9f6d0afe79026d1c96d22af0" title="Compute the inverse of the one-dimensional discrete fourier transform of a real array (of even size)...">inverse_fourier_1d_for_real_data()</a> </dd></dl>

</div>
</div>
<a id="gae7c46b9cad81152690570df6293cf896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7c46b9cad81152690570df6293cf896">&#9670;&nbsp;</a></span>fourier_for_real_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dimensions, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, std::complex&lt; T &gt; &gt; stir::fourier_for_real_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute discrete fourier transform of a real array (with the last dimensions of even size). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The type of <em>c</em> should normally be <code><a class="el" href="classstir_1_1Array.html" title="This class defines multi-dimensional (numeric) arrays. ">Array</a>&lt;d,float&gt;</code> (or <code>double</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sign</td><td>This can be used to implement a different convention for the DFT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The positive frequencies of the DFT as an array of complex numbers. That is, if <code>c</code> has sizes <code>(n1,n2,...,nd)</code>, with <code>nd</code> even, the returned array will have sizes <code>(n1,n2,...,(nd/2)+1)</code>, with the 0 frequency at index <code>(0,0,...0)</code>.</dd></dl>
<p>For a real array, the DFT is such that the values at frequency <code>(k1,k2,...,kd)</code> are the complex conjugate of the value at the corresponding frequency <code>(-k1,-k2,...,-kd)</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DFT.html#ga881be303dec92c2fb910f70b8179a652" title="Compute one-dimensional discrete fourier transform of a real array (of even size). ">fourier_1d_for_real_data()</a></dd></dl>
<p>This can be used to compute only the 'positive' half of the frequencies. For this implementation, this means that only results for frequencies <code>(k1,k2,...,kd)</code> with <code>0&lt;=kd&lt;=(nd/2)</code>, i.e. the 'last' dimension has positive frequencies.</p>
<dl class="section warning"><dt>Warning</dt><dd>At present, <code>c</code> has to be a regular array with all indices starting from 0. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DFT.html#ga5e81076ca4c51e5b9f6e43bddbb3a068" title="Adds negative frequencies to the last dimension of a complex array by complex conjugation. ">pos_frequencies_to_all()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classstir_1_1ArrayFilterUsingRealDFTWithPadding.html#af00cdd16ce0fa8fe80c1468f2b141dc8">stir::ArrayFilterUsingRealDFTWithPadding&lt; 2, float &gt;::do_it()</a>, <a class="el" href="classstir_1_1ArrayFilterUsingRealDFTWithPadding.html#a1463e5eb0a79db3836d7c8a848cb5cf0">stir::ArrayFilterUsingRealDFTWithPadding&lt; 2, float &gt;::set_kernel()</a>, and <a class="el" href="classstir_1_1ColsherFilter.html#ae533a73f0dd94b0065e1d197989bfd21">stir::ColsherFilter::set_up()</a>.</p>

</div>
</div>
<a id="ga92b644405e55adba21ad7cc2dd609864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92b644405e55adba21ad7cc2dd609864">&#9670;&nbsp;</a></span>inverse_fourier_for_real_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dimensions, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T &gt; stir::inverse_fourier_for_real_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, std::complex&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inverse of the discrete fourier transform of a real array (with the last dimension of even size). </p>
<dl class="section warning"><dt>Warning</dt><dd>Because of implementation issues, a temporary copy of the input data <code>c</code> has to be made. This </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DFT.html#gae7c46b9cad81152690570df6293cf896" title="Compute discrete fourier transform of a real array (with the last dimensions of even size)...">fourier_for_real_data()</a> </dd></dl>

</div>
</div>
<a id="ga9ec352e9ab3937a290dc51cabaf6901b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ec352e9ab3937a290dc51cabaf6901b">&#9670;&nbsp;</a></span>inverse_fourier_for_real_data_corrupting_input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dimensions, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, T &gt; stir::inverse_fourier_for_real_data_corrupting_input </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, std::complex&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <a class="el" href="group__DFT.html#ga92b644405e55adba21ad7cc2dd609864" title="Compute the inverse of the discrete fourier transform of a real array (with the last dimension of eve...">inverse_fourier_for_real_data()</a>, but avoiding the copy of the input array. </p>
<dl class="section warning"><dt>Warning</dt><dd>destroys values in (and resizes) first argument <em>c</em> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DFT.html#ga92b644405e55adba21ad7cc2dd609864" title="Compute the inverse of the discrete fourier transform of a real array (with the last dimension of eve...">inverse_fourier_for_real_data()</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classstir_1_1ArrayFilterUsingRealDFTWithPadding.html#af00cdd16ce0fa8fe80c1468f2b141dc8">stir::ArrayFilterUsingRealDFTWithPadding&lt; 2, float &gt;::do_it()</a>, and <a class="el" href="classstir_1_1ColsherFilter.html#ae533a73f0dd94b0065e1d197989bfd21">stir::ColsherFilter::set_up()</a>.</p>

</div>
</div>
<a id="ga5e81076ca4c51e5b9f6e43bddbb3a068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e81076ca4c51e5b9f6e43bddbb3a068">&#9670;&nbsp;</a></span>pos_frequencies_to_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_dimensions, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, std::complex&lt; T &gt; &gt; stir::pos_frequencies_to_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstir_1_1Array.html">Array</a>&lt; num_dimensions, std::complex&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds negative frequencies to the last dimension of a complex array by complex conjugation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DFT.html#gae7c46b9cad81152690570df6293cf896" title="Compute discrete fourier transform of a real array (with the last dimensions of even size)...">fourier_for_real_data()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 7 2021 07:21:19 for STIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
