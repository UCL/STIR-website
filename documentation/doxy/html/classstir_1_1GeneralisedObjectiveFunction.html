<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STIR: stir::GeneralisedObjectiveFunction&lt; TargetT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STIR
   &#160;<span id="projectnumber">6.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestir.html">stir</a></li><li class="navelem"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">GeneralisedObjectiveFunction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classstir_1_1GeneralisedObjectiveFunction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">stir::GeneralisedObjectiveFunction&lt; TargetT &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__STIR.html">STIR</a> &raquo; <a class="el" href="group__STIR__library.html">STIR library</a> &raquo; <a class="el" href="group__recon__buildblock.html">Reconstruction building blocks</a> &raquo; <a class="el" href="group__GeneralisedObjectiveFunction.html">Objective functions for iterative estimation of variables</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A base class for 'generalised' objective functions, i.e. objective functions for which at least a 'gradient' is defined.  
 <a href="classstir_1_1GeneralisedObjectiveFunction.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="GeneralisedObjectiveFunction_8h_source.html">stir/recon_buildblock/GeneralisedObjectiveFunction.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for stir::GeneralisedObjectiveFunction&lt; TargetT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classstir_1_1GeneralisedObjectiveFunction__inherit__graph.png" border="0" usemap="#stir_1_1GeneralisedObjectiveFunction_3_01TargetT_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="stir_1_1GeneralisedObjectiveFunction_3_01TargetT_01_4_inherit__map" id="stir_1_1GeneralisedObjectiveFunction_3_01TargetT_01_4_inherit__map">
<area shape="rect" id="node6" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMean.html" title="a base class for LogLikelihood of independent Poisson variables where the mean values are linear comb..." alt="" coords="1280,262,1455,318"/>
<area shape="rect" id="node2" href="classstir_1_1RegisteredObject.html" title="stir::RegisteredObject\l\&lt; GeneralisedObjectiveFunction\l\&lt; TargetT \&gt; \&gt;" alt="" coords="801,262,1009,318"/>
<area shape="rect" id="node3" href="classstir_1_1RegisteredObjectBase.html" title="Base class for all classes that can parse .par files (and more?)The only reason that this class exist..." alt="" coords="185,277,364,303"/>
<area shape="rect" id="node5" href="classstir_1_1RegisteredObject.html" title="Helper class to provide registry mechanisms to a Base classSuppose you have a hierarchy of classes wi..." alt="" coords="413,299,563,340"/>
<area shape="rect" id="node4" href="classstir_1_1ParsingObject.html" title="A base class for objects that want to be able to parse parameter files. " alt="" coords="5,277,136,303"/>
<area shape="rect" id="node7" href="classstir_1_1RegisteredParsingObject.html" title="RegisteredParsingObject\l\&lt; PoissonLogLikelihoodWithLinear\lKineticModelAndDynamicProjectionData\l\&lt; TargetT \&gt;, GeneralisedObjectiveFunction\l\&lt; TargetT \&gt;, PoissonLogLikelihoodWithLinearModelFor\lMean\&lt; TargetT \&gt; \&gt;" alt="" coords="1504,5,1845,105"/>
<area shape="rect" id="node9" href="classstir_1_1RegisteredParsingObject.html" title="RegisteredParsingObject\l\&lt; PoissonLogLikelihoodWithLinear\lModelForMeanAndDynamicProjData\l\&lt; TargetT \&gt;, GeneralisedObjectiveFunction\l\&lt; TargetT \&gt;, PoissonLogLikelihoodWithLinearModel\lForMean\&lt; TargetT \&gt; \&gt;" alt="" coords="1513,129,1836,229"/>
<area shape="rect" id="node11" href="classstir_1_1RegisteredParsingObject.html" title="RegisteredParsingObject\l\&lt; PoissonLogLikelihoodWithLinear\lModelForMeanAndGatedProjDataWithMotion\l\&lt; TargetT \&gt;, GeneralisedObjectiveFunction\l\&lt; TargetT \&gt;, PoissonLogLikelihoodWithLinearModelFor\lMean\&lt; TargetT \&gt; \&gt;" alt="" coords="1869,221,2211,321"/>
<area shape="rect" id="node13" href="classstir_1_1RegisteredParsingObject.html" title="RegisteredParsingObject\l\&lt; PoissonLogLikelihoodWithLinear\lModelForMeanAndProjData\&lt; TargetT\l \&gt;, GeneralisedObjectiveFunction\l\&lt; TargetT \&gt;, PoissonLogLikelihoodWithLinear\lModelForMean\&lt; TargetT \&gt; \&gt;" alt="" coords="1531,305,1818,405"/>
<area shape="rect" id="node15" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeData.html" title="An objective function class appropriate for PET list mode data. " alt="" coords="1551,430,1798,486"/>
<area shape="rect" id="node17" href="classstir_1_1SumOfGeneralisedObjectiveFunctions.html" title="SumOfGeneralisedObjective\lFunctions\&lt; PoissonLogLikelihood\lWithLinearModelForMeanAndProjData\l\&lt; TargetT \&gt;, TargetT, PoissonLogLikelihood\lWithLinearModelForMean\&lt; TargetT \&gt; \&gt;" alt="" coords="1535,519,1814,605"/>
<area shape="rect" id="node8" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html" title="a base class for LogLikelihood of independent Poisson variables where the mean values are linear comb..." alt="" coords="2377,27,2611,83"/>
<area shape="rect" id="node10" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndDynamicProjData.html" title="a base class for LogLikelihood of independent Poisson variables where the mean values are linear comb..." alt="" coords="2371,151,2617,207"/>
<area shape="rect" id="node12" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html" title="a base class for LogLikelihood of independent Poisson variables where the mean values are linear comb..." alt="" coords="2803,402,3031,458"/>
<area shape="rect" id="node14" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html" title="An objective function class appropriate for PET emission data. " alt="" coords="2372,322,2616,378"/>
<area shape="rect" id="node16" href="classstir_1_1RegisteredParsingObject.html" title="RegisteredParsingObject\l\&lt; PoissonLogLikelihoodWithLinear\lModelForMeanAndListModeDataWithProjMatrix\lByBin\&lt; TargetT \&gt;, GeneralisedObjectiveFunction\l\&lt; TargetT \&gt;, PoissonLogLikelihoodWithLinearModelForMean\lAndListModeData\&lt; TargetT \&gt; \&gt;" alt="" coords="2307,401,2681,501"/>
<area shape="rect" id="node18" href="classstir_1_1RegisteredParsingObject.html" title="stir::RegisteredParsingObject\l\&lt; PoissonLogLikelihoodWithLinear\lModelForMeanAndGatedProjDataWithMotion\l\&lt; TargetT \&gt;, GeneralisedObjectiveFunction\l\&lt; TargetT \&gt;, SumOfGeneralisedObjectiveFunctions\l\&lt; PoissonLogLikelihoodWithLinearModelForMeanAndProjData\l\&lt; TargetT \&gt;, TargetT, PoissonLogLikelihoodWithLinearModelForMean\&lt; TargetT \&gt; \&gt; \&gt;" alt="" coords="2235,526,2753,641"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac7d1bb65ad36569c4e78d81745e7db07"><td class="memItemLeft" align="right" valign="top">virtual TargetT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#ac7d1bb65ad36569c4e78d81745e7db07">construct_target_ptr</a> () const =0</td></tr>
<tr class="memdesc:ac7d1bb65ad36569c4e78d81745e7db07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a suitable target as determined by the parameters.  <a href="#ac7d1bb65ad36569c4e78d81745e7db07">More...</a><br /></td></tr>
<tr class="separator:ac7d1bb65ad36569c4e78d81745e7db07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594bd9b807d2623fbf383d059140a808"><td class="memItemLeft" align="right" valign="top"><a id="a594bd9b807d2623fbf383d059140a808"></a>
virtual <a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a594bd9b807d2623fbf383d059140a808">set_up</a> (shared_ptr&lt; TargetT &gt; const &amp;target_sptr)</td></tr>
<tr class="memdesc:a594bd9b807d2623fbf383d059140a808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has to be called before using this object. <br /></td></tr>
<tr class="separator:a594bd9b807d2623fbf383d059140a808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6291a5e5373517ddfb7ccbc259fdeef6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a6291a5e5373517ddfb7ccbc259fdeef6">compute_sub_gradient</a> (TargetT &amp;gradient, const TargetT &amp;current_estimate, const int subset_num)</td></tr>
<tr class="memdesc:a6291a5e5373517ddfb7ccbc259fdeef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the subset-gradient of the objective function at <em>current_estimate</em>.  <a href="#a6291a5e5373517ddfb7ccbc259fdeef6">More...</a><br /></td></tr>
<tr class="separator:a6291a5e5373517ddfb7ccbc259fdeef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d490db9b1171fc0fa198c93af4d78cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a3d490db9b1171fc0fa198c93af4d78cb">compute_sub_gradient_without_penalty</a> (TargetT &amp;gradient, const TargetT &amp;current_estimate, const int subset_num)=0</td></tr>
<tr class="memdesc:a3d490db9b1171fc0fa198c93af4d78cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should compute the subset-gradient of the unregularised objective function at <em>current_estimate</em>.  <a href="#a3d490db9b1171fc0fa198c93af4d78cb">More...</a><br /></td></tr>
<tr class="separator:a3d490db9b1171fc0fa198c93af4d78cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f40f452c030412e33bd0b7a7f94046b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a6f40f452c030412e33bd0b7a7f94046b">compute_gradient</a> (TargetT &amp;gradient, const TargetT &amp;current_estimate)</td></tr>
<tr class="memdesc:a6f40f452c030412e33bd0b7a7f94046b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the objective function at the <em>current_estimate</em>.  <a href="#a6f40f452c030412e33bd0b7a7f94046b">More...</a><br /></td></tr>
<tr class="separator:a6f40f452c030412e33bd0b7a7f94046b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff0a08633f24353dd2773eb7aa8504d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a7ff0a08633f24353dd2773eb7aa8504d">compute_gradient_without_penalty</a> (TargetT &amp;gradient, const TargetT &amp;current_estimate)</td></tr>
<tr class="memdesc:a7ff0a08633f24353dd2773eb7aa8504d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient of the unregularised objective function at the <em>current_estimate</em>.  <a href="#a7ff0a08633f24353dd2773eb7aa8504d">More...</a><br /></td></tr>
<tr class="separator:a7ff0a08633f24353dd2773eb7aa8504d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de6d1650b0eb144a73941a5f0ade96b"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a2de6d1650b0eb144a73941a5f0ade96b">compute_objective_function_without_penalty</a> (const TargetT &amp;current_estimate, const int subset_num)</td></tr>
<tr class="memdesc:a2de6d1650b0eb144a73941a5f0ade96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value of the unregularised sub-objective function at the <em>current_estimate</em>.  <a href="#a2de6d1650b0eb144a73941a5f0ade96b">More...</a><br /></td></tr>
<tr class="separator:a2de6d1650b0eb144a73941a5f0ade96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4fabaae9c18869ae00efa6f74ab57f"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a2b4fabaae9c18869ae00efa6f74ab57f">compute_objective_function_without_penalty</a> (const TargetT &amp;current_estimate)</td></tr>
<tr class="memdesc:a2b4fabaae9c18869ae00efa6f74ab57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value of the unregularised objective function at the <em>current_estimate</em>.  <a href="#a2b4fabaae9c18869ae00efa6f74ab57f">More...</a><br /></td></tr>
<tr class="separator:a2b4fabaae9c18869ae00efa6f74ab57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ce28ba6826afc2fbd303b65946b6d4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a77ce28ba6826afc2fbd303b65946b6d4">compute_penalty</a> (const TargetT &amp;current_estimate, const int subset_num)</td></tr>
<tr class="memdesc:a77ce28ba6826afc2fbd303b65946b6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value of the sub-penalty at the <em>current_estimate</em>.  <a href="#a77ce28ba6826afc2fbd303b65946b6d4">More...</a><br /></td></tr>
<tr class="separator:a77ce28ba6826afc2fbd303b65946b6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159b743f71bd2be8dc5441ecf580d373"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a159b743f71bd2be8dc5441ecf580d373">compute_penalty</a> (const TargetT &amp;current_estimate)</td></tr>
<tr class="memdesc:a159b743f71bd2be8dc5441ecf580d373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value of the penalty at the <em>current_estimate</em>.  <a href="#a159b743f71bd2be8dc5441ecf580d373">More...</a><br /></td></tr>
<tr class="separator:a159b743f71bd2be8dc5441ecf580d373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211f21d59b7d47f605a2f38a643bda68"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a211f21d59b7d47f605a2f38a643bda68">compute_objective_function</a> (const TargetT &amp;current_estimate, const int subset_num)</td></tr>
<tr class="memdesc:a211f21d59b7d47f605a2f38a643bda68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value of the sub-objective function at the <em>current_estimate</em>.  <a href="#a211f21d59b7d47f605a2f38a643bda68">More...</a><br /></td></tr>
<tr class="separator:a211f21d59b7d47f605a2f38a643bda68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fd305b3f3b5070ee5c7b62e8b5fee5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#af9fd305b3f3b5070ee5c7b62e8b5fee5">compute_objective_function</a> (const TargetT &amp;current_estimate)</td></tr>
<tr class="memdesc:af9fd305b3f3b5070ee5c7b62e8b5fee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the value of the objective function at the <em>current_estimate</em>.  <a href="#af9fd305b3f3b5070ee5c7b62e8b5fee5">More...</a><br /></td></tr>
<tr class="separator:af9fd305b3f3b5070ee5c7b62e8b5fee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8099c6ef0f97679d2e01d390af6798f"><td class="memItemLeft" align="right" valign="top"><a id="aa8099c6ef0f97679d2e01d390af6798f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#aa8099c6ef0f97679d2e01d390af6798f">compute_value</a> (const TargetT &amp;current_estimate)</td></tr>
<tr class="memdesc:aa8099c6ef0f97679d2e01d390af6798f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#af9fd305b3f3b5070ee5c7b62e8b5fee5" title="Compute the value of the objective function at the current_estimate. ">compute_objective_function(const TargetT&amp;)</a> <br /></td></tr>
<tr class="separator:aa8099c6ef0f97679d2e01d390af6798f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5bfcded32b6d3339b5bb1be1995c75"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#abe5bfcded32b6d3339b5bb1be1995c75">fill_nonidentifiable_target_parameters</a> (TargetT &amp;target, const float value) const</td></tr>
<tr class="memdesc:abe5bfcded32b6d3339b5bb1be1995c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill any elements that we cannot estimate with a fixed value.  <a href="#abe5bfcded32b6d3339b5bb1be1995c75">More...</a><br /></td></tr>
<tr class="separator:abe5bfcded32b6d3339b5bb1be1995c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552fa05a71b2b3c533e9c5d987bf7066"><td class="memItemLeft" align="right" valign="top"><a id="a552fa05a71b2b3c533e9c5d987bf7066"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a552fa05a71b2b3c533e9c5d987bf7066">get_objective_function_values_report</a> (const TargetT &amp;current_estimate)</td></tr>
<tr class="memdesc:a552fa05a71b2b3c533e9c5d987bf7066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string with info on the value of objective function with and without penalty. <br /></td></tr>
<tr class="separator:a552fa05a71b2b3c533e9c5d987bf7066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72704e313651d0d4d7a61846df7a8f47"><td class="memItemLeft" align="right" valign="top"><a id="a72704e313651d0d4d7a61846df7a8f47"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a72704e313651d0d4d7a61846df7a8f47">get_num_subsets</a> () const</td></tr>
<tr class="memdesc:a72704e313651d0d4d7a61846df7a8f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of subsets in-use. <br /></td></tr>
<tr class="separator:a72704e313651d0d4d7a61846df7a8f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283748c45b72865320de50548a82fb1c"><td class="memItemLeft" align="right" valign="top"><a id="a283748c45b72865320de50548a82fb1c"></a>
virtual std::unique_ptr&lt; <a class="el" href="classstir_1_1ExamInfo.html">ExamInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_exam_info_uptr_for_target</b> () const</td></tr>
<tr class="separator:a283748c45b72865320de50548a82fb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4712dc126b185ab17926283c3331ec2c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a4712dc126b185ab17926283c3331ec2c">set_num_subsets</a> (const int num_subsets)=0</td></tr>
<tr class="memdesc:a4712dc126b185ab17926283c3331ec2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to change the number of subsets.  <a href="#a4712dc126b185ab17926283c3331ec2c">More...</a><br /></td></tr>
<tr class="separator:a4712dc126b185ab17926283c3331ec2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44734aea00b7cf5ce40fd8f21367e9d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a44734aea00b7cf5ce40fd8f21367e9d5">subsets_are_approximately_balanced</a> () const</td></tr>
<tr class="memdesc:a44734aea00b7cf5ce40fd8f21367e9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks of the current subset scheme is approximately balanced.  <a href="#a44734aea00b7cf5ce40fd8f21367e9d5">More...</a><br /></td></tr>
<tr class="separator:a44734aea00b7cf5ce40fd8f21367e9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655f803224f2de4512bc144b7d67ca84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a655f803224f2de4512bc144b7d67ca84">subsets_are_approximately_balanced</a> (std::string &amp;warning_message) const</td></tr>
<tr class="memdesc:a655f803224f2de4512bc144b7d67ca84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks of the current subset scheme is approximately balanced and constructs a warning message.  <a href="#a655f803224f2de4512bc144b7d67ca84">More...</a><br /></td></tr>
<tr class="separator:a655f803224f2de4512bc144b7d67ca84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dddd10a1aa250e6c0d6d3365e1636b8"><td class="memItemLeft" align="right" valign="top"><a id="a1dddd10a1aa250e6c0d6d3365e1636b8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a1dddd10a1aa250e6c0d6d3365e1636b8">prior_is_zero</a> () const</td></tr>
<tr class="memdesc:a1dddd10a1aa250e6c0d6d3365e1636b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the prior is set (or the penalisation factor is 0) <br /></td></tr>
<tr class="separator:a1dddd10a1aa250e6c0d6d3365e1636b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c99dc70801b4cc6e909794f3889bb5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1GeneralisedPrior.html">GeneralisedPrior</a>&lt; TargetT &gt; *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a9c99dc70801b4cc6e909794f3889bb5f">get_prior_ptr</a> () const</td></tr>
<tr class="memdesc:a9c99dc70801b4cc6e909794f3889bb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to the prior.  <a href="#a9c99dc70801b4cc6e909794f3889bb5f">More...</a><br /></td></tr>
<tr class="separator:a9c99dc70801b4cc6e909794f3889bb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711bf385ed5b222b7ea2f77b09db3c0a"><td class="memItemLeft" align="right" valign="top"><a id="a711bf385ed5b222b7ea2f77b09db3c0a"></a>
shared_ptr&lt; <a class="el" href="classstir_1_1GeneralisedPrior.html">GeneralisedPrior</a>&lt; TargetT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_prior_sptr</b> ()</td></tr>
<tr class="separator:a711bf385ed5b222b7ea2f77b09db3c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19b31d2e22c5806201dabaaaafd9962"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#ab19b31d2e22c5806201dabaaaafd9962">set_prior_sptr</a> (const shared_ptr&lt; <a class="el" href="classstir_1_1GeneralisedPrior.html">GeneralisedPrior</a>&lt; TargetT &gt;&gt; &amp;)</td></tr>
<tr class="memdesc:ab19b31d2e22c5806201dabaaaafd9962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the prior.  <a href="#ab19b31d2e22c5806201dabaaaafd9962">More...</a><br /></td></tr>
<tr class="separator:ab19b31d2e22c5806201dabaaaafd9962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191d2641fe116852e66c99212fde3b50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a191d2641fe116852e66c99212fde3b50">set_input_data</a> (const shared_ptr&lt; <a class="el" href="classstir_1_1ExamData.html">ExamData</a> &gt; &amp;)=0</td></tr>
<tr class="memdesc:a191d2641fe116852e66c99212fde3b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">set_input_data  <a href="#a191d2641fe116852e66c99212fde3b50">More...</a><br /></td></tr>
<tr class="separator:a191d2641fe116852e66c99212fde3b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8304392cf449fbe3bfbb490ddc74bb1d"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classstir_1_1ExamData.html">ExamData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a8304392cf449fbe3bfbb490ddc74bb1d">get_input_data</a> () const =0</td></tr>
<tr class="memdesc:a8304392cf449fbe3bfbb490ddc74bb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get input data  <a href="#a8304392cf449fbe3bfbb490ddc74bb1d">More...</a><br /></td></tr>
<tr class="separator:a8304392cf449fbe3bfbb490ddc74bb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9605e9d34ed5d9851951ea0d9ffb4862"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a9605e9d34ed5d9851951ea0d9ffb4862">set_additive_proj_data_sptr</a> (const shared_ptr&lt; <a class="el" href="classstir_1_1ExamData.html">ExamData</a> &gt; &amp;)=0</td></tr>
<tr class="memdesc:a9605e9d34ed5d9851951ea0d9ffb4862"><td class="mdescLeft">&#160;</td><td class="mdescRight">set_additive_proj_data_sptr  <a href="#a9605e9d34ed5d9851951ea0d9ffb4862">More...</a><br /></td></tr>
<tr class="separator:a9605e9d34ed5d9851951ea0d9ffb4862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b4e611dcb36d3d690e64939e46d2dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#ae8b4e611dcb36d3d690e64939e46d2dd">set_normalisation_sptr</a> (const shared_ptr&lt; <a class="el" href="classstir_1_1BinNormalisation.html">BinNormalisation</a> &gt; &amp;)=0</td></tr>
<tr class="memdesc:ae8b4e611dcb36d3d690e64939e46d2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">set_normalisation_sptr  <a href="#ae8b4e611dcb36d3d690e64939e46d2dd">More...</a><br /></td></tr>
<tr class="separator:ae8b4e611dcb36d3d690e64939e46d2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">multiplication with approximate (sub)Hessian</div></td></tr>
<tr class="memitem:ae3539db92b08bb08e3d5f700f523d943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#ae3539db92b08bb08e3d5f700f523d943">add_multiplication_with_approximate_sub_Hessian_without_penalty</a> (TargetT &amp;output, const TargetT &amp;input, const int subset_num) const</td></tr>
<tr class="memdesc:ae3539db92b08bb08e3d5f700f523d943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions that multiply the approximate (sub)Hessian with a \'vector\'.  <a href="#ae3539db92b08bb08e3d5f700f523d943">More...</a><br /></td></tr>
<tr class="separator:ae3539db92b08bb08e3d5f700f523d943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01131b722a97e3c6595d8691c7ca21b"><td class="memItemLeft" align="right" valign="top"><a id="ad01131b722a97e3c6595d8691c7ca21b"></a>
<a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add_multiplication_with_approximate_sub_Hessian</b> (TargetT &amp;output, const TargetT &amp;input, const int subset_num) const</td></tr>
<tr class="separator:ad01131b722a97e3c6595d8691c7ca21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab546c728727fbce8a4c49e6dc2b2a0f2"><td class="memItemLeft" align="right" valign="top"><a id="ab546c728727fbce8a4c49e6dc2b2a0f2"></a>
<a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add_multiplication_with_approximate_Hessian_without_penalty</b> (TargetT &amp;output, const TargetT &amp;input) const</td></tr>
<tr class="separator:ab546c728727fbce8a4c49e6dc2b2a0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae569195e094f31dbde1571a73ae96842"><td class="memItemLeft" align="right" valign="top"><a id="ae569195e094f31dbde1571a73ae96842"></a>
<a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add_multiplication_with_approximate_Hessian</b> (TargetT &amp;output, const TargetT &amp;input) const</td></tr>
<tr class="separator:ae569195e094f31dbde1571a73ae96842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">multiplication (sub)Hessian times input</div></td></tr>
<tr class="memitem:aa218e35d7106ddf704fbf566f79d51fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#aa218e35d7106ddf704fbf566f79d51fa">accumulate_Hessian_times_input</a> (TargetT &amp;output, const TargetT &amp;current_image_estimate, const TargetT &amp;input) const</td></tr>
<tr class="memdesc:aa218e35d7106ddf704fbf566f79d51fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions that multiply the True (sub)Hessian with a \'vector\'.  <a href="#aa218e35d7106ddf704fbf566f79d51fa">More...</a><br /></td></tr>
<tr class="separator:aa218e35d7106ddf704fbf566f79d51fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6714e04d2a25acfd727514325b278e"><td class="memItemLeft" align="right" valign="top"><a id="a9b6714e04d2a25acfd727514325b278e"></a>
<a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memItemRight" valign="bottom"><b>accumulate_Hessian_times_input_without_penalty</b> (TargetT &amp;output, const TargetT &amp;current_image_estimate, const TargetT &amp;input) const</td></tr>
<tr class="separator:a9b6714e04d2a25acfd727514325b278e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19987a622a3aa74be6bb2e6e8e07bf48"><td class="memItemLeft" align="right" valign="top"><a id="a19987a622a3aa74be6bb2e6e8e07bf48"></a>
<a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memItemRight" valign="bottom"><b>accumulate_sub_Hessian_times_input</b> (TargetT &amp;output, const TargetT &amp;current_image_estimate, const TargetT &amp;input, const int subset_num) const</td></tr>
<tr class="separator:a19987a622a3aa74be6bb2e6e8e07bf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0221a02b51cef234e7511a40eac0bad5"><td class="memItemLeft" align="right" valign="top"><a id="a0221a02b51cef234e7511a40eac0bad5"></a>
<a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memItemRight" valign="bottom"><b>accumulate_sub_Hessian_times_input_without_penalty</b> (TargetT &amp;output, const TargetT &amp;current_image_estimate, const TargetT &amp;input, const int subset_num) const</td></tr>
<tr class="separator:a0221a02b51cef234e7511a40eac0bad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classstir_1_1RegisteredObjectBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classstir_1_1RegisteredObjectBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classstir_1_1RegisteredObjectBase.html">stir::RegisteredObjectBase</a></td></tr>
<tr class="memitem:a9eb7d6e93407316c0780e2121e522ae4 inherit pub_methods_classstir_1_1RegisteredObjectBase"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1RegisteredObjectBase.html#a9eb7d6e93407316c0780e2121e522ae4">get_registered_name</a> () const =0</td></tr>
<tr class="memdesc:a9eb7d6e93407316c0780e2121e522ae4 inherit pub_methods_classstir_1_1RegisteredObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the type of the object.  <a href="classstir_1_1RegisteredObjectBase.html#a9eb7d6e93407316c0780e2121e522ae4">More...</a><br /></td></tr>
<tr class="separator:a9eb7d6e93407316c0780e2121e522ae4 inherit pub_methods_classstir_1_1RegisteredObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classstir_1_1ParsingObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classstir_1_1ParsingObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classstir_1_1ParsingObject.html">stir::ParsingObject</a></td></tr>
<tr class="memitem:a15b8a585ba2b09674b823446bf8481bf inherit pub_methods_classstir_1_1ParsingObject"><td class="memItemLeft" align="right" valign="top"><a id="a15b8a585ba2b09674b823446bf8481bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ParsingObject</b> (const <a class="el" href="classstir_1_1ParsingObject.html">ParsingObject</a> &amp;)</td></tr>
<tr class="separator:a15b8a585ba2b09674b823446bf8481bf inherit pub_methods_classstir_1_1ParsingObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20920a86db3428de6fd40381ef50aba4 inherit pub_methods_classstir_1_1ParsingObject"><td class="memItemLeft" align="right" valign="top"><a id="a20920a86db3428de6fd40381ef50aba4"></a>
<a class="el" href="classstir_1_1ParsingObject.html">ParsingObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classstir_1_1ParsingObject.html">ParsingObject</a> &amp;)</td></tr>
<tr class="separator:a20920a86db3428de6fd40381ef50aba4 inherit pub_methods_classstir_1_1ParsingObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268a7806a6ad7c78ec43f21582627163 inherit pub_methods_classstir_1_1ParsingObject"><td class="memItemLeft" align="right" valign="top"><a id="a268a7806a6ad7c78ec43f21582627163"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ask_parameters</b> ()</td></tr>
<tr class="separator:a268a7806a6ad7c78ec43f21582627163 inherit pub_methods_classstir_1_1ParsingObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7dc9a4725e6e6673b5cf36f8433a0b inherit pub_methods_classstir_1_1ParsingObject"><td class="memItemLeft" align="right" valign="top"><a id="acf7dc9a4725e6e6673b5cf36f8433a0b"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>parameter_info</b> ()</td></tr>
<tr class="separator:acf7dc9a4725e6e6673b5cf36f8433a0b inherit pub_methods_classstir_1_1ParsingObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8597c63ee9c4e5c927117daf35f2b129 inherit pub_methods_classstir_1_1ParsingObject"><td class="memItemLeft" align="right" valign="top"><a id="a8597c63ee9c4e5c927117daf35f2b129"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parse</b> (std::istream &amp;f)</td></tr>
<tr class="separator:a8597c63ee9c4e5c927117daf35f2b129 inherit pub_methods_classstir_1_1ParsingObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc5f10739c1dfb78fecd33c74d7d643 inherit pub_methods_classstir_1_1ParsingObject"><td class="memItemLeft" align="right" valign="top"><a id="aedc5f10739c1dfb78fecd33c74d7d643"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>parse</b> (const char *const filename)</td></tr>
<tr class="separator:aedc5f10739c1dfb78fecd33c74d7d643 inherit pub_methods_classstir_1_1ParsingObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7e96ad89d64c593d6cd36c195ce16fe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a7e96ad89d64c593d6cd36c195ce16fe9">set_defaults</a> () override</td></tr>
<tr class="memdesc:a7e96ad89d64c593d6cd36c195ce16fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets any default values  <a href="#a7e96ad89d64c593d6cd36c195ce16fe9">More...</a><br /></td></tr>
<tr class="separator:a7e96ad89d64c593d6cd36c195ce16fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac094cea58ba54853a5894f71b3285ca2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#ac094cea58ba54853a5894f71b3285ca2">initialise_keymap</a> () override</td></tr>
<tr class="memdesc:ac094cea58ba54853a5894f71b3285ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets parsing keys  <a href="#ac094cea58ba54853a5894f71b3285ca2">More...</a><br /></td></tr>
<tr class="separator:ac094cea58ba54853a5894f71b3285ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a46ab8367116185a14645f5b22cc85"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a89a46ab8367116185a14645f5b22cc85">actual_subsets_are_approximately_balanced</a> (std::string &amp;warning_message) const =0</td></tr>
<tr class="memdesc:a89a46ab8367116185a14645f5b22cc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of function that checks subset balancing.  <a href="#a89a46ab8367116185a14645f5b22cc85">More...</a><br /></td></tr>
<tr class="separator:a89a46ab8367116185a14645f5b22cc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f19e8ac5807a8b3166524132d618095"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a1f19e8ac5807a8b3166524132d618095">actual_compute_objective_function_without_penalty</a> (const TargetT &amp;current_estimate, const int subset_num)=0</td></tr>
<tr class="memdesc:a1f19e8ac5807a8b3166524132d618095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of function that computes the objective function for the current subset.  <a href="#a1f19e8ac5807a8b3166524132d618095">More...</a><br /></td></tr>
<tr class="separator:a1f19e8ac5807a8b3166524132d618095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae22977c2003d551fc3e9a743b105725"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#aae22977c2003d551fc3e9a743b105725">actual_add_multiplication_with_approximate_sub_Hessian_without_penalty</a> (TargetT &amp;output, const TargetT &amp;input, const int subset_num) const</td></tr>
<tr class="memdesc:aae22977c2003d551fc3e9a743b105725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the function that multiplies the approximate sub-Hessian with a vector.  <a href="#aae22977c2003d551fc3e9a743b105725">More...</a><br /></td></tr>
<tr class="separator:aae22977c2003d551fc3e9a743b105725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af748cde4790c3812831d3df186eb79ee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classstir_1_1Succeeded.html">Succeeded</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#af748cde4790c3812831d3df186eb79ee">actual_accumulate_sub_Hessian_times_input_without_penalty</a> (TargetT &amp;output, const TargetT &amp;current_image_estimate, const TargetT &amp;input, const int subset_num) const</td></tr>
<tr class="memdesc:af748cde4790c3812831d3df186eb79ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the function computes the sub-Hessian and multiplies by a vector.  <a href="#af748cde4790c3812831d3df186eb79ee">More...</a><br /></td></tr>
<tr class="separator:af748cde4790c3812831d3df186eb79ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classstir_1_1ParsingObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classstir_1_1ParsingObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classstir_1_1ParsingObject.html">stir::ParsingObject</a></td></tr>
<tr class="memitem:a76911426e945844fe3429191db43af77 inherit pro_methods_classstir_1_1ParsingObject"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1ParsingObject.html#a76911426e945844fe3429191db43af77">post_processing</a> ()</td></tr>
<tr class="memdesc:a76911426e945844fe3429191db43af77 inherit pro_methods_classstir_1_1ParsingObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will be called at the end of the parsing.  <a href="classstir_1_1ParsingObject.html#a76911426e945844fe3429191db43af77">More...</a><br /></td></tr>
<tr class="separator:a76911426e945844fe3429191db43af77 inherit pro_methods_classstir_1_1ParsingObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e81786834c010c96c31bce2bac3f6d inherit pro_methods_classstir_1_1ParsingObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1ParsingObject.html#ad8e81786834c010c96c31bce2bac3f6d">set_key_values</a> ()</td></tr>
<tr class="memdesc:ad8e81786834c010c96c31bce2bac3f6d inherit pro_methods_classstir_1_1ParsingObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will be called before parsing or parameter_info is called.  <a href="classstir_1_1ParsingObject.html#ad8e81786834c010c96c31bce2bac3f6d">More...</a><br /></td></tr>
<tr class="separator:ad8e81786834c010c96c31bce2bac3f6d inherit pro_methods_classstir_1_1ParsingObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0c290bd64ac9b2018ba2d994590aaec2"><td class="memItemLeft" align="right" valign="top"><a id="a0c290bd64ac9b2018ba2d994590aaec2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>num_subsets</b></td></tr>
<tr class="separator:a0c290bd64ac9b2018ba2d994590aaec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875beb74f08a6f881679f6326b698096"><td class="memItemLeft" align="right" valign="top"><a id="a875beb74f08a6f881679f6326b698096"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>already_set_up</b></td></tr>
<tr class="separator:a875beb74f08a6f881679f6326b698096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1171c563e716259820f59706353bf7b3"><td class="memItemLeft" align="right" valign="top"><a id="a1171c563e716259820f59706353bf7b3"></a>
shared_ptr&lt; <a class="el" href="classstir_1_1GeneralisedPrior.html">GeneralisedPrior</a>&lt; TargetT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>prior_sptr</b></td></tr>
<tr class="separator:a1171c563e716259820f59706353bf7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classstir_1_1ParsingObject"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classstir_1_1ParsingObject')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classstir_1_1ParsingObject.html">stir::ParsingObject</a></td></tr>
<tr class="memitem:ac53aef0f7ecd5dbb6204239b14e657f8 inherit pro_attribs_classstir_1_1ParsingObject"><td class="memItemLeft" align="right" valign="top"><a id="ac53aef0f7ecd5dbb6204239b14e657f8"></a>
<a class="el" href="classstir_1_1KeyParser.html">KeyParser</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parser</b></td></tr>
<tr class="separator:ac53aef0f7ecd5dbb6204239b14e657f8 inherit pro_attribs_classstir_1_1ParsingObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classstir_1_1RegisteredObject"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classstir_1_1RegisteredObject')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classstir_1_1RegisteredObject.html">stir::RegisteredObject&lt; GeneralisedObjectiveFunction&lt; TargetT &gt; &gt;</a></td></tr>
<tr class="memitem:aa32357a52b98c87a1c38a162355c874e inherit pub_static_methods_classstir_1_1RegisteredObject"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">GeneralisedObjectiveFunction</a>&lt; TargetT &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1RegisteredObject.html#aa32357a52b98c87a1c38a162355c874e">read_registered_object</a> (std::istream *in, const std::string &amp;registered_name)</td></tr>
<tr class="memdesc:aa32357a52b98c87a1c38a162355c874e inherit pub_static_methods_classstir_1_1RegisteredObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new object (of a type derived from Root, its actual type determined by the registered_name parameter) by parsing the istream.  <a href="classstir_1_1RegisteredObject.html#aa32357a52b98c87a1c38a162355c874e">More...</a><br /></td></tr>
<tr class="separator:aa32357a52b98c87a1c38a162355c874e inherit pub_static_methods_classstir_1_1RegisteredObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ba04aadc52e375e5e97961ddb8f5e1 inherit pub_static_methods_classstir_1_1RegisteredObject"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">GeneralisedObjectiveFunction</a>&lt; TargetT &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1RegisteredObject.html#a20ba04aadc52e375e5e97961ddb8f5e1">ask_type_and_parameters</a> ()</td></tr>
<tr class="memdesc:a20ba04aadc52e375e5e97961ddb8f5e1 inherit pub_static_methods_classstir_1_1RegisteredObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">ask the user for the type, and then calls read_registered_object(0, type)  <a href="classstir_1_1RegisteredObject.html#a20ba04aadc52e375e5e97961ddb8f5e1">More...</a><br /></td></tr>
<tr class="separator:a20ba04aadc52e375e5e97961ddb8f5e1 inherit pub_static_methods_classstir_1_1RegisteredObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7946572a60fac083300e2baaf650d6b8 inherit pub_static_methods_classstir_1_1RegisteredObject"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1RegisteredObject.html#a7946572a60fac083300e2baaf650d6b8">list_registered_names</a> (std::ostream &amp;stream)</td></tr>
<tr class="memdesc:a7946572a60fac083300e2baaf650d6b8 inherit pub_static_methods_classstir_1_1RegisteredObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all possible registered names to the stream.  <a href="classstir_1_1RegisteredObject.html#a7946572a60fac083300e2baaf650d6b8">More...</a><br /></td></tr>
<tr class="separator:a7946572a60fac083300e2baaf650d6b8 inherit pub_static_methods_classstir_1_1RegisteredObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classstir_1_1RegisteredObject"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classstir_1_1RegisteredObject')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classstir_1_1RegisteredObject.html">stir::RegisteredObject&lt; GeneralisedObjectiveFunction&lt; TargetT &gt; &gt;</a></td></tr>
<tr class="memitem:a4497941e1fe3ec79b7a75085d75488fb inherit pro_types_classstir_1_1RegisteredObject"><td class="memItemLeft" align="right" valign="top"><a id="a4497941e1fe3ec79b7a75085d75488fb"></a>
typedef <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">GeneralisedObjectiveFunction</a>&lt; TargetT &gt; *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1RegisteredObject.html#a4497941e1fe3ec79b7a75085d75488fb">RootFactory</a>) (std::istream *)</td></tr>
<tr class="memdesc:a4497941e1fe3ec79b7a75085d75488fb inherit pro_types_classstir_1_1RegisteredObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a root factory is a function, taking an istream* as argument, and returning a Root*. <br /></td></tr>
<tr class="separator:a4497941e1fe3ec79b7a75085d75488fb inherit pro_types_classstir_1_1RegisteredObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dc41fd8a2cb0a5e1118aa32df98711 inherit pro_types_classstir_1_1RegisteredObject"><td class="memItemLeft" align="right" valign="top"><a id="aa6dc41fd8a2cb0a5e1118aa32df98711"></a>
typedef <a class="el" href="classstir_1_1FactoryRegistry.html">FactoryRegistry</a>&lt; std::string, <a class="el" href="classstir_1_1RegisteredObject.html#a4497941e1fe3ec79b7a75085d75488fb">RootFactory</a>, <a class="el" href="structstir_1_1interfile__less.html">interfile_less</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1RegisteredObject.html#aa6dc41fd8a2cb0a5e1118aa32df98711">RegistryType</a></td></tr>
<tr class="memdesc:aa6dc41fd8a2cb0a5e1118aa32df98711 inherit pro_types_classstir_1_1RegisteredObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the registry. <br /></td></tr>
<tr class="separator:aa6dc41fd8a2cb0a5e1118aa32df98711 inherit pro_types_classstir_1_1RegisteredObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classstir_1_1RegisteredObject"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classstir_1_1RegisteredObject')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classstir_1_1RegisteredObject.html">stir::RegisteredObject&lt; GeneralisedObjectiveFunction&lt; TargetT &gt; &gt;</a></td></tr>
<tr class="memitem:a480c831d74fb41ff32787a908a07bbd3 inherit pro_static_methods_classstir_1_1RegisteredObject"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classstir_1_1RegisteredObject.html#aa6dc41fd8a2cb0a5e1118aa32df98711">RegistryType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstir_1_1RegisteredObject.html#a480c831d74fb41ff32787a908a07bbd3">registry</a> ()</td></tr>
<tr class="memdesc:a480c831d74fb41ff32787a908a07bbd3 inherit pro_static_methods_classstir_1_1RegisteredObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function returning the registry.  <a href="classstir_1_1RegisteredObject.html#a480c831d74fb41ff32787a908a07bbd3">More...</a><br /></td></tr>
<tr class="separator:a480c831d74fb41ff32787a908a07bbd3 inherit pro_static_methods_classstir_1_1RegisteredObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TargetT&gt;<br />
class stir::GeneralisedObjectiveFunction&lt; TargetT &gt;</h3>

<p>A base class for 'generalised' objective functions, i.e. objective functions for which at least a 'gradient' is defined. </p>
<p>Some iterative algorithms use an 'objective function' only in a loose sense. They might for instance allow generalisations which no longer optimise a function. For example in the case of <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html" title="An objective function class appropriate for PET emission data. ">PoissonLogLikelihoodWithLinearModelForMeanAndProjData</a> with non-matching forward and back projectors, the 'gradient' that is computed is generally not the gradient of the log-likelihood that corresponds to the forward projector. However, one hopes that it still points towards the optimum.</p>
<p>Often, one includes a penalty (or prior) in the objective function. This class uses a <a class="el" href="classstir_1_1GeneralisedPrior.html" title="A base class for &#39;generalised&#39; priors, i.e. priors for which at least a &#39;gradient&#39; is defined...">GeneralisedPrior</a> object for this. Note that we use the convention that the objective function is maximised. The penalty is expected to be a function that increases with higher penalty, so it will be <em>subtracted</em> from the unregularised case.</p>
<p>In tomography, we often use subsets, where the objective function is written as a sum of sub-objective functions. This class has some subset functionality. When using subsets, the penalty will be distributed evenly over all subsets. While this increases the computational cost, it makes the subsets more 'balanced' which is best for most algorithms.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classstir_1_1IterativeReconstruction.html" title="base class for iterative reconstruction objectsThis is the base class for all iterative reconstructio...">IterativeReconstruction</a></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000137">Todo:</a></b></dt><dd>Currently, there is subset code in both <a class="el" href="classstir_1_1IterativeReconstruction.html" title="base class for iterative reconstruction objectsThis is the base class for all iterative reconstructio...">IterativeReconstruction</a> and here. This is confusing and leads to repetition. It probably should all be moved here.</dd></dl>
<dl class="section user"><dt>Parameters for parsing</dt><dd></dd></dl>
<pre class="fragment">; specify prior, see GeneralisedObjectiveFunction&lt;TargetT&gt; hierarchy for possible values
prior type :=
</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac7d1bb65ad36569c4e78d81745e7db07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d1bb65ad36569c4e78d81745e7db07">&#9670;&nbsp;</a></span>construct_target_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TargetT* <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::construct_target_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a suitable target as determined by the parameters. </p>
<dl class="section warning"><dt>Warning</dt><dd>This should <b>not</b> check <code>already_set_up</code> (unfortunately), as it is currently called in <a class="el" href="classstir_1_1Reconstruction.html#a3a21f515d15e20c4281e3643aa170472" title="executes the reconstruction ">Reconstruction::reconstruct()</a> before calling <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a594bd9b807d2623fbf383d059140a808" title="Has to be called before using this object. ">set_up()</a>. </dd></dl>

<p>Implemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#a6196e239cd1e74f40d3d4bc67fd2860c">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin.html#af92cf6c9d4ff66b92478f43d9748e064">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html#a4ea50eeb2f34fe3c0097ad4b9836c295">stir::PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html#a85cb557cacfa656250174929368d765c">stir::PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion&lt; TargetT &gt;</a>, and <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html#a30b06373f619f8f37c49849e71afba53">stir::PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData&lt; TargetT &gt;</a>.</p>

</div>
</div>
<a id="a6291a5e5373517ddfb7ccbc259fdeef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6291a5e5373517ddfb7ccbc259fdeef6">&#9670;&nbsp;</a></span>compute_sub_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::compute_sub_gradient </td>
          <td>(</td>
          <td class="paramtype">TargetT &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>current_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>subset_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the subset-gradient of the objective function at <em>current_estimate</em>. </p>
<p>The subset-gradient is the gradient of the objective function restricted to the subset specified. What this means depends on how this function is implemented later on in the hierarchy.</p>
<p>Computed as the <em>difference</em> of <code>compute_sub_gradient_without_penalty</code> and <code><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a9c99dc70801b4cc6e909794f3889bb5f" title="Read-only access to the prior. ">get_prior_ptr()</a>-&gt;<a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a6f40f452c030412e33bd0b7a7f94046b" title="Compute the gradient of the objective function at the current_estimate. ">compute_gradient()</a>/num_subsets</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Any data in <em>gradient</em> will be overwritten. </dd></dl>

<p class="reference">References <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f">stir::error()</a>.</p>

</div>
</div>
<a id="a3d490db9b1171fc0fa198c93af4d78cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d490db9b1171fc0fa198c93af4d78cb">&#9670;&nbsp;</a></span>compute_sub_gradient_without_penalty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::compute_sub_gradient_without_penalty </td>
          <td>(</td>
          <td class="paramtype">TargetT &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>current_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>subset_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This should compute the subset-gradient of the unregularised objective function at <em>current_estimate</em>. </p>
<dl class="section warning"><dt>Warning</dt><dd>The derived class should overwrite any data in <em>gradient</em>. </dd></dl>

<p>Implemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMean.html#a35ccb0e304436def1a338a8c5c46d276">stir::PoissonLogLikelihoodWithLinearModelForMean&lt; TargetT &gt;</a>, and <a class="el" href="classstir_1_1SumOfGeneralisedObjectiveFunctions.html#ad0e1104f45c2b6c735e4a6d849184f28">stir::SumOfGeneralisedObjectiveFunctions&lt; PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;, TargetT, PoissonLogLikelihoodWithLinearModelForMean&lt; TargetT &gt; &gt;</a>.</p>

</div>
</div>
<a id="a6f40f452c030412e33bd0b7a7f94046b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f40f452c030412e33bd0b7a7f94046b">&#9670;&nbsp;</a></span>compute_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::compute_gradient </td>
          <td>(</td>
          <td class="paramtype">TargetT &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>current_estimate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the gradient of the objective function at the <em>current_estimate</em>. </p>
<p>Computed as the <em>difference</em> of <code>compute_gradient_without_penalty</code> and <code><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a9c99dc70801b4cc6e909794f3889bb5f" title="Read-only access to the prior. ">get_prior_ptr()</a>-&gt;<a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a6f40f452c030412e33bd0b7a7f94046b" title="Compute the gradient of the objective function at the current_estimate. ">compute_gradient()</a></code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Any data in <em>gradient</em> will be overwritten. </dd></dl>

</div>
</div>
<a id="a7ff0a08633f24353dd2773eb7aa8504d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff0a08633f24353dd2773eb7aa8504d">&#9670;&nbsp;</a></span>compute_gradient_without_penalty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::compute_gradient_without_penalty </td>
          <td>(</td>
          <td class="paramtype">TargetT &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>current_estimate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the gradient of the unregularised objective function at the <em>current_estimate</em>. </p>
<p>Computed by summing subset-gradients.</p>
<dl class="section warning"><dt>Warning</dt><dd>Any data in <em>gradient</em> will be overwritten. </dd></dl>

</div>
</div>
<a id="a2de6d1650b0eb144a73941a5f0ade96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de6d1650b0eb144a73941a5f0ade96b">&#9670;&nbsp;</a></span>compute_objective_function_without_penalty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::compute_objective_function_without_penalty </td>
          <td>(</td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>current_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>subset_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the value of the unregularised sub-objective function at the <em>current_estimate</em>. </p>
<p>Implemented in terms of actual_compute_objective_function_without_penalty. </p>

<p class="reference">References <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f">stir::error()</a>.</p>

</div>
</div>
<a id="a2b4fabaae9c18869ae00efa6f74ab57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4fabaae9c18869ae00efa6f74ab57f">&#9670;&nbsp;</a></span>compute_objective_function_without_penalty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::compute_objective_function_without_penalty </td>
          <td>(</td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>current_estimate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the value of the unregularised objective function at the <em>current_estimate</em>. </p>
<p>Computed by summing over all subsets. </p>

</div>
</div>
<a id="a77ce28ba6826afc2fbd303b65946b6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ce28ba6826afc2fbd303b65946b6d4">&#9670;&nbsp;</a></span>compute_penalty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::compute_penalty </td>
          <td>(</td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>current_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>subset_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value of the sub-penalty at the <em>current_estimate</em>. </p>
<p>As each subset contains the same penalty, this function returns the same as </p><div class="fragment"><div class="line"><a class="code" href="classstir_1_1GeneralisedObjectiveFunction.html#a77ce28ba6826afc2fbd303b65946b6d4">compute_penalty</a>(current_estimate)/num_subsets</div></div><!-- fragment --><p> Implemented in terms of <a class="el" href="classstir_1_1GeneralisedPrior.html#afa6d6e88ce44aed622b37aca1548910e" title="compute the value of the function ">GeneralisedPrior::compute_value</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#af9fd305b3f3b5070ee5c7b62e8b5fee5" title="Compute the value of the objective function at the current_estimate. ">compute_objective_function(const TargetT&amp;)</a> for sign conventions. </dd></dl>

</div>
</div>
<a id="a159b743f71bd2be8dc5441ecf580d373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159b743f71bd2be8dc5441ecf580d373">&#9670;&nbsp;</a></span>compute_penalty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::compute_penalty </td>
          <td>(</td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>current_estimate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value of the penalty at the <em>current_estimate</em>. </p>
<p>Implemented in terms of <a class="el" href="classstir_1_1GeneralisedPrior.html#afa6d6e88ce44aed622b37aca1548910e" title="compute the value of the function ">GeneralisedPrior::compute_value</a>. </p>

<p class="reference">References <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#aa8099c6ef0f97679d2e01d390af6798f">stir::GeneralisedObjectiveFunction&lt; TargetT &gt;::compute_value()</a>.</p>

</div>
</div>
<a id="a211f21d59b7d47f605a2f38a643bda68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211f21d59b7d47f605a2f38a643bda68">&#9670;&nbsp;</a></span>compute_objective_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::compute_objective_function </td>
          <td>(</td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>current_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>subset_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value of the sub-objective function at the <em>current_estimate</em>. </p>
<p>Computed as the <em>difference</em> of <code>compute_objective_function_without_penalty</code> and <code>compute_penalty</code>. </p>

</div>
</div>
<a id="af9fd305b3f3b5070ee5c7b62e8b5fee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fd305b3f3b5070ee5c7b62e8b5fee5">&#9670;&nbsp;</a></span>compute_objective_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::compute_objective_function </td>
          <td>(</td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>current_estimate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the value of the objective function at the <em>current_estimate</em>. </p>
<p>Computed as the <em>difference</em> of <code>compute_objective_function_without_penalty</code> and <code>compute_penalty</code>. </p>

</div>
</div>
<a id="abe5bfcded32b6d3339b5bb1be1995c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5bfcded32b6d3339b5bb1be1995c75">&#9670;&nbsp;</a></span>fill_nonidentifiable_target_parameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::fill_nonidentifiable_target_parameters </td>
          <td>(</td>
          <td class="paramtype">TargetT &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill any elements that we cannot estimate with a fixed value. </p>
<p>In many cases, it is easier to use a larger target than what we can actually estimate. For instance, using a rectangular image while we estimate only a circular region.</p>
<p>For some algorithms, it is important that the parameters that cannot be estimate are set to 0 (or some other value). For example, if the outer voxels contribute to the forward projection of an image, but not to a backprojection.</p>
<p>This function allows you to do that. Its default implementation is to do nothing. It is up to the derived class to implement this sensible.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000138">Todo:</a></b></dt><dd>The type of the value should really be derived from e.g. TargetT::full_iterator. </dd></dl>

<p>Reimplemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMean.html#ab9c794711edfbc2301bf945aa4334936">stir::PoissonLogLikelihoodWithLinearModelForMean&lt; TargetT &gt;</a>.</p>

</div>
</div>
<a id="ae3539db92b08bb08e3d5f700f523d943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3539db92b08bb08e3d5f700f523d943">&#9670;&nbsp;</a></span>add_multiplication_with_approximate_sub_Hessian_without_penalty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Succeeded.html">Succeeded</a> <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::add_multiplication_with_approximate_sub_Hessian_without_penalty </td>
          <td>(</td>
          <td class="paramtype">TargetT &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>subset_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functions that multiply the approximate (sub)Hessian with a \'vector\'. </p>
<p>All these functions add their result to any existing data in <em>output</em>.</p>
<p>They all call actual_add_multiplication_with_approximate_sub_Hessian_without_penalty. </p>

<p class="reference">References <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f">stir::error()</a>, and <a class="el" href="group__buildblock.html#ga45e27d9de6cdc69c146e791a825a20da">stir::warning()</a>.</p>

</div>
</div>
<a id="aa218e35d7106ddf704fbf566f79d51fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa218e35d7106ddf704fbf566f79d51fa">&#9670;&nbsp;</a></span>accumulate_Hessian_times_input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Succeeded.html">Succeeded</a> <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::accumulate_Hessian_times_input </td>
          <td>(</td>
          <td class="paramtype">TargetT &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>current_image_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functions that multiply the True (sub)Hessian with a \'vector\'. </p>
<p>All these functions add their result to any existing data in <em>output</em>.</p>
<p>They all call actual_accumulate_sub_Hessian_times_input_without_penalty. </p>

<p class="reference">References <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#aa218e35d7106ddf704fbf566f79d51fa">stir::GeneralisedObjectiveFunction&lt; TargetT &gt;::accumulate_Hessian_times_input()</a>, <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f">stir::error()</a>, and <a class="el" href="group__buildblock.html#ga45e27d9de6cdc69c146e791a825a20da">stir::warning()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#aa218e35d7106ddf704fbf566f79d51fa">stir::GeneralisedObjectiveFunction&lt; TargetT &gt;::accumulate_Hessian_times_input()</a>.</p>

</div>
</div>
<a id="a4712dc126b185ab17926283c3331ec2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4712dc126b185ab17926283c3331ec2c">&#9670;&nbsp;</a></span>set_num_subsets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::set_num_subsets </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_subsets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to change the number of subsets. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of subsets that will be used later, which is not guaranteed to be what you asked for. </dd></dl>

<p>Implemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#a0c440f6db030a8da5ecc495e131eba22">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html#a250aeaf7f8cacf6e6bb7213c45dff5a8">stir::PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html#a116e1518bc49e82acdfae4b4c5601a41">stir::PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin.html#a83892e66acaf7235cc609f895d4e69fe">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin&lt; TargetT &gt;</a>, and <a class="el" href="classstir_1_1SumOfGeneralisedObjectiveFunctions.html#a5c76239072c8daec3e9a6082797a590c">stir::SumOfGeneralisedObjectiveFunctions&lt; PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;, TargetT, PoissonLogLikelihoodWithLinearModelForMean&lt; TargetT &gt; &gt;</a>.</p>

</div>
</div>
<a id="a44734aea00b7cf5ce40fd8f21367e9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44734aea00b7cf5ce40fd8f21367e9d5">&#9670;&nbsp;</a></span>subsets_are_approximately_balanced() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::subsets_are_approximately_balanced </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks of the current subset scheme is approximately balanced. </p>
<p>Balanced subsets means that the sub-gradients point all roughly in the same direction (at least when far from the optimum).</p>
<p>This function tests if this is approximately true, such that a reconstruction algorithm can either adapt or abort.</p>
<p>Implemented in terms of actual_subsets_are_approximately_balanced(std::string&amp;). </p>

</div>
</div>
<a id="a655f803224f2de4512bc144b7d67ca84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655f803224f2de4512bc144b7d67ca84">&#9670;&nbsp;</a></span>subsets_are_approximately_balanced() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::subsets_are_approximately_balanced </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>warning_message</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks of the current subset scheme is approximately balanced and constructs a warning message. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a44734aea00b7cf5ce40fd8f21367e9d5" title="Checks of the current subset scheme is approximately balanced. ">subsets_are_approximately_balanced()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warning_message</td><td>A string variable. If the subsets are not (approx.) balanced, this function will <b>append</b> a warning message explaining why. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f">stir::error()</a>.</p>

</div>
</div>
<a id="a9c99dc70801b4cc6e909794f3889bb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c99dc70801b4cc6e909794f3889bb5f">&#9670;&nbsp;</a></span>get_prior_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1GeneralisedPrior.html">GeneralisedPrior</a>&lt; TargetT &gt; *const <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::get_prior_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read-only access to the prior. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000139">Todo:</a></b></dt><dd>It would be nicer to not return a pointer. </dd></dl>

</div>
</div>
<a id="ab19b31d2e22c5806201dabaaaafd9962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19b31d2e22c5806201dabaaaafd9962">&#9670;&nbsp;</a></span>set_prior_sptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::set_prior_sptr </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classstir_1_1GeneralisedPrior.html">GeneralisedPrior</a>&lt; TargetT &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the prior. </p>
<dl class="section warning"><dt>Warning</dt><dd>You should call <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a594bd9b807d2623fbf383d059140a808" title="Has to be called before using this object. ">set_up()</a> again after using this function. </dd></dl>

</div>
</div>
<a id="a191d2641fe116852e66c99212fde3b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191d2641fe116852e66c99212fde3b50">&#9670;&nbsp;</a></span>set_input_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::set_input_data </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classstir_1_1ExamData.html">ExamData</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set_input_data </p>
<dl class="section author"><dt>Author</dt><dd>Nikos Efthimiou</dd></dl>
<p>It can be used to set the data to be reconstructed within some other code, as opposed to via parsing. </p>

<p>Implemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#ae704bdda17f877f4c26df17e0f777bf0">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html#a124710ed930ee043ccc8ad6fe52247be">stir::PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html#afaf645d8d18ad3152a9d66b5d3d460a7">stir::PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData&lt; TargetT &gt;</a>, and <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeData.html#a62c604a22485010d6f924f549f7b84b3">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeData&lt; TargetT &gt;</a>.</p>

</div>
</div>
<a id="a8304392cf449fbe3bfbb490ddc74bb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8304392cf449fbe3bfbb490ddc74bb1d">&#9670;&nbsp;</a></span>get_input_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classstir_1_1ExamData.html">ExamData</a>&amp; <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::get_input_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get input data </p>
<p>Will throw an exception if it wasn't set first </p>

<p>Implemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#ad9d4871ba741d472b9be26856015a953">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html#a89a5ea992f50f9afb60930a5fa27aa2a">stir::PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html#a7995ad9ac095f9b83eced77e103f6932">stir::PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData&lt; TargetT &gt;</a>, and <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeData.html#a9d5fb1147e30052e4d03ebbd15d3e0dd">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeData&lt; TargetT &gt;</a>.</p>

</div>
</div>
<a id="a9605e9d34ed5d9851951ea0d9ffb4862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9605e9d34ed5d9851951ea0d9ffb4862">&#9670;&nbsp;</a></span>set_additive_proj_data_sptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::set_additive_proj_data_sptr </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classstir_1_1ExamData.html">ExamData</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set_additive_proj_data_sptr </p>
<dl class="section author"><dt>Author</dt><dd>Nikos Efthimiou</dd></dl>
<p>In the case the reconstruction process is called from another piece of code, the user should be able to set any additive sinogram </p>

<p>Implemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#ac991c48f9b1d3175ce4cbbf54f01990f">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html#a56fb65d8dec9f41969dd4950ec7186ee">stir::PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html#a39b2cd91bc11d2637ba670bed46c94f2">stir::PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData&lt; TargetT &gt;</a>, and <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeData.html#ae55a22de9af725a7e25820b5dc94ec2a">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeData&lt; TargetT &gt;</a>.</p>

</div>
</div>
<a id="ae8b4e611dcb36d3d690e64939e46d2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b4e611dcb36d3d690e64939e46d2dd">&#9670;&nbsp;</a></span>set_normalisation_sptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::set_normalisation_sptr </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; <a class="el" href="classstir_1_1BinNormalisation.html">BinNormalisation</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set_normalisation_sptr </p>
<dl class="section author"><dt>Author</dt><dd>Nikos Efthimiou</dd></dl>
<p>In the case the reconstruction process is called from another piece of code, the user should be able to set any additive sinogram </p>

<p>Implemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#a6284273b0b09e91b497a5b5050dac29c">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html#a9b6464f6e913c8e60e9261ecb0a7c857">stir::PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html#a854e69a3f3dd53122e8bc7b457b936d8">stir::PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData&lt; TargetT &gt;</a>, and <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeData.html#abd3063652ca9eafa1a3aad4f400b92fa">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeData&lt; TargetT &gt;</a>.</p>

</div>
</div>
<a id="a7e96ad89d64c593d6cd36c195ce16fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e96ad89d64c593d6cd36c195ce16fe9">&#9670;&nbsp;</a></span>set_defaults()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::set_defaults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets any default values </p>
<p>Has to be called by set_defaults in the leaf-class </p>

<p>Reimplemented from <a class="el" href="classstir_1_1ParsingObject.html#ad5f86478612a06b86e28adf664afcd74">stir::ParsingObject</a>.</p>

<p>Reimplemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#af3429f92e4cb1c70eb77a0cbc076ffd6">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMean.html#a24114e4d481b1829e72bd574fa5c98c5">stir::PoissonLogLikelihoodWithLinearModelForMean&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html#a77a6a0f1592cde80ad5da880c97f4b4b">stir::PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeData.html#aae43d6da4b83a44467409a080e7aea51">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html#af1b5d306f5ca28c5c1d5aa242ab6552b">stir::PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndDynamicProjData.html#abcca67c186e40a1472040422406642db">stir::PoissonLogLikelihoodWithLinearModelForMeanAndDynamicProjData&lt; TargetT &gt;</a>, and <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin.html#a6fddea8a787afc402089bcbd1885c150">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin&lt; TargetT &gt;</a>.</p>

</div>
</div>
<a id="ac094cea58ba54853a5894f71b3285ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac094cea58ba54853a5894f71b3285ca2">&#9670;&nbsp;</a></span>initialise_keymap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::initialise_keymap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets parsing keys </p>
<p>Has to be called by initialise_keymap in the leaf-class </p>

<p>Reimplemented from <a class="el" href="classstir_1_1ParsingObject.html#a6997d88d93e295e096a7c2eda925d4b6">stir::ParsingObject</a>.</p>

<p>Reimplemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#ad2622ee1e04f21bc32eedeb977c23472">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMean.html#ac7c0b83ce8f415cbfc2d736a108e7f26">stir::PoissonLogLikelihoodWithLinearModelForMean&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html#ac26b8b37c7df96d802e141584e82d305">stir::PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeData.html#a874a8abb79861e8450a9400030cb8195">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html#aded20dab37f6b69ea9edbd481c31f2b1">stir::PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndDynamicProjData.html#a6d28e22184066e46219ebd3846e84cc1">stir::PoissonLogLikelihoodWithLinearModelForMeanAndDynamicProjData&lt; TargetT &gt;</a>, and <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin.html#abf1a19e85bb229a59f2c51746087c43a">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin&lt; TargetT &gt;</a>.</p>

</div>
</div>
<a id="a89a46ab8367116185a14645f5b22cc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a46ab8367116185a14645f5b22cc85">&#9670;&nbsp;</a></span>actual_subsets_are_approximately_balanced()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::actual_subsets_are_approximately_balanced </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>warning_message</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of function that checks subset balancing. </p>
<dl class="section see"><dt>See also</dt><dd>subsets_are_approximately_balanced(std::string&amp;)</dd></dl>
<dl class="section user"><dt>Developer\'s note</dt><dd></dd></dl>
<p>The reason we have this function is that overloading subsets_are_approximately_balanced(std::string&amp;) in a derived class would hide <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html#a44734aea00b7cf5ce40fd8f21367e9d5" title="Checks of the current subset scheme is approximately balanced. ">subsets_are_approximately_balanced()</a>. </p>

<p>Implemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#a4b863e78e523e4790f407844409da15f">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html#af96157154a2a99922949ca84236e05ad">stir::PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html#a0a25f3b77a4599545bc61fed66830bc0">stir::PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin.html#a8c726a5b2b38fa36eb983c6d8b517fed">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndDynamicProjData.html#a26469a84323ec6d1efffc820c2efd79d">stir::PoissonLogLikelihoodWithLinearModelForMeanAndDynamicProjData&lt; TargetT &gt;</a>, and <a class="el" href="classstir_1_1SumOfGeneralisedObjectiveFunctions.html#ad133b896ff6307ce2cb5a70388c95f43">stir::SumOfGeneralisedObjectiveFunctions&lt; PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;, TargetT, PoissonLogLikelihoodWithLinearModelForMean&lt; TargetT &gt; &gt;</a>.</p>

</div>
</div>
<a id="a1f19e8ac5807a8b3166524132d618095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f19e8ac5807a8b3166524132d618095">&#9670;&nbsp;</a></span>actual_compute_objective_function_without_penalty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::actual_compute_objective_function_without_penalty </td>
          <td>(</td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>current_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>subset_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of function that computes the objective function for the current subset. </p>
<dl class="section see"><dt>See also</dt><dd>compute_objective_function_without_penalty(const Target&amp;,const int)</dd></dl>
<dl class="section user"><dt>Developer\'s note</dt><dd></dd></dl>
<p>The reason we have this function is that overloading a function in a derived class, hides all functions of the same name. </p>

<p>Implemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#ab454cb26a2cd744e4f21fef9f1217187">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html#a08e4b0ccb5436c00c05ce925f0d71a19">stir::PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin.html#ac31fcd4e142d17b8b56df7ae20074ed6">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin&lt; TargetT &gt;</a>, and <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html#af3fe9e6100d7935be3df0c763d517823">stir::PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData&lt; TargetT &gt;</a>.</p>

</div>
</div>
<a id="aae22977c2003d551fc3e9a743b105725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae22977c2003d551fc3e9a743b105725">&#9670;&nbsp;</a></span>actual_add_multiplication_with_approximate_sub_Hessian_without_penalty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Succeeded.html">Succeeded</a> <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::actual_add_multiplication_with_approximate_sub_Hessian_without_penalty </td>
          <td>(</td>
          <td class="paramtype">TargetT &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>subset_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the function that multiplies the approximate sub-Hessian with a vector. </p>
<dl class="section see"><dt>See also</dt><dd>multiplication_with_approximate_sub_Hessian_without_penalty(TargetT&amp;,const TargetT&amp;, const int).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The default implementation just calls <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f" title="Print error with format string a la printf and throw exception. ">error()</a>. This behaviour has to be overloaded by the derived classes.</dd></dl>
<dl class="section user"><dt>Developer\'s note</dt><dd></dd></dl>
<p>The reason we have this function is that overloading a function in a derived class, hides all functions of the same name. </p>

<p>Reimplemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#aa272b8557da413ec8cf863dd23f52575">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html#a8aef031a2f956dd2378a8a157b1b24f5">stir::PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion&lt; TargetT &gt;</a>, and <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html#ae95e4121cf70ed9331f52914dedf377a">stir::PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData&lt; TargetT &gt;</a>.</p>

<p class="reference">References <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f">stir::error()</a>.</p>

</div>
</div>
<a id="af748cde4790c3812831d3df186eb79ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af748cde4790c3812831d3df186eb79ee">&#9670;&nbsp;</a></span>actual_accumulate_sub_Hessian_times_input_without_penalty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstir_1_1Succeeded.html">Succeeded</a> <a class="el" href="classstir_1_1GeneralisedObjectiveFunction.html">stir::GeneralisedObjectiveFunction</a>&lt; TargetT &gt;::actual_accumulate_sub_Hessian_times_input_without_penalty </td>
          <td>(</td>
          <td class="paramtype">TargetT &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>current_image_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TargetT &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>subset_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the function computes the sub-Hessian and multiplies by a vector. </p>
<dl class="section see"><dt>See also</dt><dd>accumulate_sub_Hessian_times_input_without_penalty(TargetT&amp;,const TargetT&amp;, TargetT&amp;, const int).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The default implementation just calls <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f" title="Print error with format string a la printf and throw exception. ">error()</a>. This behaviour has to be overloaded by the derived classes.</dd></dl>
<dl class="section user"><dt>Developer\'s note</dt><dd></dd></dl>
<p>The reason we have this function is that overloading a function in a derived class, hides all functions of the same name. </p>

<p>Reimplemented in <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndProjData.html#a164e646e2c79adeaf03945d3e082f1de">stir::PoissonLogLikelihoodWithLinearModelForMeanAndProjData&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion.html#a67f1d4ce333d05556739b61f799a38b4">stir::PoissonLogLikelihoodWithLinearModelForMeanAndGatedProjDataWithMotion&lt; TargetT &gt;</a>, <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin.html#aa0448446f695b2f737e966d908837626">stir::PoissonLogLikelihoodWithLinearModelForMeanAndListModeDataWithProjMatrixByBin&lt; TargetT &gt;</a>, and <a class="el" href="classstir_1_1PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData.html#a639474a396f56761f641590e836392cd">stir::PoissonLogLikelihoodWithLinearKineticModelAndDynamicProjectionData&lt; TargetT &gt;</a>.</p>

<p class="reference">References <a class="el" href="group__buildblock.html#ga19b3ad285f04d613640a497f868b385f">stir::error()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/sirfuser/devel/STIRdistrib/STIR/src/include/stir/recon_buildblock/<a class="el" href="GeneralisedObjectiveFunction_8h_source.html">GeneralisedObjectiveFunction.h</a></li>
<li>/home/sirfuser/devel/STIRdistrib/STIR/src/recon_buildblock/<a class="el" href="GeneralisedObjectiveFunction_8cxx.html">GeneralisedObjectiveFunction.cxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 23 2024 09:13:14 for STIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
